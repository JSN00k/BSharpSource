grammar org.xtext.sampleProj.mydsl.MyDsl with org.eclipse.xtext.common.Terminals

generate myDsl "http://www.xtext.org/sampleProj/mydsl/MyDsl"

DomainModel:
	(elements+=TopLevel)*;
	
// Theorem names can include white space.
//terminal THM_NAME: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9' ' | '|'\t')*;
	
TopLevel:
	ImportStatement | ClassDecl;
	

ImportStatement:
	'Import'
		imports+=Import
;

Import:
	importName+=ImportComponent ('.' importName+=ImportComponent)
;

ImportComponent:
	name=ID
;

ClassDecl:
	Class | Datatype | Extend
;

Class returns BppClass:
	'Class' typeName=TypeName (context=PolyContext)? (supertypes=SuperTypeList)? '{' (bodyElements+=TypeBodyElements)* '}'
;

Name: PolymorphicTypeName | TypeName;

TypeName: name=ID;

/*---------------- Polymorphic Context -------------------------- */

PolymorphicTypeName: name=ID;

PolyContext:
	'<' (polyTypes+=PolyContextTypes)+ '>'
;

PolyContextTypes:
	name=PolymorphicTypeName (constraints+=PolyTypeConstraints)*
;

PolyTypeConstraints:
	':' typeName+=[TypeName] (',' typeName+=[TypeName])*
;

/* ------------------- SuperTypes ---------------------------------- */

/* Any constriction on the polymorphic context has to be done by declaring the polymorphic context
 * on the new type. If necessary the polymorphic context can be used within type constructors. In the simple case 
 * this will be infered . Required thought on checking the base types of the super types. At some points these
 * need to be identical declarations. It is also necessary to allow EventB style type constructors at this
 * point. e.g., an associative operator is a subtype of a closed Event-B total function.
 */
SuperTypeList:
	':' superType+=ConstructedType (',' superType+=ConstructedType)*
;

/* Along with the normal Event-B type operator, and new B++ types the  */
ConstructedType:
	type+=TypeConstructor (('×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠') type+=ConstructedType)?
;

/* Type constructor has validation rules to check that there is no context when there is a polymorphic name, 
 * and type checking on the polymorphic context. There is also  scope rule to check the usage of polymorphic types.
 */
TypeConstructor:
	typeName=[Name] (context+=TypeDeclContext)?
;

TypeDeclContext:
	'<' typeName+=ConstructedType (',' typeName+=ConstructedType)* '>'
;

/* -------------------- Next Thing -------------------------------- */

/* This may need to be changed when we can construct the types more. */
TypedVariable:
	name=ID constraints+=PolyTypeConstraints
;

TypeDeclaration:
	typeName=[TypeName] context=TypeDeclContext
;

Where:
	'where' expessions+=Expression (';' expressions+=Expression)
;

TypeBodyElements:
	 (functions+=FunctionDecl) | (theorems+=TheoremBody)
;

FunctionName:
	name=ID
;

Datatype:
	'Datatype' name=TypeName (context+=PolyContext)? (constructors+=DatatypeConstructor)* '{' (bodyElements+=TypeBodyElements)* '}'
;

DatatypeConstructor:
	BaseConstructor | Constructor
;

BaseConstructor:
	name=ID
;

Constructor:
	name=ID '(' (typedVariables+=TypedVariable)* ')'
;

Extend: 
	name=[TypeName] '(' extesnion=ID ')' '{' (bodyElements+=TypeBodyElements)* '}'
;

FunctionDecl:
	name+=FunctionName '(' (typeVariables+=TypedVariable)* ')'
;

TheoremBody:
	'Theorems' '{'  '}'
;

Expression:
	// This needs to be written. Could be worth separating this out into another 
	// dsl reducing the complexity of this section. Specifically I need to look out for
	// the following expressions forall exists lambda function calls.
	name=ID
;