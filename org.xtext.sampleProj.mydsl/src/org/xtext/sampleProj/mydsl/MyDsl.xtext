grammar org.xtext.sampleProj.mydsl.MyDsl with org.eclipse.xtext.common.Terminals

generate myDsl "http://www.xtext.org/sampleProj/mydsl/MyDsl"

DomainModel:
	(elements+=TopLevel)*;
	
// Theorem names can include white space.
THM_NAME: (ID | WS)* ":";
	
TopLevel:
	ImportStatement | ClassDecl;
	

ImportStatement:
	'Import'
		imports+=Import
;

Import:
	importName+=ImportComponent ('.' importName+=ImportComponent)
;

ImportComponent:
	name=ID
;

ClassDecl:
	Class | Datatype | Extend
;

/* ------------------------ Class statements --------------------- */


Class returns BppClass:
	'Class' typeName=TypeName (context=PolyContext)? (supertypes=SuperTypeList)? (typeStructure=TypeStructure)? (where=Where)? (';')? '{' (bodyElements+=TypeBodyElements)* '}'
;

Name: PolymorphicTypeName | TypeName;

TypeName: name=ID;

/*---------------- Polymorphic Context -------------------------- */

PolymorphicTypeName: name=ID;

PolyContext:
	'<' (polyTypes+=PolyContextTypes)+ '>'
;

PolyContextTypes:
	name=PolymorphicTypeName (constraints+=PolyTypeConstraints)*
;

PolyTypeConstraints:
	':' typeName+=[TypeName] (',' typeName+=[TypeName])*
;

/* ------------------- SuperTypes ---------------------------------- */

/* Any constriction on the polymorphic context has to be done by declaring the polymorphic context
 * on the new type. If necessary the polymorphic context can be used within type constructors. In the simple case 
 * this will be inferred . Required thought on checking the base types of the super types. At some points these
 * need to be identical declarations. It is also necessary to allow EventB style type constructors at this
 * point. e.g., an associative operator is a subtype of a closed Event-B total function.
 */
SuperTypeList:
	':' superType+=ConstructedType (',' superType+=ConstructedType)*
;

/* Along with the normal Event-B type operator, and new B++ types the  */
ConstructedType:
	type+=TypeConstructor (('×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠') type+=ConstructedType)?
;

/* Type constructor has validation rules to check that there is no context when there is a polymorphic name, 
 * and type checking on the polymorphic context. There is also  scope rule to check the usage of polymorphic types.
 * Probably need to add the predicate type to this.
 */
TypeConstructor:
	typeName=[Name] (context+=TypeDeclContext)?
;

TypeDeclContext:
	'<' typeName+=ConstructedType (',' typeName+=ConstructedType)* '>'
;

/* -------------------- Type Structure ---------------------------------- */

TypeStructure:
	'(' variables=TypedVariableList ')'
;

/* -------------------- Where Statement -------------------------------- */

/* Type checking (which is not implemented yet) is used to type check that Expression returns a 
 * predicate. Expression has not yet been written, but is far too general to be included in the where
 * statement.
 */
Where:
	'where' expessions+=Expression (';' expressions+=Expression)*
;

/* ---------------------- Datatype declarations -------------------------- */

Datatype:
	'Datatype' name=TypeName (context=PolyContext)? (constructors+=DatatypeConstructor)* '{' (bodyElements+=TypeBodyElements)* '}'
;

/* PolyContext is the same as PolyContext used by the class declaration above. */

DatatypeConstructor:
	'|' (BaseConstructor | DTypeConstructor)
;

BaseConstructor:
	name=ID
;

/* Typed Variable list is declared below, it is used in several situations such as functions/lambdas
 * not just in Datatypes.
 */
DTypeConstructor:
	name=ID '(' decons=TypedVariableList ')'
;

/* ------------------------ Extension statement ---------------------------- */

Extend: 
	name=[TypeName] '(' extesnion=ID ')' '{' (bodyElements+=TypeBodyElements)* '}'
;

/* ------------------------ TypeBodyElements ------------------------------- */

TypeBodyElements:
	 (functions+=FunctionDecl) | (theorems+=TheoremBody)
;

/*------------------------- Functions --------------------------------- */

FunctionDecl:
	name+=FunctionName (context=PolyContext)? '(' (variables=TypedVariableList)? ')' body=FunctionBody ':' returnType=TypeConstructor
;

FunctionName:
	name=ID
;

FunctionBody:
	FuncInductive | FuncDirectDef
;

/* The expression will be type checked to make sure that it returns the expected type. The result of type checking
 * will have three possible result. A negative result giving an error e.g., the type returned by the expression 
 * cannot match the return type. An undetermined result, a proof obligation is generated so the user can prove
 * demonstrate the expression returns the correct type. A positive result, the expected type is returned by the
 * expression, and the user is not required to do anything. In the case of an intermediate result the type system
 * assumes that the declaration is true, however, there will still be the unsatisfied proof obligation showing
 * that the system is unproven */
FuncDirectDef:
	expression=Expression
;

FuncInductive:
	'match' variableName=[TypedVariable]
	inductCase+=FuncInductiveCase (inductCase+=FuncInductiveCase)*
;

FuncInductiveCase:
	'|' deconName=[DTypeConstructor] ':' expre=Expression
;

/* ----------------------------- Theorems -------------------------*/

TheoremBody:
	'Theorems' '{' (theoremDecl+=TheoremDecl)+ '}'
;

/* Type check that the expression is a predicate expression. */
TheoremDecl:
	thmName=THM_NAME exp=Expression
;

TypedVariableList:
	typeVar+=TypedVariable (',' typeVar+=TypedVariable)*
;

TypedVariable:
	name=ID ':' type=ConstructedType
;

TypeDeclaration:
	typeName=[TypeName] context=TypeDeclContext
;

/* --------------------------- Expressions -------------------------- */

Expression:
	// This needs to be written. Could be worth separating this out into another 
	// dsl reducing the complexity of this section. Specifically I need to look out for
	// the following expressions forall exists lambda function calls.
	name=ID
;

BuiltIn:
	Lambda | Quantifier | Prefix | Infix | Functional
;

Lambda:
	'λ' (varList=TypedVariableList)? '|' expr=Expression
;

/* --------------------- Quantifiers ------------------------- */
Quantifier:

	('∀' | '∃') varList=TypedVariableList? '·' expr=Expression
;

/* ---------------------- *Fix ------------------------------ */

Prefix:
	name=PrefixBuiltIn expr=Expression
;

PrefixBuiltIn:
	'¬'
;

/* Infix operators cause problems, there are two issues one is avoiding left recursion this 
 * is covered adequately here: https://www.eclipse.org/Xtext/documentation/307_special_languages.html#expressions 
 * The second issue is precedence, this is also covered in the link above, however, implementing it in the 
 * way suggested above will not scale to the creation of ones own infix functions, instead the initial implementation
 * will require brackets for precedence. After that a system will be implemented where each infix operator will 
 * be given a precedence value with higher values being higher precedence. It looks like this can be done by
 * changing the parser using the MyDSLRuntimeModule to build the abstract syntax tree based on the value of the 
 * operators.
 * Before the precedence code is written into a parser override, all the expressions are in effect right bracketed,
 * as you may expect from a language that is read from left to right.
 */
 
Infix:
	left=Element (name+=InfixOpName expr2+=Infix)* 
;

Element:
	Bracket | FunctionCall | Instance
;

Bracket:
	'(' Infix ')'
;

/* Change this to be builtin infix operators, and declared infix operators. */
InfixOpName:
	name=ID
;
