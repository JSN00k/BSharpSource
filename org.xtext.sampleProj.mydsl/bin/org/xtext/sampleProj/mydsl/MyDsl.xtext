grammar org.xtext.sampleProj.mydsl.MyDsl with org.eclipse.xtext.common.Terminals

generate myDsl "http://www.xtext.org/sampleProj/mydsl/MyDsl"

DomainModel:
	(elements+=TopLevel)*;
	
// Theorem names can include white space. Work out how to change this to any string without a ':'
THM_NAME: (INT | ID | WS)* ":";
	
TopLevel:
	ImportStatement | ClassDecl | Extend | Instance;
	

ImportStatement:
	'Import'
		imports+=Import
;

Import:
	importName+=ImportComponent ('.' importName+=ImportComponent)
;

ImportComponent:
	name=ID
;

ClassDecl returns ClassDecl:
	Class | Datatype
;

/* ------------------------ Class statements --------------------- */


Class returns BppClass:
	'Class' typeName=TypeName (context=PolyContext)? (supertypes=SuperTypeList)? (varList=TypeStructure)? (where=Where)? (';')? 
	'{' (bodyElements+=TypeBodyElements)* '}'
;

GenName: PolymorphicTypeName | TypeName;

TypeName: name=ID;

/*---------------- Polymorphic Context of -------------------------- */

PolymorphicTypeName: name=ID;

PolyContext:
	'<' (polyTypes+=PolyContextTypes)+ '>'
;

PolyContextTypes:
	name=PolymorphicTypeName (constraints+=PolyTypeConstraints)*
;

PolyTypeConstraints:
	':' TypeName+=[TypeName] (',' TypeName+=[TypeName])*
;

/* ------------------- SuperTypes ---------------------------------- */

/* Any constriction on the polymorphic context has to be done by declaring the polymorphic context
 * on the new type. If necessary the polymorphic context can be used within type constructors. In the simple case 
 * this will be inferred . Required thought on checking the base types of the super types. At some points these
 * need to be identical declarations. It is also necessary to allow EventB style type constructors at this
 * point. e.g., an associative operator is a subtype of a closed Event-B total function.
 */
SuperTypeList:
	':' superType+=ConstructedType (',' superType+=ConstructedType)*
;

/* Along with the normal Event-B type operator, and new B++ types the  */
ConstructedType:
	type+=TypeConstructor (('×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠') type+=ConstructedType)?
;

/* Type constructor has validation rules to check that there is no context when there is a polymorphic name, 
 * and type checking on the polymorphic context. There is also  scope rule to check the usage of polymorphic types.
 * Probably need to add the predicate type to this.
 */
TypeConstructor:
	(TypeName=[GenName] | InbuiltTypeScan) (context+=TypeDeclContext)?
;

TypeDeclContext:
	'<' TypeName+=ConstructedType (',' TypeName+=ConstructedType)* '>'
;

/* -------------------- Type Structure ---------------------------------- */

TypeStructure:
	'(' variables=TypedVariableList ')'
;

/* -------------------- Where Statement -------------------------------- */

/* Type checking (which is not implemented yet) is used to type check that Expression returns a 
 * predicate. Expression has not yet been written, but is far too general to be included in the where
 * statement.
 */
Where:
	'where' expessions+=Quantifier (';' expressions+=RootExpression)*
;

/* ---------------------- Datatype declarations -------------------------- */

Datatype:
	'Datatype' typeName=TypeName (context=PolyContext)? (constructors+=DatatypeConstructor)* '{' (bodyElements+=TypeBodyElements)* '}'
;

/* PolyContext is the same as PolyContext used by the class declaration above. */

DatatypeConstructor:
	'|' (BaseConstructor | DTypeConstructor)
;

BaseConstructor:
	name=ID
;

/* Typed Variable list is declared below, it is used in several situations such as functions/lambdas
 * not just in Datatypes.
 */
DTypeConstructor:
	name=ID '(' decons=TypedVariableList ')'
;

/* ------------------------ Extension statement ---------------------------- */

Extend: 
	'Extend' name=[TypeName] '(' extension=ID ')' '{' (bodyElements+=TypeBodyElements)* '}'
;

/* ------------------------ TypeBodyElements ------------------------------- */

TypeBodyElements:
	 (functions+=FunctionDecl) | (theorems+=TheoremBody)
;

/*------------------------- Functions --------------------------------- */

FunctionDecl:
	name+=FunctionName (context=PolyContext)? '(' (varList=TypedVariableList)? ')' ':' returnType=TypeConstructor body=FunctionBody
;

FunctionName:
	name=ID
;

FunctionBody:
	FuncInductive | FuncDirectDef
;

/* The expression will be type checked to make sure that it returns the expected type. The result of type checking
 * will have three possible result. A negative result giving an error e.g., the type returned by the expression 
 * cannot match the return type. An undetermined result, a proof obligation is generated so the user can prove
 * demonstrate the expression returns the correct type. A positive result, the expected type is returned by the
 * expression, and the user is not required to do anything. In the case of an intermediate result the type system
 * assumes that the declaration is true, however, there will still be the unsatisfied proof obligation showing
 * that the system is unproven */
FuncDirectDef:
	expression=RootExpression
;

FuncInductive:
	'match' variableName=[TypedVariable]
	inductCase+=FuncInductiveCase (inductCase+=FuncInductiveCase)*
;

FuncInductiveCase:
	'|' deconName=[DTypeConstructor] ':' expre=RootExpression
;

/* ----------------------------- Theorems -------------------------*/

TheoremBody:
	'Theorems' '{' (theoremDecl+=TheoremDecl)+ '}'
;

/* Type check that the expression is a predicate expression. */
TheoremDecl:
	thmName=THM_NAME exp=RootExpression ';'
;

TypedVariableList:
	 variablesOfType+=VariableTyping (',' variablesOfType+=VariableTyping)*
;

VariableTyping:
	((typeVar+=TypedVariable) (',' typeVar+=TypedVariable)* ':' type=ConstructedType)
;

TypedVariable:
	name=ID
;

TypeDeclaration:
	TypeName=[TypeName] context=TypeDeclContext
;

/* --------------------------- Expressions -------------------------- */

/* --------------------------- Lambda and Quantifier ---------------- */

/* The structure of Lambda and Quantifier are so similar that they're going to share a class */

Lambda returns QuantLambda:
	qType='λ' (context=PolyContext)? varList=TypedVariableList '|' child=RootExpression
;

Quantifier returns QuantLambda:
	qType=('∀' | '∃') (context=PolyContext)? varList=TypedVariableList '·' child=RootExpression
;

RootExpression returns Expression:
	Lambda | Quantifier | Infix
;

/* ---------------------- *Fix ------------------------------ */

Prefix:
	name=PrefixBuiltIn elem=Element
;

PrefixBuiltIn:
	'¬'
;

/* Infix operators cause problems, there are two issues one is avoiding left recursion this 
 * is covered adequately here: https://www.eclipse.org/Xtext/documentation/307_special_languages.html#expressions 
 * The second issue is precedence, this is also covered in the link above, however, implementing it in the 
 * way suggested above will not scale to the creation of ones own infix functions, instead the initial implementation
 * will require brackets for precedence. After that a system will be implemented where each infix operator will 
 * be given a precedence value with higher values being higher precedence. It looks like this can be done by
 * changing the parser using the MyDSLRuntimeModule to build the abstract syntax tree based on the value of the 
 * operators.
 * Before the precedence code is written into a parser override, all the expressions are in effect right bracketed,
 * as you may expect from a language that is read from left to right.
 * 
 * TODO: Programmatically check that the function is an infix function.
 */
Infix returns Expression:
	Element ({Infix.left=current} (funcName+=[FunctionName] | opName+=InbuiltInfix) right+=Element)* 
;

/* currently it will not build because the quantifier is causing recursion I think. 
 * I think that we need a quantifier free expression to solve the problem Similar to the way
 * precedence is handled here: https://typefox.io/parsing-expressions-with-xtext
 */
Element returns Expression:
	Bracket | Prefix | FunctionCall
;

Bracket returns Expression:
	'(' RootExpression ')'
;


/* This produces an interesting issue in parsing the program because it is necessary to distinguish between the following three
 * scenarios: 
 * A function call f(arguments)
 * A infix function with a bracketed argument on the right 10 f (arguments)
 * A function used without any arguments f add g 
 * 
 * To solve this functions can either be Prefix, Infix, or called with bracketed arguments. You cannot call a Infix function with bracketd 
 * arguments. To do this you would need to write another function to make this call for you. In coq this is achieved when you declare a function
 * you can add a operator name to the function, which is either infix or prefix, this again gives the two names for the function allowing 
 * it to be called either as an operator or a functional call.
 * 
 * This expressions needs a lot of programmatic checking! Starting with the count of the arguments, followed by type checking the arguments.
 */
FunctionCall returns Expression:
	(typeInst=TypeInstance) ('(' (arguments+=Infix)? (',' arguments+=Infix)* ')')?
;

ExpressionType:
	TypeName
;

ExpressionVariable:
	 FunctionName | TypedVariable | ExpressionType
;

/* With Parametric polymorphism classes e.g., Class ReflexRel<T> : T × T → Pred we can use ReflexRel directly 
 * within an expression as it is the ReflexRel operator. However, with similar type class declarations:
 * Class Group : Monoid where ... Does it make sense to be able to be able to use Group directly? it 
 * refers to the whole type. I think that I'm conceptually ok to treat Group or ReflexRel as a polymorphic
 * instance of the super type, and later treat it more like a set, It strikes me that this is a concept 
 * already familiar to Generics where we're reasoning using a generic type (which is in a sense a subtype of
 * its own.
 * 
 * The below statement needs scoping all polymorphic types have to be locally declared.
 */
 TypeInstance:
 	(instance=[ExpressionVariable]) | (typeName=[GenName] ('.' element+=[TypedVariable])+)
 ;

InbuiltInfix:
	'⇔' | '⇒' | '=' | '≠' | '∧' | '∨'
;

/* Consider whether to add other inbuilt types such as Integers etc. Given the lack of 
 * recursion in the inbuilt types it may be better to  */
InbuiltType:
	'Pred'
;

InbuiltTypeScan:
	name=InbuiltType
;

/* I feel like I should need these, however, I'm not sure when they would be necessary. */
//InbuiltTypeInstance:
//	'⊤' | '⊥'
//;
//
//InbuiltTypeInstanceScan:
//	name=InbuiltTypeInstance
//;

/* ------------------------------ Instance ---------------------------------------------*/

Instance:
	'Instance' className=[TypeName] context=TypeDeclContext '(' (arguments+=Infix)? (',' arguments+=Infix)* ')'
;

/* TODO: Implement Methods,  Infix keyword and precedence on Infix operators. */
