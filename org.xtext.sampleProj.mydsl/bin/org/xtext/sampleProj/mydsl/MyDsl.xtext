grammar org.xtext.sampleProj.mydsl.MyDsl with org.eclipse.xtext.common.Terminals

generate myDsl "http://www.xtext.org/sampleProj/mydsl/MyDsl"

DomainModel:
	(elements+=TopLevel)*;
	
// Theorem names can include white space.
//terminal THM_NAME: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9' ' | '|'\t')*;
	
TopLevel:
	ImportStatement | ClassDecl;
	

ImportStatement:
	'Import'
		imports+=Import
;

Import:
	importName+=ImportComponent ('.' importName+=ImportComponent)
;

ImportComponent:
	name=ID
;

ClassDecl:
	Class | Datatype | Extend
;

Class:
	'Class' typeName=TypeName (context+=PolyContext)? (supertypes+=Supertype)? '{' (bodyElements+=TypeBodyElements)* '}'
;

Name: PolymorphicTypeName | TypeName;

TypeName: name=ID;

PolymorphicTypeName: name=ID;

PolyContext:
	'<' (polyTypes+=PolyContextTypes)+ '>'
;

PolyContextTypes:
	name=PolymorphicTypeName (constraints+=TypeConstraints)*
;


TypeConstraints:
	':' typeName+=[TypeName] (',' typeName+=[TypeName])*
;

TypedVariable:
	name=ID constraints+=TypeConstraints
;

Supertype:
	':' superType+=ConstructedType (',' superType+=ConstructedType)*
;

TypeDeclaration:
	typeName=[TypeName] context=TypeDeclContext
;

/* Along with the normal Event-B type operator, and new B++ types the  */
ConstructedType:
	type+=TypeConstructor (('×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠') type+=ConstructedType)?
;

/* Type constructor has validation rules to check that there is no context when there is a polymorphic name, 
 * and type checking on the polymorphic context. There is also  scope rule to check the usage of polymorphic types.
 */
TypeConstructor:
	typeName+=[Name] (context+=TypeDeclContext)?
;

TypeDeclContext:
	'<' typeName+=ConstructedType (',' typeName+=ConstructedType)* '>'
;

//ConcreteTypeDecl:
//	PolymorphicTypeName | TypeConstructor | ConstructedType
//;
//
//TypeConstructor:
//	typeName+=[TypeName] (context+=TypeDeclContext)?
//;
//
//TypeDeclContext:
//	'<' typeName+=ConcreteTypeDecl (',' typeName+=ConcreteTypeDecl)* '>'
//;
//
//ConstructedType:
//	type+=TypeConstructor (('×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠') type+=TypeConstructor)?
//;


Where:
	'where' expessions+=Expression (';' expressions+=Expression)
;

TypeBodyElements:
	 (functions+=FunctionDecl) | (theorems+=TheoremBody)
;

FunctionName:
	name=ID
;

Datatype:
	'Datatype' name=TypeName (context+=PolyContext)? (constructors+=DatatypeConstructor)* '{' (bodyElements+=TypeBodyElements)* '}'
;

DatatypeConstructor:
	BaseConstructor | Constructor
;

BaseConstructor:
	name=ID
;

Constructor:
	name=ID '(' (typedVariables+=TypedVariable)* ')'
;

Extend: 
	name=[TypeName] '(' extesnion=ID ')' '{' (bodyElements+=TypeBodyElements)* '}'
;

FunctionDecl:
	name+=FunctionName '(' (typeVariables+=TypedVariable)* ')'
;

TheoremBody:
	'Theorems' '{'  '}'
;

Expression:
	// This needs to be written. Could be worth separating this out into another 
	// dsl reducing the complexity of this section. Specifically I need to look out for
	// the following expressions forall exists lambda function calls.
	name=ID
;