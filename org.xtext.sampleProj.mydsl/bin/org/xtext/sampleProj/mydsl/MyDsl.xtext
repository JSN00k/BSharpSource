grammar org.xtext.sampleProj.mydsl.MyDsl with org.eclipse.xtext.common.Terminals

generate myDsl "http://www.xtext.org/sampleProj/mydsl/MyDsl"

DomainModel:
	(elements+=TopLevel)*;
	
// Theorem names can include white space.
//terminal THM_NAME: '^' -> ":";
	
TopLevel:
	ImportStatement | ClassDecl;
	

ImportStatement:
	'Import'
		imports+=Import
;

Import:
	importName+=ImportComponent ('.' importName+=ImportComponent)
;

ImportComponent:
	name=ID
;

ClassDecl:
	Class | Datatype | Extend
;

/* ------------------------ Class statements --------------------- */

Class returns BppClass:
	'Class' typeName=TypeName (context=PolyContext)? (supertypes=SuperTypeList)? (where=Where)? '{' (bodyElements+=TypeBodyElements)* '}'
;

Name: PolymorphicTypeName | TypeName;

TypeName: name=ID;

/*---------------- Polymorphic Context -------------------------- */

PolymorphicTypeName: name=ID;

PolyContext:
	'<' (polyTypes+=PolyContextTypes)+ '>'
;

PolyContextTypes:
	name=PolymorphicTypeName (constraints+=PolyTypeConstraints)*
;

PolyTypeConstraints:
	':' typeName+=[TypeName] (',' typeName+=[TypeName])*
;

/* ------------------- SuperTypes ---------------------------------- */

/* Any constriction on the polymorphic context has to be done by declaring the polymorphic context
 * on the new type. If necessary the polymorphic context can be used within type constructors. In the simple case 
 * this will be inferred . Required thought on checking the base types of the super types. At some points these
 * need to be identical declarations. It is also necessary to allow EventB style type constructors at this
 * point. e.g., an associative operator is a subtype of a closed Event-B total function.
 */
SuperTypeList:
	':' superType+=ConstructedType (',' superType+=ConstructedType)*
;

/* Along with the normal Event-B type operator, and new B++ types the  */
ConstructedType:
	type+=TypeConstructor (('×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠') type+=ConstructedType)?
;

/* Type constructor has validation rules to check that there is no context when there is a polymorphic name, 
 * and type checking on the polymorphic context. There is also  scope rule to check the usage of polymorphic types.
 */
TypeConstructor:
	typeName=[Name] (context+=TypeDeclContext)?
;

TypeDeclContext:
	'<' typeName+=ConstructedType (',' typeName+=ConstructedType)* '>'
;

/* -------------------- Where Statement -------------------------------- */

/* Type checking (which is not implemented yet) is used to type check that Expression returns a 
 * predicate. Expression has not yet been written, but is far too general to be included in the where
 * statement.
 */
Where:
	'where' expessions+=Expression (';' expressions+=Expression)
;

/* ---------------------- Datatype declarations -------------------------- */

Datatype:
	'Datatype' name=TypeName (context=PolyContext)? (constructors+=DatatypeConstructor)* '{' (bodyElements+=TypeBodyElements)* '}'
;

/* PolyContext is the same as PolyContext used by the class declaration above. */

DatatypeConstructor:
	'|' (BaseConstructor | DTypeConstructor)
;

BaseConstructor:
	name=ID
;

/* Typed Variable list is declared below, it is used in several situations such as functions/lambdas
 * not just in Datatypes.
 */
DTypeConstructor:
	name=ID '(' decons=TypedVariableList ')'
;

/* ------------------------ Extension statement ---------------------------- */

Extend: 
	name=[TypeName] '(' extesnion=ID ')' '{' (bodyElements+=TypeBodyElements)* '}'
;

/* ------------------------ TypeBodyElements ------------------------------- */

TypeBodyElements:
	 (functions+=FunctionDecl) | (theorems+=TheoremBody)
;

/*------------------------- Functions --------------------------------- */

FunctionDecl:
	name+=FunctionName (context=PolyContext)? '(' (variables=TypedVariableList)? ')' body=FunctionBody ':' returnType=TypeConstructor
;

FunctionBody:
	FuncInductive | FuncDirectDef
;

/* The expression will be type checked to make sure that it returns the expected type. The result of type checking
 * will have three possible result. A negative result giving an error e.g., the type returned by the expression 
 * cannot match the return type. An undetermined result, a proof obligation is generated so the user can prove
 * demonstrate the expression returns the correct type. A positive result, the expected type is returned by the
 * expression, and the user is not required to do anything. In the case of an intermediate result the type system
 * assumes that the declaration is true, however, there will still be the unsatisfied proof obligation showing
 * that the system is unproven */
FuncDirectDef:
	expression=Expression
;

FuncInductive:
	'match' variableName=[TypedVariable]
	inductCase+=FuncInductiveCase (inductCase+=FuncInductiveCase)*
;

FuncInductiveCase:
	'|' deconName=[DTypeConstructor] ':' expre=Expression
;

/* ----------------------------- Theorems -------------------------*/

TheoremBody:
	'Theorems' '{' (theoremDecl+=TheoremDecl)+ '}'
;

TheoremDecl:
	thmName=ID
;

TypedVariableList:
	typeVar+=TypedVariable (',' typeVar+=TypedVariable)
;

TypedVariable:
	name=ID ':' type=ConstructedType
;

TypeDeclaration:
	typeName=[TypeName] context=TypeDeclContext
;

FunctionName:
	name=ID
;

Expression:
	// This needs to be written. Could be worth separating this out into another 
	// dsl reducing the complexity of this section. Specifically I need to look out for
	// the following expressions forall exists lambda function calls.
	name=ID
;