/*
 * generated by Xtext 2.13.0
 */
package org.xtext.sampleProj.mydsl.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class MyDslGrammarAccess extends AbstractGrammarElementFinder {
	
	public class DomainModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.DomainModel");
		private final Assignment cElementsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cElementsTopLevelParserRuleCall_0 = (RuleCall)cElementsAssignment.eContents().get(0);
		
		//DomainModel:
		//	elements+=TopLevel*;
		@Override public ParserRule getRule() { return rule; }
		
		//elements+=TopLevel*
		public Assignment getElementsAssignment() { return cElementsAssignment; }
		
		//TopLevel
		public RuleCall getElementsTopLevelParserRuleCall_0() { return cElementsTopLevelParserRuleCall_0; }
	}
	public class THM_NAMEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.THM_NAME");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//// Theorem names can include white space.
		//THM_NAME:
		//	(ID | WS)* ":";
		@Override public ParserRule getRule() { return rule; }
		
		//(ID | WS)* ":"
		public Group getGroup() { return cGroup; }
		
		//(ID | WS)*
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0_0() { return cIDTerminalRuleCall_0_0; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_0_1() { return cWSTerminalRuleCall_0_1; }
		
		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
	}
	public class TopLevelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TopLevel");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cImportStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cClassDeclParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//TopLevel:
		//	ImportStatement | ClassDecl;
		@Override public ParserRule getRule() { return rule; }
		
		//ImportStatement | ClassDecl
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ImportStatement
		public RuleCall getImportStatementParserRuleCall_0() { return cImportStatementParserRuleCall_0; }
		
		//ClassDecl
		public RuleCall getClassDeclParserRuleCall_1() { return cClassDeclParserRuleCall_1; }
	}
	public class ImportStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.ImportStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cImportsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImportsImportParserRuleCall_1_0 = (RuleCall)cImportsAssignment_1.eContents().get(0);
		
		//ImportStatement:
		//	'Import'
		//	imports+=Import;
		@Override public ParserRule getRule() { return rule; }
		
		//'Import' imports+=Import
		public Group getGroup() { return cGroup; }
		
		//'Import'
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }
		
		//imports+=Import
		public Assignment getImportsAssignment_1() { return cImportsAssignment_1; }
		
		//Import
		public RuleCall getImportsImportParserRuleCall_1_0() { return cImportsImportParserRuleCall_1_0; }
	}
	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Import");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cImportNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cImportNameImportComponentParserRuleCall_0_0 = (RuleCall)cImportNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cImportNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cImportNameImportComponentParserRuleCall_1_1_0 = (RuleCall)cImportNameAssignment_1_1.eContents().get(0);
		
		//Import:
		//	importName+=ImportComponent ('.' importName+=ImportComponent);
		@Override public ParserRule getRule() { return rule; }
		
		//importName+=ImportComponent ('.' importName+=ImportComponent)
		public Group getGroup() { return cGroup; }
		
		//importName+=ImportComponent
		public Assignment getImportNameAssignment_0() { return cImportNameAssignment_0; }
		
		//ImportComponent
		public RuleCall getImportNameImportComponentParserRuleCall_0_0() { return cImportNameImportComponentParserRuleCall_0_0; }
		
		//'.' importName+=ImportComponent
		public Group getGroup_1() { return cGroup_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }
		
		//importName+=ImportComponent
		public Assignment getImportNameAssignment_1_1() { return cImportNameAssignment_1_1; }
		
		//ImportComponent
		public RuleCall getImportNameImportComponentParserRuleCall_1_1_0() { return cImportNameImportComponentParserRuleCall_1_1_0; }
	}
	public class ImportComponentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.ImportComponent");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//ImportComponent:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class ClassDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.ClassDecl");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cClassParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDatatypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cExtendParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//ClassDecl:
		//	Class | Datatype | Extend;
		@Override public ParserRule getRule() { return rule; }
		
		//Class | Datatype | Extend
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Class
		public RuleCall getClassParserRuleCall_0() { return cClassParserRuleCall_0; }
		
		//Datatype
		public RuleCall getDatatypeParserRuleCall_1() { return cDatatypeParserRuleCall_1; }
		
		//Extend
		public RuleCall getExtendParserRuleCall_2() { return cExtendParserRuleCall_2; }
	}
	public class ClassElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Class");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cClassKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeNameTypeNameParserRuleCall_1_0 = (RuleCall)cTypeNameAssignment_1.eContents().get(0);
		private final Assignment cContextAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cContextPolyContextParserRuleCall_2_0 = (RuleCall)cContextAssignment_2.eContents().get(0);
		private final Assignment cSupertypesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cSupertypesSuperTypeListParserRuleCall_3_0 = (RuleCall)cSupertypesAssignment_3.eContents().get(0);
		private final Assignment cTypeStructureAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cTypeStructureTypeStructureParserRuleCall_4_0 = (RuleCall)cTypeStructureAssignment_4.eContents().get(0);
		private final Assignment cWhereAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cWhereWhereParserRuleCall_5_0 = (RuleCall)cWhereAssignment_5.eContents().get(0);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cLeftCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cBodyElementsAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cBodyElementsTypeBodyElementsParserRuleCall_8_0 = (RuleCall)cBodyElementsAssignment_8.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		///* ------------------------ Class statements --------------------- */ Class BppClass:
		//	'Class' typeName=TypeName context=PolyContext? supertypes=SuperTypeList? typeStructure=TypeStructure? where=Where?
		//	';'? '{' bodyElements+=TypeBodyElements* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'Class' typeName=TypeName context=PolyContext? supertypes=SuperTypeList? typeStructure=TypeStructure? where=Where? ';'?
		//'{' bodyElements+=TypeBodyElements* '}'
		public Group getGroup() { return cGroup; }
		
		//'Class'
		public Keyword getClassKeyword_0() { return cClassKeyword_0; }
		
		//typeName=TypeName
		public Assignment getTypeNameAssignment_1() { return cTypeNameAssignment_1; }
		
		//TypeName
		public RuleCall getTypeNameTypeNameParserRuleCall_1_0() { return cTypeNameTypeNameParserRuleCall_1_0; }
		
		//context=PolyContext?
		public Assignment getContextAssignment_2() { return cContextAssignment_2; }
		
		//PolyContext
		public RuleCall getContextPolyContextParserRuleCall_2_0() { return cContextPolyContextParserRuleCall_2_0; }
		
		//supertypes=SuperTypeList?
		public Assignment getSupertypesAssignment_3() { return cSupertypesAssignment_3; }
		
		//SuperTypeList
		public RuleCall getSupertypesSuperTypeListParserRuleCall_3_0() { return cSupertypesSuperTypeListParserRuleCall_3_0; }
		
		//typeStructure=TypeStructure?
		public Assignment getTypeStructureAssignment_4() { return cTypeStructureAssignment_4; }
		
		//TypeStructure
		public RuleCall getTypeStructureTypeStructureParserRuleCall_4_0() { return cTypeStructureTypeStructureParserRuleCall_4_0; }
		
		//where=Where?
		public Assignment getWhereAssignment_5() { return cWhereAssignment_5; }
		
		//Where
		public RuleCall getWhereWhereParserRuleCall_5_0() { return cWhereWhereParserRuleCall_5_0; }
		
		//';'?
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_7() { return cLeftCurlyBracketKeyword_7; }
		
		//bodyElements+=TypeBodyElements*
		public Assignment getBodyElementsAssignment_8() { return cBodyElementsAssignment_8; }
		
		//TypeBodyElements
		public RuleCall getBodyElementsTypeBodyElementsParserRuleCall_8_0() { return cBodyElementsTypeBodyElementsParserRuleCall_8_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_9() { return cRightCurlyBracketKeyword_9; }
	}
	public class NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPolymorphicTypeNameParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypeNameParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Name:
		//	PolymorphicTypeName | TypeName;
		@Override public ParserRule getRule() { return rule; }
		
		//PolymorphicTypeName | TypeName
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PolymorphicTypeName
		public RuleCall getPolymorphicTypeNameParserRuleCall_0() { return cPolymorphicTypeNameParserRuleCall_0; }
		
		//TypeName
		public RuleCall getTypeNameParserRuleCall_1() { return cTypeNameParserRuleCall_1; }
	}
	public class TypeNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TypeName");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//TypeName:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class PolymorphicTypeNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.PolymorphicTypeName");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		///*---------------- Polymorphic Context -------------------------- */ PolymorphicTypeName:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class PolyContextElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.PolyContext");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPolyTypesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPolyTypesPolyContextTypesParserRuleCall_1_0 = (RuleCall)cPolyTypesAssignment_1.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//PolyContext:
		//	'<' polyTypes+=PolyContextTypes+ '>';
		@Override public ParserRule getRule() { return rule; }
		
		//'<' polyTypes+=PolyContextTypes+ '>'
		public Group getGroup() { return cGroup; }
		
		//'<'
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }
		
		//polyTypes+=PolyContextTypes+
		public Assignment getPolyTypesAssignment_1() { return cPolyTypesAssignment_1; }
		
		//PolyContextTypes
		public RuleCall getPolyTypesPolyContextTypesParserRuleCall_1_0() { return cPolyTypesPolyContextTypesParserRuleCall_1_0; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_2() { return cGreaterThanSignKeyword_2; }
	}
	public class PolyContextTypesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.PolyContextTypes");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNamePolymorphicTypeNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cConstraintsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConstraintsPolyTypeConstraintsParserRuleCall_1_0 = (RuleCall)cConstraintsAssignment_1.eContents().get(0);
		
		//PolyContextTypes:
		//	name=PolymorphicTypeName constraints+=PolyTypeConstraints*;
		@Override public ParserRule getRule() { return rule; }
		
		//name=PolymorphicTypeName constraints+=PolyTypeConstraints*
		public Group getGroup() { return cGroup; }
		
		//name=PolymorphicTypeName
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//PolymorphicTypeName
		public RuleCall getNamePolymorphicTypeNameParserRuleCall_0_0() { return cNamePolymorphicTypeNameParserRuleCall_0_0; }
		
		//constraints+=PolyTypeConstraints*
		public Assignment getConstraintsAssignment_1() { return cConstraintsAssignment_1; }
		
		//PolyTypeConstraints
		public RuleCall getConstraintsPolyTypeConstraintsParserRuleCall_1_0() { return cConstraintsPolyTypeConstraintsParserRuleCall_1_0; }
	}
	public class PolyTypeConstraintsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.PolyTypeConstraints");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cTypeNameTypeNameCrossReference_1_0 = (CrossReference)cTypeNameAssignment_1.eContents().get(0);
		private final RuleCall cTypeNameTypeNameIDTerminalRuleCall_1_0_1 = (RuleCall)cTypeNameTypeNameCrossReference_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cTypeNameAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final CrossReference cTypeNameTypeNameCrossReference_2_1_0 = (CrossReference)cTypeNameAssignment_2_1.eContents().get(0);
		private final RuleCall cTypeNameTypeNameIDTerminalRuleCall_2_1_0_1 = (RuleCall)cTypeNameTypeNameCrossReference_2_1_0.eContents().get(1);
		
		//PolyTypeConstraints:
		//	':' typeName+=[TypeName] (',' typeName+=[TypeName])*;
		@Override public ParserRule getRule() { return rule; }
		
		//':' typeName+=[TypeName] (',' typeName+=[TypeName])*
		public Group getGroup() { return cGroup; }
		
		//':'
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }
		
		//typeName+=[TypeName]
		public Assignment getTypeNameAssignment_1() { return cTypeNameAssignment_1; }
		
		//[TypeName]
		public CrossReference getTypeNameTypeNameCrossReference_1_0() { return cTypeNameTypeNameCrossReference_1_0; }
		
		//ID
		public RuleCall getTypeNameTypeNameIDTerminalRuleCall_1_0_1() { return cTypeNameTypeNameIDTerminalRuleCall_1_0_1; }
		
		//(',' typeName+=[TypeName])*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//typeName+=[TypeName]
		public Assignment getTypeNameAssignment_2_1() { return cTypeNameAssignment_2_1; }
		
		//[TypeName]
		public CrossReference getTypeNameTypeNameCrossReference_2_1_0() { return cTypeNameTypeNameCrossReference_2_1_0; }
		
		//ID
		public RuleCall getTypeNameTypeNameIDTerminalRuleCall_2_1_0_1() { return cTypeNameTypeNameIDTerminalRuleCall_2_1_0_1; }
	}
	public class SuperTypeListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.SuperTypeList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSuperTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSuperTypeConstructedTypeParserRuleCall_1_0 = (RuleCall)cSuperTypeAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cSuperTypeAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cSuperTypeConstructedTypeParserRuleCall_2_1_0 = (RuleCall)cSuperTypeAssignment_2_1.eContents().get(0);
		
		///* ------------------- SuperTypes ---------------------------------- */ /* Any constriction on the polymorphic context has to be done by declaring the polymorphic context
		// * on the new type. If necessary the polymorphic context can be used within type constructors. In the simple case 
		// * this will be inferred . Required thought on checking the base types of the super types. At some points these
		// * need to be identical declarations. It is also necessary to allow EventB style type constructors at this
		// * point. e.g., an associative operator is a subtype of a closed Event-B total function.
		// */ SuperTypeList:
		//	':' superType+=ConstructedType (',' superType+=ConstructedType)*;
		@Override public ParserRule getRule() { return rule; }
		
		//':' superType+=ConstructedType (',' superType+=ConstructedType)*
		public Group getGroup() { return cGroup; }
		
		//':'
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }
		
		//superType+=ConstructedType
		public Assignment getSuperTypeAssignment_1() { return cSuperTypeAssignment_1; }
		
		//ConstructedType
		public RuleCall getSuperTypeConstructedTypeParserRuleCall_1_0() { return cSuperTypeConstructedTypeParserRuleCall_1_0; }
		
		//(',' superType+=ConstructedType)*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//superType+=ConstructedType
		public Assignment getSuperTypeAssignment_2_1() { return cSuperTypeAssignment_2_1; }
		
		//ConstructedType
		public RuleCall getSuperTypeConstructedTypeParserRuleCall_2_1_0() { return cSuperTypeConstructedTypeParserRuleCall_2_1_0; }
	}
	public class ConstructedTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.ConstructedType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeTypeConstructorParserRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Keyword cMultiplicationSignKeyword_1_0_0 = (Keyword)cAlternatives_1_0.eContents().get(0);
		private final Keyword cRightwardsArrowKeyword_1_0_1 = (Keyword)cAlternatives_1_0.eContents().get(1);
		private final Keyword cPrivateUseAreaE102Keyword_1_0_2 = (Keyword)cAlternatives_1_0.eContents().get(2);
		private final Keyword cPrivateUseAreaE100Keyword_1_0_3 = (Keyword)cAlternatives_1_0.eContents().get(3);
		private final Keyword cLeftRightArrowKeyword_1_0_4 = (Keyword)cAlternatives_1_0.eContents().get(4);
		private final Keyword cRightwardsTwoHeadedArrowWithTailKeyword_1_0_5 = (Keyword)cAlternatives_1_0.eContents().get(5);
		private final Keyword cRightwardsArrowWithVerticalStrokeKeyword_1_0_6 = (Keyword)cAlternatives_1_0.eContents().get(6);
		private final Keyword cRightwardsArrowWithTailKeyword_1_0_7 = (Keyword)cAlternatives_1_0.eContents().get(7);
		private final Keyword cRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_1_0_8 = (Keyword)cAlternatives_1_0.eContents().get(8);
		private final Keyword cRightwardsTwoHeadedArrowKeyword_1_0_9 = (Keyword)cAlternatives_1_0.eContents().get(9);
		private final Assignment cTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypeConstructedTypeParserRuleCall_1_1_0 = (RuleCall)cTypeAssignment_1_1.eContents().get(0);
		
		///* Along with the normal Event-B type operator, and new B++ types the  */ ConstructedType:
		//	type+=TypeConstructor (('×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠') type+=ConstructedType)?;
		@Override public ParserRule getRule() { return rule; }
		
		//type+=TypeConstructor (('×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠') type+=ConstructedType)?
		public Group getGroup() { return cGroup; }
		
		//type+=TypeConstructor
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//TypeConstructor
		public RuleCall getTypeTypeConstructorParserRuleCall_0_0() { return cTypeTypeConstructorParserRuleCall_0_0; }
		
		//(('×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠') type+=ConstructedType)?
		public Group getGroup_1() { return cGroup_1; }
		
		//'×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠'
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//'×'
		public Keyword getMultiplicationSignKeyword_1_0_0() { return cMultiplicationSignKeyword_1_0_0; }
		
		//'→'
		public Keyword getRightwardsArrowKeyword_1_0_1() { return cRightwardsArrowKeyword_1_0_1; }
		
		//''
		public Keyword getPrivateUseAreaE102Keyword_1_0_2() { return cPrivateUseAreaE102Keyword_1_0_2; }
		
		//''
		public Keyword getPrivateUseAreaE100Keyword_1_0_3() { return cPrivateUseAreaE100Keyword_1_0_3; }
		
		//'↔'
		public Keyword getLeftRightArrowKeyword_1_0_4() { return cLeftRightArrowKeyword_1_0_4; }
		
		//'⤖'
		public Keyword getRightwardsTwoHeadedArrowWithTailKeyword_1_0_5() { return cRightwardsTwoHeadedArrowWithTailKeyword_1_0_5; }
		
		//'⇸'
		public Keyword getRightwardsArrowWithVerticalStrokeKeyword_1_0_6() { return cRightwardsArrowWithVerticalStrokeKeyword_1_0_6; }
		
		//'↣'
		public Keyword getRightwardsArrowWithTailKeyword_1_0_7() { return cRightwardsArrowWithTailKeyword_1_0_7; }
		
		//'⤀'
		public Keyword getRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_1_0_8() { return cRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_1_0_8; }
		
		//'↠'
		public Keyword getRightwardsTwoHeadedArrowKeyword_1_0_9() { return cRightwardsTwoHeadedArrowKeyword_1_0_9; }
		
		//type+=ConstructedType
		public Assignment getTypeAssignment_1_1() { return cTypeAssignment_1_1; }
		
		//ConstructedType
		public RuleCall getTypeConstructedTypeParserRuleCall_1_1_0() { return cTypeConstructedTypeParserRuleCall_1_1_0; }
	}
	public class TypeConstructorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TypeConstructor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeNameNameCrossReference_0_0 = (CrossReference)cTypeNameAssignment_0.eContents().get(0);
		private final RuleCall cTypeNameNameIDTerminalRuleCall_0_0_1 = (RuleCall)cTypeNameNameCrossReference_0_0.eContents().get(1);
		private final Assignment cContextAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cContextTypeDeclContextParserRuleCall_1_0 = (RuleCall)cContextAssignment_1.eContents().get(0);
		
		///* Type constructor has validation rules to check that there is no context when there is a polymorphic name, 
		// * and type checking on the polymorphic context. There is also  scope rule to check the usage of polymorphic types.
		// * Probably need to add the predicate type to this.
		// */ TypeConstructor:
		//	typeName=[Name] context+=TypeDeclContext?;
		@Override public ParserRule getRule() { return rule; }
		
		//typeName=[Name] context+=TypeDeclContext?
		public Group getGroup() { return cGroup; }
		
		//typeName=[Name]
		public Assignment getTypeNameAssignment_0() { return cTypeNameAssignment_0; }
		
		//[Name]
		public CrossReference getTypeNameNameCrossReference_0_0() { return cTypeNameNameCrossReference_0_0; }
		
		//ID
		public RuleCall getTypeNameNameIDTerminalRuleCall_0_0_1() { return cTypeNameNameIDTerminalRuleCall_0_0_1; }
		
		//context+=TypeDeclContext?
		public Assignment getContextAssignment_1() { return cContextAssignment_1; }
		
		//TypeDeclContext
		public RuleCall getContextTypeDeclContextParserRuleCall_1_0() { return cContextTypeDeclContextParserRuleCall_1_0; }
	}
	public class TypeDeclContextElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TypeDeclContext");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeNameConstructedTypeParserRuleCall_1_0 = (RuleCall)cTypeNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cTypeNameAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cTypeNameConstructedTypeParserRuleCall_2_1_0 = (RuleCall)cTypeNameAssignment_2_1.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//TypeDeclContext:
		//	'<' typeName+=ConstructedType (',' typeName+=ConstructedType)* '>';
		@Override public ParserRule getRule() { return rule; }
		
		//'<' typeName+=ConstructedType (',' typeName+=ConstructedType)* '>'
		public Group getGroup() { return cGroup; }
		
		//'<'
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }
		
		//typeName+=ConstructedType
		public Assignment getTypeNameAssignment_1() { return cTypeNameAssignment_1; }
		
		//ConstructedType
		public RuleCall getTypeNameConstructedTypeParserRuleCall_1_0() { return cTypeNameConstructedTypeParserRuleCall_1_0; }
		
		//(',' typeName+=ConstructedType)*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//typeName+=ConstructedType
		public Assignment getTypeNameAssignment_2_1() { return cTypeNameAssignment_2_1; }
		
		//ConstructedType
		public RuleCall getTypeNameConstructedTypeParserRuleCall_2_1_0() { return cTypeNameConstructedTypeParserRuleCall_2_1_0; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_3() { return cGreaterThanSignKeyword_3; }
	}
	public class TypeStructureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TypeStructure");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVariablesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVariablesTypedVariableListParserRuleCall_1_0 = (RuleCall)cVariablesAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		///* -------------------- Type Structure ---------------------------------- */ TypeStructure:
		//	'(' variables=TypedVariableList ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' variables=TypedVariableList ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//variables=TypedVariableList
		public Assignment getVariablesAssignment_1() { return cVariablesAssignment_1; }
		
		//TypedVariableList
		public RuleCall getVariablesTypedVariableListParserRuleCall_1_0() { return cVariablesTypedVariableListParserRuleCall_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class WhereElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Where");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhereKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpessionsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpessionsExpressionParserRuleCall_1_0 = (RuleCall)cExpessionsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cSemicolonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cExpressionsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cExpressionsExpressionParserRuleCall_2_1_0 = (RuleCall)cExpressionsAssignment_2_1.eContents().get(0);
		
		///* -------------------- Where Statement -------------------------------- */ /* Type checking (which is not implemented yet) is used to type check that Expression returns a 
		// * predicate. Expression has not yet been written, but is far too general to be included in the where
		// * statement.
		// */ Where:
		//	'where' expessions+=Expression (';' expressions+=Expression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//'where' expessions+=Expression (';' expressions+=Expression)*
		public Group getGroup() { return cGroup; }
		
		//'where'
		public Keyword getWhereKeyword_0() { return cWhereKeyword_0; }
		
		//expessions+=Expression
		public Assignment getExpessionsAssignment_1() { return cExpessionsAssignment_1; }
		
		//Expression
		public RuleCall getExpessionsExpressionParserRuleCall_1_0() { return cExpessionsExpressionParserRuleCall_1_0; }
		
		//(';' expressions+=Expression)*
		public Group getGroup_2() { return cGroup_2; }
		
		//';'
		public Keyword getSemicolonKeyword_2_0() { return cSemicolonKeyword_2_0; }
		
		//expressions+=Expression
		public Assignment getExpressionsAssignment_2_1() { return cExpressionsAssignment_2_1; }
		
		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_2_1_0() { return cExpressionsExpressionParserRuleCall_2_1_0; }
	}
	public class DatatypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Datatype");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDatatypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameTypeNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cContextAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cContextPolyContextParserRuleCall_2_0 = (RuleCall)cContextAssignment_2.eContents().get(0);
		private final Assignment cConstructorsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cConstructorsDatatypeConstructorParserRuleCall_3_0 = (RuleCall)cConstructorsAssignment_3.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cBodyElementsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cBodyElementsTypeBodyElementsParserRuleCall_5_0 = (RuleCall)cBodyElementsAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		///* ---------------------- Datatype declarations -------------------------- */ Datatype:
		//	'Datatype' name=TypeName context=PolyContext? constructors+=DatatypeConstructor* '{' bodyElements+=TypeBodyElements*
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'Datatype' name=TypeName context=PolyContext? constructors+=DatatypeConstructor* '{' bodyElements+=TypeBodyElements* '}'
		public Group getGroup() { return cGroup; }
		
		//'Datatype'
		public Keyword getDatatypeKeyword_0() { return cDatatypeKeyword_0; }
		
		//name=TypeName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//TypeName
		public RuleCall getNameTypeNameParserRuleCall_1_0() { return cNameTypeNameParserRuleCall_1_0; }
		
		//context=PolyContext?
		public Assignment getContextAssignment_2() { return cContextAssignment_2; }
		
		//PolyContext
		public RuleCall getContextPolyContextParserRuleCall_2_0() { return cContextPolyContextParserRuleCall_2_0; }
		
		//constructors+=DatatypeConstructor*
		public Assignment getConstructorsAssignment_3() { return cConstructorsAssignment_3; }
		
		//DatatypeConstructor
		public RuleCall getConstructorsDatatypeConstructorParserRuleCall_3_0() { return cConstructorsDatatypeConstructorParserRuleCall_3_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//bodyElements+=TypeBodyElements*
		public Assignment getBodyElementsAssignment_5() { return cBodyElementsAssignment_5; }
		
		//TypeBodyElements
		public RuleCall getBodyElementsTypeBodyElementsParserRuleCall_5_0() { return cBodyElementsTypeBodyElementsParserRuleCall_5_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}
	public class DatatypeConstructorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.DatatypeConstructor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVerticalLineKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cBaseConstructorParserRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cDTypeConstructorParserRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		
		///* PolyContext is the same as PolyContext used by the class declaration above. */ DatatypeConstructor:
		//	'|' (BaseConstructor | DTypeConstructor);
		@Override public ParserRule getRule() { return rule; }
		
		//'|' (BaseConstructor | DTypeConstructor)
		public Group getGroup() { return cGroup; }
		
		//'|'
		public Keyword getVerticalLineKeyword_0() { return cVerticalLineKeyword_0; }
		
		//BaseConstructor | DTypeConstructor
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//BaseConstructor
		public RuleCall getBaseConstructorParserRuleCall_1_0() { return cBaseConstructorParserRuleCall_1_0; }
		
		//DTypeConstructor
		public RuleCall getDTypeConstructorParserRuleCall_1_1() { return cDTypeConstructorParserRuleCall_1_1; }
	}
	public class BaseConstructorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.BaseConstructor");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//BaseConstructor:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class DTypeConstructorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.DTypeConstructor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cDeconsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDeconsTypedVariableListParserRuleCall_2_0 = (RuleCall)cDeconsAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		///* Typed Variable list is declared below, it is used in several situations such as functions/lambdas
		// * not just in Datatypes.
		// */ DTypeConstructor:
		//	name=ID '(' decons=TypedVariableList ')';
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID '(' decons=TypedVariableList ')'
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//decons=TypedVariableList
		public Assignment getDeconsAssignment_2() { return cDeconsAssignment_2; }
		
		//TypedVariableList
		public RuleCall getDeconsTypedVariableListParserRuleCall_2_0() { return cDeconsTypedVariableListParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class ExtendElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Extend");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cNameTypeNameCrossReference_0_0 = (CrossReference)cNameAssignment_0.eContents().get(0);
		private final RuleCall cNameTypeNameIDTerminalRuleCall_0_0_1 = (RuleCall)cNameTypeNameCrossReference_0_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExtesnionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExtesnionIDTerminalRuleCall_2_0 = (RuleCall)cExtesnionAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cBodyElementsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cBodyElementsTypeBodyElementsParserRuleCall_5_0 = (RuleCall)cBodyElementsAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		///* ------------------------ Extension statement ---------------------------- */ Extend:
		//	name=[TypeName] '(' extesnion=ID ')' '{' bodyElements+=TypeBodyElements* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//name=[TypeName] '(' extesnion=ID ')' '{' bodyElements+=TypeBodyElements* '}'
		public Group getGroup() { return cGroup; }
		
		//name=[TypeName]
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//[TypeName]
		public CrossReference getNameTypeNameCrossReference_0_0() { return cNameTypeNameCrossReference_0_0; }
		
		//ID
		public RuleCall getNameTypeNameIDTerminalRuleCall_0_0_1() { return cNameTypeNameIDTerminalRuleCall_0_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//extesnion=ID
		public Assignment getExtesnionAssignment_2() { return cExtesnionAssignment_2; }
		
		//ID
		public RuleCall getExtesnionIDTerminalRuleCall_2_0() { return cExtesnionIDTerminalRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//bodyElements+=TypeBodyElements*
		public Assignment getBodyElementsAssignment_5() { return cBodyElementsAssignment_5; }
		
		//TypeBodyElements
		public RuleCall getBodyElementsTypeBodyElementsParserRuleCall_5_0() { return cBodyElementsTypeBodyElementsParserRuleCall_5_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}
	public class TypeBodyElementsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TypeBodyElements");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cFunctionsAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cFunctionsFunctionDeclParserRuleCall_0_0 = (RuleCall)cFunctionsAssignment_0.eContents().get(0);
		private final Assignment cTheoremsAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cTheoremsTheoremBodyParserRuleCall_1_0 = (RuleCall)cTheoremsAssignment_1.eContents().get(0);
		
		///* ------------------------ TypeBodyElements ------------------------------- */ TypeBodyElements:
		//	functions+=FunctionDecl | theorems+=TheoremBody;
		@Override public ParserRule getRule() { return rule; }
		
		//functions+=FunctionDecl | theorems+=TheoremBody
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//functions+=FunctionDecl
		public Assignment getFunctionsAssignment_0() { return cFunctionsAssignment_0; }
		
		//FunctionDecl
		public RuleCall getFunctionsFunctionDeclParserRuleCall_0_0() { return cFunctionsFunctionDeclParserRuleCall_0_0; }
		
		//theorems+=TheoremBody
		public Assignment getTheoremsAssignment_1() { return cTheoremsAssignment_1; }
		
		//TheoremBody
		public RuleCall getTheoremsTheoremBodyParserRuleCall_1_0() { return cTheoremsTheoremBodyParserRuleCall_1_0; }
	}
	public class FunctionDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.FunctionDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameFunctionNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cContextAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cContextPolyContextParserRuleCall_1_0 = (RuleCall)cContextAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cVariablesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVariablesTypedVariableListParserRuleCall_3_0 = (RuleCall)cVariablesAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cBodyAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cBodyFunctionBodyParserRuleCall_5_0 = (RuleCall)cBodyAssignment_5.eContents().get(0);
		private final Keyword cColonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cReturnTypeAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cReturnTypeTypeConstructorParserRuleCall_7_0 = (RuleCall)cReturnTypeAssignment_7.eContents().get(0);
		
		///*------------------------- Functions --------------------------------- */ FunctionDecl:
		//	name+=FunctionName context=PolyContext? '(' variables=TypedVariableList? ')' body=FunctionBody ':'
		//	returnType=TypeConstructor;
		@Override public ParserRule getRule() { return rule; }
		
		//name+=FunctionName context=PolyContext? '(' variables=TypedVariableList? ')' body=FunctionBody ':'
		//returnType=TypeConstructor
		public Group getGroup() { return cGroup; }
		
		//name+=FunctionName
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//FunctionName
		public RuleCall getNameFunctionNameParserRuleCall_0_0() { return cNameFunctionNameParserRuleCall_0_0; }
		
		//context=PolyContext?
		public Assignment getContextAssignment_1() { return cContextAssignment_1; }
		
		//PolyContext
		public RuleCall getContextPolyContextParserRuleCall_1_0() { return cContextPolyContextParserRuleCall_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//variables=TypedVariableList?
		public Assignment getVariablesAssignment_3() { return cVariablesAssignment_3; }
		
		//TypedVariableList
		public RuleCall getVariablesTypedVariableListParserRuleCall_3_0() { return cVariablesTypedVariableListParserRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
		
		//body=FunctionBody
		public Assignment getBodyAssignment_5() { return cBodyAssignment_5; }
		
		//FunctionBody
		public RuleCall getBodyFunctionBodyParserRuleCall_5_0() { return cBodyFunctionBodyParserRuleCall_5_0; }
		
		//':'
		public Keyword getColonKeyword_6() { return cColonKeyword_6; }
		
		//returnType=TypeConstructor
		public Assignment getReturnTypeAssignment_7() { return cReturnTypeAssignment_7; }
		
		//TypeConstructor
		public RuleCall getReturnTypeTypeConstructorParserRuleCall_7_0() { return cReturnTypeTypeConstructorParserRuleCall_7_0; }
	}
	public class FunctionBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.FunctionBody");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFuncInductiveParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFuncDirectDefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//FunctionBody:
		//	FuncInductive | FuncDirectDef;
		@Override public ParserRule getRule() { return rule; }
		
		//FuncInductive | FuncDirectDef
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//FuncInductive
		public RuleCall getFuncInductiveParserRuleCall_0() { return cFuncInductiveParserRuleCall_0; }
		
		//FuncDirectDef
		public RuleCall getFuncDirectDefParserRuleCall_1() { return cFuncDirectDefParserRuleCall_1; }
	}
	public class FuncDirectDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.FuncDirectDef");
		private final Assignment cExpressionAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_0 = (RuleCall)cExpressionAssignment.eContents().get(0);
		
		///* The expression will be type checked to make sure that it returns the expected type. The result of type checking
		// * will have three possible result. A negative result giving an error e.g., the type returned by the expression 
		// * cannot match the return type. An undetermined result, a proof obligation is generated so the user can prove
		// * demonstrate the expression returns the correct type. A positive result, the expected type is returned by the
		// * expression, and the user is not required to do anything. In the case of an intermediate result the type system
		// * assumes that the declaration is true, however, there will still be the unsatisfied proof obligation showing
		// * that the system is unproven */ FuncDirectDef:
		//	expression=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//expression=Expression
		public Assignment getExpressionAssignment() { return cExpressionAssignment; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_0() { return cExpressionExpressionParserRuleCall_0; }
	}
	public class FuncInductiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.FuncInductive");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMatchKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVariableNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cVariableNameTypedVariableCrossReference_1_0 = (CrossReference)cVariableNameAssignment_1.eContents().get(0);
		private final RuleCall cVariableNameTypedVariableIDTerminalRuleCall_1_0_1 = (RuleCall)cVariableNameTypedVariableCrossReference_1_0.eContents().get(1);
		private final Assignment cInductCaseAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cInductCaseFuncInductiveCaseParserRuleCall_2_0 = (RuleCall)cInductCaseAssignment_2.eContents().get(0);
		private final Assignment cInductCaseAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cInductCaseFuncInductiveCaseParserRuleCall_3_0 = (RuleCall)cInductCaseAssignment_3.eContents().get(0);
		
		//FuncInductive:
		//	'match' variableName=[TypedVariable] inductCase+=FuncInductiveCase inductCase+=FuncInductiveCase*;
		@Override public ParserRule getRule() { return rule; }
		
		//'match' variableName=[TypedVariable] inductCase+=FuncInductiveCase inductCase+=FuncInductiveCase*
		public Group getGroup() { return cGroup; }
		
		//'match'
		public Keyword getMatchKeyword_0() { return cMatchKeyword_0; }
		
		//variableName=[TypedVariable]
		public Assignment getVariableNameAssignment_1() { return cVariableNameAssignment_1; }
		
		//[TypedVariable]
		public CrossReference getVariableNameTypedVariableCrossReference_1_0() { return cVariableNameTypedVariableCrossReference_1_0; }
		
		//ID
		public RuleCall getVariableNameTypedVariableIDTerminalRuleCall_1_0_1() { return cVariableNameTypedVariableIDTerminalRuleCall_1_0_1; }
		
		//inductCase+=FuncInductiveCase
		public Assignment getInductCaseAssignment_2() { return cInductCaseAssignment_2; }
		
		//FuncInductiveCase
		public RuleCall getInductCaseFuncInductiveCaseParserRuleCall_2_0() { return cInductCaseFuncInductiveCaseParserRuleCall_2_0; }
		
		//inductCase+=FuncInductiveCase*
		public Assignment getInductCaseAssignment_3() { return cInductCaseAssignment_3; }
		
		//FuncInductiveCase
		public RuleCall getInductCaseFuncInductiveCaseParserRuleCall_3_0() { return cInductCaseFuncInductiveCaseParserRuleCall_3_0; }
	}
	public class FuncInductiveCaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.FuncInductiveCase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVerticalLineKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDeconNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cDeconNameDTypeConstructorCrossReference_1_0 = (CrossReference)cDeconNameAssignment_1.eContents().get(0);
		private final RuleCall cDeconNameDTypeConstructorIDTerminalRuleCall_1_0_1 = (RuleCall)cDeconNameDTypeConstructorCrossReference_1_0.eContents().get(1);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExpreAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpreExpressionParserRuleCall_3_0 = (RuleCall)cExpreAssignment_3.eContents().get(0);
		
		//FuncInductiveCase:
		//	'|' deconName=[DTypeConstructor] ':' expre=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//'|' deconName=[DTypeConstructor] ':' expre=Expression
		public Group getGroup() { return cGroup; }
		
		//'|'
		public Keyword getVerticalLineKeyword_0() { return cVerticalLineKeyword_0; }
		
		//deconName=[DTypeConstructor]
		public Assignment getDeconNameAssignment_1() { return cDeconNameAssignment_1; }
		
		//[DTypeConstructor]
		public CrossReference getDeconNameDTypeConstructorCrossReference_1_0() { return cDeconNameDTypeConstructorCrossReference_1_0; }
		
		//ID
		public RuleCall getDeconNameDTypeConstructorIDTerminalRuleCall_1_0_1() { return cDeconNameDTypeConstructorIDTerminalRuleCall_1_0_1; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//expre=Expression
		public Assignment getExpreAssignment_3() { return cExpreAssignment_3; }
		
		//Expression
		public RuleCall getExpreExpressionParserRuleCall_3_0() { return cExpreExpressionParserRuleCall_3_0; }
	}
	public class TheoremBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TheoremBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTheoremsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTheoremDeclAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTheoremDeclTheoremDeclParserRuleCall_2_0 = (RuleCall)cTheoremDeclAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		///* ----------------------------- Theorems -------------------------*/ TheoremBody:
		//	'Theorems' '{' theoremDecl+=TheoremDecl+ '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'Theorems' '{' theoremDecl+=TheoremDecl+ '}'
		public Group getGroup() { return cGroup; }
		
		//'Theorems'
		public Keyword getTheoremsKeyword_0() { return cTheoremsKeyword_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//theoremDecl+=TheoremDecl+
		public Assignment getTheoremDeclAssignment_2() { return cTheoremDeclAssignment_2; }
		
		//TheoremDecl
		public RuleCall getTheoremDeclTheoremDeclParserRuleCall_2_0() { return cTheoremDeclTheoremDeclParserRuleCall_2_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class TheoremDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TheoremDecl");
		private final Assignment cThmNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cThmNameTHM_NAMEParserRuleCall_0 = (RuleCall)cThmNameAssignment.eContents().get(0);
		
		//TheoremDecl:
		//	thmName=THM_NAME;
		@Override public ParserRule getRule() { return rule; }
		
		//thmName=THM_NAME
		public Assignment getThmNameAssignment() { return cThmNameAssignment; }
		
		//THM_NAME
		public RuleCall getThmNameTHM_NAMEParserRuleCall_0() { return cThmNameTHM_NAMEParserRuleCall_0; }
	}
	public class TypedVariableListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TypedVariableList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeVarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeVarTypedVariableParserRuleCall_0_0 = (RuleCall)cTypeVarAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTypeVarAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypeVarTypedVariableParserRuleCall_1_1_0 = (RuleCall)cTypeVarAssignment_1_1.eContents().get(0);
		
		//TypedVariableList:
		//	typeVar+=TypedVariable (',' typeVar+=TypedVariable)*;
		@Override public ParserRule getRule() { return rule; }
		
		//typeVar+=TypedVariable (',' typeVar+=TypedVariable)*
		public Group getGroup() { return cGroup; }
		
		//typeVar+=TypedVariable
		public Assignment getTypeVarAssignment_0() { return cTypeVarAssignment_0; }
		
		//TypedVariable
		public RuleCall getTypeVarTypedVariableParserRuleCall_0_0() { return cTypeVarTypedVariableParserRuleCall_0_0; }
		
		//(',' typeVar+=TypedVariable)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//typeVar+=TypedVariable
		public Assignment getTypeVarAssignment_1_1() { return cTypeVarAssignment_1_1; }
		
		//TypedVariable
		public RuleCall getTypeVarTypedVariableParserRuleCall_1_1_0() { return cTypeVarTypedVariableParserRuleCall_1_1_0; }
	}
	public class TypedVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TypedVariable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeConstructedTypeParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//TypedVariable:
		//	name=ID ':' type=ConstructedType;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID ':' type=ConstructedType
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//type=ConstructedType
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//ConstructedType
		public RuleCall getTypeConstructedTypeParserRuleCall_2_0() { return cTypeConstructedTypeParserRuleCall_2_0; }
	}
	public class TypeDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TypeDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeNameTypeNameCrossReference_0_0 = (CrossReference)cTypeNameAssignment_0.eContents().get(0);
		private final RuleCall cTypeNameTypeNameIDTerminalRuleCall_0_0_1 = (RuleCall)cTypeNameTypeNameCrossReference_0_0.eContents().get(1);
		private final Assignment cContextAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cContextTypeDeclContextParserRuleCall_1_0 = (RuleCall)cContextAssignment_1.eContents().get(0);
		
		//TypeDeclaration:
		//	typeName=[TypeName] context=TypeDeclContext;
		@Override public ParserRule getRule() { return rule; }
		
		//typeName=[TypeName] context=TypeDeclContext
		public Group getGroup() { return cGroup; }
		
		//typeName=[TypeName]
		public Assignment getTypeNameAssignment_0() { return cTypeNameAssignment_0; }
		
		//[TypeName]
		public CrossReference getTypeNameTypeNameCrossReference_0_0() { return cTypeNameTypeNameCrossReference_0_0; }
		
		//ID
		public RuleCall getTypeNameTypeNameIDTerminalRuleCall_0_0_1() { return cTypeNameTypeNameIDTerminalRuleCall_0_0_1; }
		
		//context=TypeDeclContext
		public Assignment getContextAssignment_1() { return cContextAssignment_1; }
		
		//TypeDeclContext
		public RuleCall getContextTypeDeclContextParserRuleCall_1_0() { return cContextTypeDeclContextParserRuleCall_1_0; }
	}
	public class FunctionNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.FunctionName");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//FunctionName:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Expression");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Expression:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//// This needs to be written. Could be worth separating this out into another 
		//// dsl reducing the complexity of this section. Specifically I need to look out for
		//// the following expressions forall exists lambda function calls.
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	
	
	private final DomainModelElements pDomainModel;
	private final THM_NAMEElements pTHM_NAME;
	private final TopLevelElements pTopLevel;
	private final ImportStatementElements pImportStatement;
	private final ImportElements pImport;
	private final ImportComponentElements pImportComponent;
	private final ClassDeclElements pClassDecl;
	private final ClassElements pClass;
	private final NameElements pName;
	private final TypeNameElements pTypeName;
	private final PolymorphicTypeNameElements pPolymorphicTypeName;
	private final PolyContextElements pPolyContext;
	private final PolyContextTypesElements pPolyContextTypes;
	private final PolyTypeConstraintsElements pPolyTypeConstraints;
	private final SuperTypeListElements pSuperTypeList;
	private final ConstructedTypeElements pConstructedType;
	private final TypeConstructorElements pTypeConstructor;
	private final TypeDeclContextElements pTypeDeclContext;
	private final TypeStructureElements pTypeStructure;
	private final WhereElements pWhere;
	private final DatatypeElements pDatatype;
	private final DatatypeConstructorElements pDatatypeConstructor;
	private final BaseConstructorElements pBaseConstructor;
	private final DTypeConstructorElements pDTypeConstructor;
	private final ExtendElements pExtend;
	private final TypeBodyElementsElements pTypeBodyElements;
	private final FunctionDeclElements pFunctionDecl;
	private final FunctionBodyElements pFunctionBody;
	private final FuncDirectDefElements pFuncDirectDef;
	private final FuncInductiveElements pFuncInductive;
	private final FuncInductiveCaseElements pFuncInductiveCase;
	private final TheoremBodyElements pTheoremBody;
	private final TheoremDeclElements pTheoremDecl;
	private final TypedVariableListElements pTypedVariableList;
	private final TypedVariableElements pTypedVariable;
	private final TypeDeclarationElements pTypeDeclaration;
	private final FunctionNameElements pFunctionName;
	private final ExpressionElements pExpression;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public MyDslGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pDomainModel = new DomainModelElements();
		this.pTHM_NAME = new THM_NAMEElements();
		this.pTopLevel = new TopLevelElements();
		this.pImportStatement = new ImportStatementElements();
		this.pImport = new ImportElements();
		this.pImportComponent = new ImportComponentElements();
		this.pClassDecl = new ClassDeclElements();
		this.pClass = new ClassElements();
		this.pName = new NameElements();
		this.pTypeName = new TypeNameElements();
		this.pPolymorphicTypeName = new PolymorphicTypeNameElements();
		this.pPolyContext = new PolyContextElements();
		this.pPolyContextTypes = new PolyContextTypesElements();
		this.pPolyTypeConstraints = new PolyTypeConstraintsElements();
		this.pSuperTypeList = new SuperTypeListElements();
		this.pConstructedType = new ConstructedTypeElements();
		this.pTypeConstructor = new TypeConstructorElements();
		this.pTypeDeclContext = new TypeDeclContextElements();
		this.pTypeStructure = new TypeStructureElements();
		this.pWhere = new WhereElements();
		this.pDatatype = new DatatypeElements();
		this.pDatatypeConstructor = new DatatypeConstructorElements();
		this.pBaseConstructor = new BaseConstructorElements();
		this.pDTypeConstructor = new DTypeConstructorElements();
		this.pExtend = new ExtendElements();
		this.pTypeBodyElements = new TypeBodyElementsElements();
		this.pFunctionDecl = new FunctionDeclElements();
		this.pFunctionBody = new FunctionBodyElements();
		this.pFuncDirectDef = new FuncDirectDefElements();
		this.pFuncInductive = new FuncInductiveElements();
		this.pFuncInductiveCase = new FuncInductiveCaseElements();
		this.pTheoremBody = new TheoremBodyElements();
		this.pTheoremDecl = new TheoremDeclElements();
		this.pTypedVariableList = new TypedVariableListElements();
		this.pTypedVariable = new TypedVariableElements();
		this.pTypeDeclaration = new TypeDeclarationElements();
		this.pFunctionName = new FunctionNameElements();
		this.pExpression = new ExpressionElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.sampleProj.mydsl.MyDsl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//DomainModel:
	//	elements+=TopLevel*;
	public DomainModelElements getDomainModelAccess() {
		return pDomainModel;
	}
	
	public ParserRule getDomainModelRule() {
		return getDomainModelAccess().getRule();
	}
	
	//// Theorem names can include white space.
	//THM_NAME:
	//	(ID | WS)* ":";
	public THM_NAMEElements getTHM_NAMEAccess() {
		return pTHM_NAME;
	}
	
	public ParserRule getTHM_NAMERule() {
		return getTHM_NAMEAccess().getRule();
	}
	
	//TopLevel:
	//	ImportStatement | ClassDecl;
	public TopLevelElements getTopLevelAccess() {
		return pTopLevel;
	}
	
	public ParserRule getTopLevelRule() {
		return getTopLevelAccess().getRule();
	}
	
	//ImportStatement:
	//	'Import'
	//	imports+=Import;
	public ImportStatementElements getImportStatementAccess() {
		return pImportStatement;
	}
	
	public ParserRule getImportStatementRule() {
		return getImportStatementAccess().getRule();
	}
	
	//Import:
	//	importName+=ImportComponent ('.' importName+=ImportComponent);
	public ImportElements getImportAccess() {
		return pImport;
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}
	
	//ImportComponent:
	//	name=ID;
	public ImportComponentElements getImportComponentAccess() {
		return pImportComponent;
	}
	
	public ParserRule getImportComponentRule() {
		return getImportComponentAccess().getRule();
	}
	
	//ClassDecl:
	//	Class | Datatype | Extend;
	public ClassDeclElements getClassDeclAccess() {
		return pClassDecl;
	}
	
	public ParserRule getClassDeclRule() {
		return getClassDeclAccess().getRule();
	}
	
	///* ------------------------ Class statements --------------------- */ Class BppClass:
	//	'Class' typeName=TypeName context=PolyContext? supertypes=SuperTypeList? typeStructure=TypeStructure? where=Where?
	//	';'? '{' bodyElements+=TypeBodyElements* '}';
	public ClassElements getClassAccess() {
		return pClass;
	}
	
	public ParserRule getClassRule() {
		return getClassAccess().getRule();
	}
	
	//Name:
	//	PolymorphicTypeName | TypeName;
	public NameElements getNameAccess() {
		return pName;
	}
	
	public ParserRule getNameRule() {
		return getNameAccess().getRule();
	}
	
	//TypeName:
	//	name=ID;
	public TypeNameElements getTypeNameAccess() {
		return pTypeName;
	}
	
	public ParserRule getTypeNameRule() {
		return getTypeNameAccess().getRule();
	}
	
	///*---------------- Polymorphic Context -------------------------- */ PolymorphicTypeName:
	//	name=ID;
	public PolymorphicTypeNameElements getPolymorphicTypeNameAccess() {
		return pPolymorphicTypeName;
	}
	
	public ParserRule getPolymorphicTypeNameRule() {
		return getPolymorphicTypeNameAccess().getRule();
	}
	
	//PolyContext:
	//	'<' polyTypes+=PolyContextTypes+ '>';
	public PolyContextElements getPolyContextAccess() {
		return pPolyContext;
	}
	
	public ParserRule getPolyContextRule() {
		return getPolyContextAccess().getRule();
	}
	
	//PolyContextTypes:
	//	name=PolymorphicTypeName constraints+=PolyTypeConstraints*;
	public PolyContextTypesElements getPolyContextTypesAccess() {
		return pPolyContextTypes;
	}
	
	public ParserRule getPolyContextTypesRule() {
		return getPolyContextTypesAccess().getRule();
	}
	
	//PolyTypeConstraints:
	//	':' typeName+=[TypeName] (',' typeName+=[TypeName])*;
	public PolyTypeConstraintsElements getPolyTypeConstraintsAccess() {
		return pPolyTypeConstraints;
	}
	
	public ParserRule getPolyTypeConstraintsRule() {
		return getPolyTypeConstraintsAccess().getRule();
	}
	
	///* ------------------- SuperTypes ---------------------------------- */ /* Any constriction on the polymorphic context has to be done by declaring the polymorphic context
	// * on the new type. If necessary the polymorphic context can be used within type constructors. In the simple case 
	// * this will be inferred . Required thought on checking the base types of the super types. At some points these
	// * need to be identical declarations. It is also necessary to allow EventB style type constructors at this
	// * point. e.g., an associative operator is a subtype of a closed Event-B total function.
	// */ SuperTypeList:
	//	':' superType+=ConstructedType (',' superType+=ConstructedType)*;
	public SuperTypeListElements getSuperTypeListAccess() {
		return pSuperTypeList;
	}
	
	public ParserRule getSuperTypeListRule() {
		return getSuperTypeListAccess().getRule();
	}
	
	///* Along with the normal Event-B type operator, and new B++ types the  */ ConstructedType:
	//	type+=TypeConstructor (('×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠') type+=ConstructedType)?;
	public ConstructedTypeElements getConstructedTypeAccess() {
		return pConstructedType;
	}
	
	public ParserRule getConstructedTypeRule() {
		return getConstructedTypeAccess().getRule();
	}
	
	///* Type constructor has validation rules to check that there is no context when there is a polymorphic name, 
	// * and type checking on the polymorphic context. There is also  scope rule to check the usage of polymorphic types.
	// * Probably need to add the predicate type to this.
	// */ TypeConstructor:
	//	typeName=[Name] context+=TypeDeclContext?;
	public TypeConstructorElements getTypeConstructorAccess() {
		return pTypeConstructor;
	}
	
	public ParserRule getTypeConstructorRule() {
		return getTypeConstructorAccess().getRule();
	}
	
	//TypeDeclContext:
	//	'<' typeName+=ConstructedType (',' typeName+=ConstructedType)* '>';
	public TypeDeclContextElements getTypeDeclContextAccess() {
		return pTypeDeclContext;
	}
	
	public ParserRule getTypeDeclContextRule() {
		return getTypeDeclContextAccess().getRule();
	}
	
	///* -------------------- Type Structure ---------------------------------- */ TypeStructure:
	//	'(' variables=TypedVariableList ')';
	public TypeStructureElements getTypeStructureAccess() {
		return pTypeStructure;
	}
	
	public ParserRule getTypeStructureRule() {
		return getTypeStructureAccess().getRule();
	}
	
	///* -------------------- Where Statement -------------------------------- */ /* Type checking (which is not implemented yet) is used to type check that Expression returns a 
	// * predicate. Expression has not yet been written, but is far too general to be included in the where
	// * statement.
	// */ Where:
	//	'where' expessions+=Expression (';' expressions+=Expression)*;
	public WhereElements getWhereAccess() {
		return pWhere;
	}
	
	public ParserRule getWhereRule() {
		return getWhereAccess().getRule();
	}
	
	///* ---------------------- Datatype declarations -------------------------- */ Datatype:
	//	'Datatype' name=TypeName context=PolyContext? constructors+=DatatypeConstructor* '{' bodyElements+=TypeBodyElements*
	//	'}';
	public DatatypeElements getDatatypeAccess() {
		return pDatatype;
	}
	
	public ParserRule getDatatypeRule() {
		return getDatatypeAccess().getRule();
	}
	
	///* PolyContext is the same as PolyContext used by the class declaration above. */ DatatypeConstructor:
	//	'|' (BaseConstructor | DTypeConstructor);
	public DatatypeConstructorElements getDatatypeConstructorAccess() {
		return pDatatypeConstructor;
	}
	
	public ParserRule getDatatypeConstructorRule() {
		return getDatatypeConstructorAccess().getRule();
	}
	
	//BaseConstructor:
	//	name=ID;
	public BaseConstructorElements getBaseConstructorAccess() {
		return pBaseConstructor;
	}
	
	public ParserRule getBaseConstructorRule() {
		return getBaseConstructorAccess().getRule();
	}
	
	///* Typed Variable list is declared below, it is used in several situations such as functions/lambdas
	// * not just in Datatypes.
	// */ DTypeConstructor:
	//	name=ID '(' decons=TypedVariableList ')';
	public DTypeConstructorElements getDTypeConstructorAccess() {
		return pDTypeConstructor;
	}
	
	public ParserRule getDTypeConstructorRule() {
		return getDTypeConstructorAccess().getRule();
	}
	
	///* ------------------------ Extension statement ---------------------------- */ Extend:
	//	name=[TypeName] '(' extesnion=ID ')' '{' bodyElements+=TypeBodyElements* '}';
	public ExtendElements getExtendAccess() {
		return pExtend;
	}
	
	public ParserRule getExtendRule() {
		return getExtendAccess().getRule();
	}
	
	///* ------------------------ TypeBodyElements ------------------------------- */ TypeBodyElements:
	//	functions+=FunctionDecl | theorems+=TheoremBody;
	public TypeBodyElementsElements getTypeBodyElementsAccess() {
		return pTypeBodyElements;
	}
	
	public ParserRule getTypeBodyElementsRule() {
		return getTypeBodyElementsAccess().getRule();
	}
	
	///*------------------------- Functions --------------------------------- */ FunctionDecl:
	//	name+=FunctionName context=PolyContext? '(' variables=TypedVariableList? ')' body=FunctionBody ':'
	//	returnType=TypeConstructor;
	public FunctionDeclElements getFunctionDeclAccess() {
		return pFunctionDecl;
	}
	
	public ParserRule getFunctionDeclRule() {
		return getFunctionDeclAccess().getRule();
	}
	
	//FunctionBody:
	//	FuncInductive | FuncDirectDef;
	public FunctionBodyElements getFunctionBodyAccess() {
		return pFunctionBody;
	}
	
	public ParserRule getFunctionBodyRule() {
		return getFunctionBodyAccess().getRule();
	}
	
	///* The expression will be type checked to make sure that it returns the expected type. The result of type checking
	// * will have three possible result. A negative result giving an error e.g., the type returned by the expression 
	// * cannot match the return type. An undetermined result, a proof obligation is generated so the user can prove
	// * demonstrate the expression returns the correct type. A positive result, the expected type is returned by the
	// * expression, and the user is not required to do anything. In the case of an intermediate result the type system
	// * assumes that the declaration is true, however, there will still be the unsatisfied proof obligation showing
	// * that the system is unproven */ FuncDirectDef:
	//	expression=Expression;
	public FuncDirectDefElements getFuncDirectDefAccess() {
		return pFuncDirectDef;
	}
	
	public ParserRule getFuncDirectDefRule() {
		return getFuncDirectDefAccess().getRule();
	}
	
	//FuncInductive:
	//	'match' variableName=[TypedVariable] inductCase+=FuncInductiveCase inductCase+=FuncInductiveCase*;
	public FuncInductiveElements getFuncInductiveAccess() {
		return pFuncInductive;
	}
	
	public ParserRule getFuncInductiveRule() {
		return getFuncInductiveAccess().getRule();
	}
	
	//FuncInductiveCase:
	//	'|' deconName=[DTypeConstructor] ':' expre=Expression;
	public FuncInductiveCaseElements getFuncInductiveCaseAccess() {
		return pFuncInductiveCase;
	}
	
	public ParserRule getFuncInductiveCaseRule() {
		return getFuncInductiveCaseAccess().getRule();
	}
	
	///* ----------------------------- Theorems -------------------------*/ TheoremBody:
	//	'Theorems' '{' theoremDecl+=TheoremDecl+ '}';
	public TheoremBodyElements getTheoremBodyAccess() {
		return pTheoremBody;
	}
	
	public ParserRule getTheoremBodyRule() {
		return getTheoremBodyAccess().getRule();
	}
	
	//TheoremDecl:
	//	thmName=THM_NAME;
	public TheoremDeclElements getTheoremDeclAccess() {
		return pTheoremDecl;
	}
	
	public ParserRule getTheoremDeclRule() {
		return getTheoremDeclAccess().getRule();
	}
	
	//TypedVariableList:
	//	typeVar+=TypedVariable (',' typeVar+=TypedVariable)*;
	public TypedVariableListElements getTypedVariableListAccess() {
		return pTypedVariableList;
	}
	
	public ParserRule getTypedVariableListRule() {
		return getTypedVariableListAccess().getRule();
	}
	
	//TypedVariable:
	//	name=ID ':' type=ConstructedType;
	public TypedVariableElements getTypedVariableAccess() {
		return pTypedVariable;
	}
	
	public ParserRule getTypedVariableRule() {
		return getTypedVariableAccess().getRule();
	}
	
	//TypeDeclaration:
	//	typeName=[TypeName] context=TypeDeclContext;
	public TypeDeclarationElements getTypeDeclarationAccess() {
		return pTypeDeclaration;
	}
	
	public ParserRule getTypeDeclarationRule() {
		return getTypeDeclarationAccess().getRule();
	}
	
	//FunctionName:
	//	name=ID;
	public FunctionNameElements getFunctionNameAccess() {
		return pFunctionName;
	}
	
	public ParserRule getFunctionNameRule() {
		return getFunctionNameAccess().getRule();
	}
	
	//Expression:
	//	name=ID;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
