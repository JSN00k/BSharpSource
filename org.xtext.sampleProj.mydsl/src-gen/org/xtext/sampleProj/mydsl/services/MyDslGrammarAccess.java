/*
 * generated by Xtext 2.13.0
 */
package org.xtext.sampleProj.mydsl.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class MyDslGrammarAccess extends AbstractGrammarElementFinder {
	
	public class DomainModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.DomainModel");
		private final Assignment cElementsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cElementsTopLevelParserRuleCall_0 = (RuleCall)cElementsAssignment.eContents().get(0);
		
		//DomainModel:
		//	elements+=TopLevel*;
		@Override public ParserRule getRule() { return rule; }
		
		//elements+=TopLevel*
		public Assignment getElementsAssignment() { return cElementsAssignment; }
		
		//TopLevel
		public RuleCall getElementsTopLevelParserRuleCall_0() { return cElementsTopLevelParserRuleCall_0; }
	}
	public class TopLevelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TopLevel");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cImportStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cClassDeclParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// Theorem names can include white space.
		////terminal THM_NAME: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9' ' | '|'\t')*;
		//TopLevel:
		//	ImportStatement | ClassDecl;
		@Override public ParserRule getRule() { return rule; }
		
		//ImportStatement | ClassDecl
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ImportStatement
		public RuleCall getImportStatementParserRuleCall_0() { return cImportStatementParserRuleCall_0; }
		
		//ClassDecl
		public RuleCall getClassDeclParserRuleCall_1() { return cClassDeclParserRuleCall_1; }
	}
	public class ImportStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.ImportStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cImportsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImportsImportParserRuleCall_1_0 = (RuleCall)cImportsAssignment_1.eContents().get(0);
		
		//ImportStatement:
		//	'Import'
		//	imports+=Import;
		@Override public ParserRule getRule() { return rule; }
		
		//'Import' imports+=Import
		public Group getGroup() { return cGroup; }
		
		//'Import'
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }
		
		//imports+=Import
		public Assignment getImportsAssignment_1() { return cImportsAssignment_1; }
		
		//Import
		public RuleCall getImportsImportParserRuleCall_1_0() { return cImportsImportParserRuleCall_1_0; }
	}
	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Import");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cImportNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cImportNameImportComponentParserRuleCall_0_0 = (RuleCall)cImportNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cImportNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cImportNameImportComponentParserRuleCall_1_1_0 = (RuleCall)cImportNameAssignment_1_1.eContents().get(0);
		
		//Import:
		//	importName+=ImportComponent ('.' importName+=ImportComponent);
		@Override public ParserRule getRule() { return rule; }
		
		//importName+=ImportComponent ('.' importName+=ImportComponent)
		public Group getGroup() { return cGroup; }
		
		//importName+=ImportComponent
		public Assignment getImportNameAssignment_0() { return cImportNameAssignment_0; }
		
		//ImportComponent
		public RuleCall getImportNameImportComponentParserRuleCall_0_0() { return cImportNameImportComponentParserRuleCall_0_0; }
		
		//'.' importName+=ImportComponent
		public Group getGroup_1() { return cGroup_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }
		
		//importName+=ImportComponent
		public Assignment getImportNameAssignment_1_1() { return cImportNameAssignment_1_1; }
		
		//ImportComponent
		public RuleCall getImportNameImportComponentParserRuleCall_1_1_0() { return cImportNameImportComponentParserRuleCall_1_1_0; }
	}
	public class ImportComponentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.ImportComponent");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//ImportComponent:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class ClassDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.ClassDecl");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cClassParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDatatypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cExtendParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//ClassDecl:
		//	Class | Datatype | Extend;
		@Override public ParserRule getRule() { return rule; }
		
		//Class | Datatype | Extend
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Class
		public RuleCall getClassParserRuleCall_0() { return cClassParserRuleCall_0; }
		
		//Datatype
		public RuleCall getDatatypeParserRuleCall_1() { return cDatatypeParserRuleCall_1; }
		
		//Extend
		public RuleCall getExtendParserRuleCall_2() { return cExtendParserRuleCall_2; }
	}
	public class ClassElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Class");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cClassKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeNameTypeNameParserRuleCall_1_0 = (RuleCall)cTypeNameAssignment_1.eContents().get(0);
		private final Assignment cContextAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cContextPolyContextParserRuleCall_2_0 = (RuleCall)cContextAssignment_2.eContents().get(0);
		private final Assignment cSupertypesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cSupertypesSuperTypeListParserRuleCall_3_0 = (RuleCall)cSupertypesAssignment_3.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cBodyElementsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cBodyElementsTypeBodyElementsParserRuleCall_5_0 = (RuleCall)cBodyElementsAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//Class BppClass:
		//	'Class' typeName=TypeName context=PolyContext? supertypes=SuperTypeList? '{' bodyElements+=TypeBodyElements* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'Class' typeName=TypeName context=PolyContext? supertypes=SuperTypeList? '{' bodyElements+=TypeBodyElements* '}'
		public Group getGroup() { return cGroup; }
		
		//'Class'
		public Keyword getClassKeyword_0() { return cClassKeyword_0; }
		
		//typeName=TypeName
		public Assignment getTypeNameAssignment_1() { return cTypeNameAssignment_1; }
		
		//TypeName
		public RuleCall getTypeNameTypeNameParserRuleCall_1_0() { return cTypeNameTypeNameParserRuleCall_1_0; }
		
		//context=PolyContext?
		public Assignment getContextAssignment_2() { return cContextAssignment_2; }
		
		//PolyContext
		public RuleCall getContextPolyContextParserRuleCall_2_0() { return cContextPolyContextParserRuleCall_2_0; }
		
		//supertypes=SuperTypeList?
		public Assignment getSupertypesAssignment_3() { return cSupertypesAssignment_3; }
		
		//SuperTypeList
		public RuleCall getSupertypesSuperTypeListParserRuleCall_3_0() { return cSupertypesSuperTypeListParserRuleCall_3_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//bodyElements+=TypeBodyElements*
		public Assignment getBodyElementsAssignment_5() { return cBodyElementsAssignment_5; }
		
		//TypeBodyElements
		public RuleCall getBodyElementsTypeBodyElementsParserRuleCall_5_0() { return cBodyElementsTypeBodyElementsParserRuleCall_5_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}
	public class NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPolymorphicTypeNameParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypeNameParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Name:
		//	PolymorphicTypeName | TypeName;
		@Override public ParserRule getRule() { return rule; }
		
		//PolymorphicTypeName | TypeName
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PolymorphicTypeName
		public RuleCall getPolymorphicTypeNameParserRuleCall_0() { return cPolymorphicTypeNameParserRuleCall_0; }
		
		//TypeName
		public RuleCall getTypeNameParserRuleCall_1() { return cTypeNameParserRuleCall_1; }
	}
	public class TypeNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TypeName");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//TypeName:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class PolymorphicTypeNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.PolymorphicTypeName");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		///*---------------- Polymorphic Context -------------------------- */ PolymorphicTypeName:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class PolyContextElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.PolyContext");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPolyTypesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPolyTypesPolyContextTypesParserRuleCall_1_0 = (RuleCall)cPolyTypesAssignment_1.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//PolyContext:
		//	'<' polyTypes+=PolyContextTypes+ '>';
		@Override public ParserRule getRule() { return rule; }
		
		//'<' polyTypes+=PolyContextTypes+ '>'
		public Group getGroup() { return cGroup; }
		
		//'<'
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }
		
		//polyTypes+=PolyContextTypes+
		public Assignment getPolyTypesAssignment_1() { return cPolyTypesAssignment_1; }
		
		//PolyContextTypes
		public RuleCall getPolyTypesPolyContextTypesParserRuleCall_1_0() { return cPolyTypesPolyContextTypesParserRuleCall_1_0; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_2() { return cGreaterThanSignKeyword_2; }
	}
	public class PolyContextTypesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.PolyContextTypes");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNamePolymorphicTypeNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cConstraintsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConstraintsPolyTypeConstraintsParserRuleCall_1_0 = (RuleCall)cConstraintsAssignment_1.eContents().get(0);
		
		//PolyContextTypes:
		//	name=PolymorphicTypeName constraints+=PolyTypeConstraints*;
		@Override public ParserRule getRule() { return rule; }
		
		//name=PolymorphicTypeName constraints+=PolyTypeConstraints*
		public Group getGroup() { return cGroup; }
		
		//name=PolymorphicTypeName
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//PolymorphicTypeName
		public RuleCall getNamePolymorphicTypeNameParserRuleCall_0_0() { return cNamePolymorphicTypeNameParserRuleCall_0_0; }
		
		//constraints+=PolyTypeConstraints*
		public Assignment getConstraintsAssignment_1() { return cConstraintsAssignment_1; }
		
		//PolyTypeConstraints
		public RuleCall getConstraintsPolyTypeConstraintsParserRuleCall_1_0() { return cConstraintsPolyTypeConstraintsParserRuleCall_1_0; }
	}
	public class PolyTypeConstraintsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.PolyTypeConstraints");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cTypeNameTypeNameCrossReference_1_0 = (CrossReference)cTypeNameAssignment_1.eContents().get(0);
		private final RuleCall cTypeNameTypeNameIDTerminalRuleCall_1_0_1 = (RuleCall)cTypeNameTypeNameCrossReference_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cTypeNameAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final CrossReference cTypeNameTypeNameCrossReference_2_1_0 = (CrossReference)cTypeNameAssignment_2_1.eContents().get(0);
		private final RuleCall cTypeNameTypeNameIDTerminalRuleCall_2_1_0_1 = (RuleCall)cTypeNameTypeNameCrossReference_2_1_0.eContents().get(1);
		
		//PolyTypeConstraints:
		//	':' typeName+=[TypeName] (',' typeName+=[TypeName])*;
		@Override public ParserRule getRule() { return rule; }
		
		//':' typeName+=[TypeName] (',' typeName+=[TypeName])*
		public Group getGroup() { return cGroup; }
		
		//':'
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }
		
		//typeName+=[TypeName]
		public Assignment getTypeNameAssignment_1() { return cTypeNameAssignment_1; }
		
		//[TypeName]
		public CrossReference getTypeNameTypeNameCrossReference_1_0() { return cTypeNameTypeNameCrossReference_1_0; }
		
		//ID
		public RuleCall getTypeNameTypeNameIDTerminalRuleCall_1_0_1() { return cTypeNameTypeNameIDTerminalRuleCall_1_0_1; }
		
		//(',' typeName+=[TypeName])*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//typeName+=[TypeName]
		public Assignment getTypeNameAssignment_2_1() { return cTypeNameAssignment_2_1; }
		
		//[TypeName]
		public CrossReference getTypeNameTypeNameCrossReference_2_1_0() { return cTypeNameTypeNameCrossReference_2_1_0; }
		
		//ID
		public RuleCall getTypeNameTypeNameIDTerminalRuleCall_2_1_0_1() { return cTypeNameTypeNameIDTerminalRuleCall_2_1_0_1; }
	}
	public class SuperTypeListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.SuperTypeList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSuperTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSuperTypeConstructedTypeParserRuleCall_1_0 = (RuleCall)cSuperTypeAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cSuperTypeAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cSuperTypeConstructedTypeParserRuleCall_2_1_0 = (RuleCall)cSuperTypeAssignment_2_1.eContents().get(0);
		
		///* ------------------- SuperTypes ---------------------------------- */ /* Any constriction on the polymorphic context has to be done by declaring the polymorphic context
		// * on the new type. If necessary the polymorphic context can be used within type constructors. In the simple case 
		// * this will be infered . Required thought on checking the base types of the super types. At some points these
		// * need to be identical declarations. It is also necessary to allow EventB style type constructors at this
		// * point. e.g., an associative operator is a subtype of a closed Event-B total function.
		// */ SuperTypeList:
		//	':' superType+=ConstructedType (',' superType+=ConstructedType)*;
		@Override public ParserRule getRule() { return rule; }
		
		//':' superType+=ConstructedType (',' superType+=ConstructedType)*
		public Group getGroup() { return cGroup; }
		
		//':'
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }
		
		//superType+=ConstructedType
		public Assignment getSuperTypeAssignment_1() { return cSuperTypeAssignment_1; }
		
		//ConstructedType
		public RuleCall getSuperTypeConstructedTypeParserRuleCall_1_0() { return cSuperTypeConstructedTypeParserRuleCall_1_0; }
		
		//(',' superType+=ConstructedType)*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//superType+=ConstructedType
		public Assignment getSuperTypeAssignment_2_1() { return cSuperTypeAssignment_2_1; }
		
		//ConstructedType
		public RuleCall getSuperTypeConstructedTypeParserRuleCall_2_1_0() { return cSuperTypeConstructedTypeParserRuleCall_2_1_0; }
	}
	public class ConstructedTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.ConstructedType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeTypeConstructorParserRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Keyword cMultiplicationSignKeyword_1_0_0 = (Keyword)cAlternatives_1_0.eContents().get(0);
		private final Keyword cRightwardsArrowKeyword_1_0_1 = (Keyword)cAlternatives_1_0.eContents().get(1);
		private final Keyword cPrivateUseAreaE102Keyword_1_0_2 = (Keyword)cAlternatives_1_0.eContents().get(2);
		private final Keyword cPrivateUseAreaE100Keyword_1_0_3 = (Keyword)cAlternatives_1_0.eContents().get(3);
		private final Keyword cLeftRightArrowKeyword_1_0_4 = (Keyword)cAlternatives_1_0.eContents().get(4);
		private final Keyword cRightwardsTwoHeadedArrowWithTailKeyword_1_0_5 = (Keyword)cAlternatives_1_0.eContents().get(5);
		private final Keyword cRightwardsArrowWithVerticalStrokeKeyword_1_0_6 = (Keyword)cAlternatives_1_0.eContents().get(6);
		private final Keyword cRightwardsArrowWithTailKeyword_1_0_7 = (Keyword)cAlternatives_1_0.eContents().get(7);
		private final Keyword cRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_1_0_8 = (Keyword)cAlternatives_1_0.eContents().get(8);
		private final Keyword cRightwardsTwoHeadedArrowKeyword_1_0_9 = (Keyword)cAlternatives_1_0.eContents().get(9);
		private final Assignment cTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypeConstructedTypeParserRuleCall_1_1_0 = (RuleCall)cTypeAssignment_1_1.eContents().get(0);
		
		///* Along with the normal Event-B type operator, and new B++ types the  */ ConstructedType:
		//	type+=TypeConstructor (('×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠') type+=ConstructedType)?;
		@Override public ParserRule getRule() { return rule; }
		
		//type+=TypeConstructor (('×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠') type+=ConstructedType)?
		public Group getGroup() { return cGroup; }
		
		//type+=TypeConstructor
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//TypeConstructor
		public RuleCall getTypeTypeConstructorParserRuleCall_0_0() { return cTypeTypeConstructorParserRuleCall_0_0; }
		
		//(('×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠') type+=ConstructedType)?
		public Group getGroup_1() { return cGroup_1; }
		
		//'×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠'
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//'×'
		public Keyword getMultiplicationSignKeyword_1_0_0() { return cMultiplicationSignKeyword_1_0_0; }
		
		//'→'
		public Keyword getRightwardsArrowKeyword_1_0_1() { return cRightwardsArrowKeyword_1_0_1; }
		
		//''
		public Keyword getPrivateUseAreaE102Keyword_1_0_2() { return cPrivateUseAreaE102Keyword_1_0_2; }
		
		//''
		public Keyword getPrivateUseAreaE100Keyword_1_0_3() { return cPrivateUseAreaE100Keyword_1_0_3; }
		
		//'↔'
		public Keyword getLeftRightArrowKeyword_1_0_4() { return cLeftRightArrowKeyword_1_0_4; }
		
		//'⤖'
		public Keyword getRightwardsTwoHeadedArrowWithTailKeyword_1_0_5() { return cRightwardsTwoHeadedArrowWithTailKeyword_1_0_5; }
		
		//'⇸'
		public Keyword getRightwardsArrowWithVerticalStrokeKeyword_1_0_6() { return cRightwardsArrowWithVerticalStrokeKeyword_1_0_6; }
		
		//'↣'
		public Keyword getRightwardsArrowWithTailKeyword_1_0_7() { return cRightwardsArrowWithTailKeyword_1_0_7; }
		
		//'⤀'
		public Keyword getRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_1_0_8() { return cRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_1_0_8; }
		
		//'↠'
		public Keyword getRightwardsTwoHeadedArrowKeyword_1_0_9() { return cRightwardsTwoHeadedArrowKeyword_1_0_9; }
		
		//type+=ConstructedType
		public Assignment getTypeAssignment_1_1() { return cTypeAssignment_1_1; }
		
		//ConstructedType
		public RuleCall getTypeConstructedTypeParserRuleCall_1_1_0() { return cTypeConstructedTypeParserRuleCall_1_1_0; }
	}
	public class TypeConstructorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TypeConstructor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeNameNameCrossReference_0_0 = (CrossReference)cTypeNameAssignment_0.eContents().get(0);
		private final RuleCall cTypeNameNameIDTerminalRuleCall_0_0_1 = (RuleCall)cTypeNameNameCrossReference_0_0.eContents().get(1);
		private final Assignment cContextAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cContextTypeDeclContextParserRuleCall_1_0 = (RuleCall)cContextAssignment_1.eContents().get(0);
		
		///* Type constructor has validation rules to check that there is no context when there is a polymorphic name, 
		// * and type checking on the polymorphic context. There is also  scope rule to check the usage of polymorphic types.
		// */ TypeConstructor:
		//	typeName=[Name] context+=TypeDeclContext?;
		@Override public ParserRule getRule() { return rule; }
		
		//typeName=[Name] context+=TypeDeclContext?
		public Group getGroup() { return cGroup; }
		
		//typeName=[Name]
		public Assignment getTypeNameAssignment_0() { return cTypeNameAssignment_0; }
		
		//[Name]
		public CrossReference getTypeNameNameCrossReference_0_0() { return cTypeNameNameCrossReference_0_0; }
		
		//ID
		public RuleCall getTypeNameNameIDTerminalRuleCall_0_0_1() { return cTypeNameNameIDTerminalRuleCall_0_0_1; }
		
		//context+=TypeDeclContext?
		public Assignment getContextAssignment_1() { return cContextAssignment_1; }
		
		//TypeDeclContext
		public RuleCall getContextTypeDeclContextParserRuleCall_1_0() { return cContextTypeDeclContextParserRuleCall_1_0; }
	}
	public class TypeDeclContextElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TypeDeclContext");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeNameConstructedTypeParserRuleCall_1_0 = (RuleCall)cTypeNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cTypeNameAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cTypeNameConstructedTypeParserRuleCall_2_1_0 = (RuleCall)cTypeNameAssignment_2_1.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//TypeDeclContext:
		//	'<' typeName+=ConstructedType (',' typeName+=ConstructedType)* '>';
		@Override public ParserRule getRule() { return rule; }
		
		//'<' typeName+=ConstructedType (',' typeName+=ConstructedType)* '>'
		public Group getGroup() { return cGroup; }
		
		//'<'
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }
		
		//typeName+=ConstructedType
		public Assignment getTypeNameAssignment_1() { return cTypeNameAssignment_1; }
		
		//ConstructedType
		public RuleCall getTypeNameConstructedTypeParserRuleCall_1_0() { return cTypeNameConstructedTypeParserRuleCall_1_0; }
		
		//(',' typeName+=ConstructedType)*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//typeName+=ConstructedType
		public Assignment getTypeNameAssignment_2_1() { return cTypeNameAssignment_2_1; }
		
		//ConstructedType
		public RuleCall getTypeNameConstructedTypeParserRuleCall_2_1_0() { return cTypeNameConstructedTypeParserRuleCall_2_1_0; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_3() { return cGreaterThanSignKeyword_3; }
	}
	public class TypedVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TypedVariable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cConstraintsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConstraintsPolyTypeConstraintsParserRuleCall_1_0 = (RuleCall)cConstraintsAssignment_1.eContents().get(0);
		
		///* -------------------- Next Thing -------------------------------- */
		///* This may need to be changed when we can construct the types more. */ TypedVariable:
		//	name=ID constraints+=PolyTypeConstraints;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID constraints+=PolyTypeConstraints
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//constraints+=PolyTypeConstraints
		public Assignment getConstraintsAssignment_1() { return cConstraintsAssignment_1; }
		
		//PolyTypeConstraints
		public RuleCall getConstraintsPolyTypeConstraintsParserRuleCall_1_0() { return cConstraintsPolyTypeConstraintsParserRuleCall_1_0; }
	}
	public class TypeDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TypeDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeNameTypeNameCrossReference_0_0 = (CrossReference)cTypeNameAssignment_0.eContents().get(0);
		private final RuleCall cTypeNameTypeNameIDTerminalRuleCall_0_0_1 = (RuleCall)cTypeNameTypeNameCrossReference_0_0.eContents().get(1);
		private final Assignment cContextAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cContextTypeDeclContextParserRuleCall_1_0 = (RuleCall)cContextAssignment_1.eContents().get(0);
		
		//TypeDeclaration:
		//	typeName=[TypeName] context=TypeDeclContext;
		@Override public ParserRule getRule() { return rule; }
		
		//typeName=[TypeName] context=TypeDeclContext
		public Group getGroup() { return cGroup; }
		
		//typeName=[TypeName]
		public Assignment getTypeNameAssignment_0() { return cTypeNameAssignment_0; }
		
		//[TypeName]
		public CrossReference getTypeNameTypeNameCrossReference_0_0() { return cTypeNameTypeNameCrossReference_0_0; }
		
		//ID
		public RuleCall getTypeNameTypeNameIDTerminalRuleCall_0_0_1() { return cTypeNameTypeNameIDTerminalRuleCall_0_0_1; }
		
		//context=TypeDeclContext
		public Assignment getContextAssignment_1() { return cContextAssignment_1; }
		
		//TypeDeclContext
		public RuleCall getContextTypeDeclContextParserRuleCall_1_0() { return cContextTypeDeclContextParserRuleCall_1_0; }
	}
	public class WhereElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Where");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhereKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpessionsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpessionsExpressionParserRuleCall_1_0 = (RuleCall)cExpessionsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cSemicolonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cExpressionsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cExpressionsExpressionParserRuleCall_2_1_0 = (RuleCall)cExpressionsAssignment_2_1.eContents().get(0);
		
		//Where:
		//	'where' expessions+=Expression (';' expressions+=Expression);
		@Override public ParserRule getRule() { return rule; }
		
		//'where' expessions+=Expression (';' expressions+=Expression)
		public Group getGroup() { return cGroup; }
		
		//'where'
		public Keyword getWhereKeyword_0() { return cWhereKeyword_0; }
		
		//expessions+=Expression
		public Assignment getExpessionsAssignment_1() { return cExpessionsAssignment_1; }
		
		//Expression
		public RuleCall getExpessionsExpressionParserRuleCall_1_0() { return cExpessionsExpressionParserRuleCall_1_0; }
		
		//';' expressions+=Expression
		public Group getGroup_2() { return cGroup_2; }
		
		//';'
		public Keyword getSemicolonKeyword_2_0() { return cSemicolonKeyword_2_0; }
		
		//expressions+=Expression
		public Assignment getExpressionsAssignment_2_1() { return cExpressionsAssignment_2_1; }
		
		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_2_1_0() { return cExpressionsExpressionParserRuleCall_2_1_0; }
	}
	public class TypeBodyElementsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TypeBodyElements");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cFunctionsAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cFunctionsFunctionDeclParserRuleCall_0_0 = (RuleCall)cFunctionsAssignment_0.eContents().get(0);
		private final Assignment cTheoremsAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cTheoremsTheoremBodyParserRuleCall_1_0 = (RuleCall)cTheoremsAssignment_1.eContents().get(0);
		
		//TypeBodyElements:
		//	functions+=FunctionDecl | theorems+=TheoremBody;
		@Override public ParserRule getRule() { return rule; }
		
		//functions+=FunctionDecl | theorems+=TheoremBody
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//functions+=FunctionDecl
		public Assignment getFunctionsAssignment_0() { return cFunctionsAssignment_0; }
		
		//FunctionDecl
		public RuleCall getFunctionsFunctionDeclParserRuleCall_0_0() { return cFunctionsFunctionDeclParserRuleCall_0_0; }
		
		//theorems+=TheoremBody
		public Assignment getTheoremsAssignment_1() { return cTheoremsAssignment_1; }
		
		//TheoremBody
		public RuleCall getTheoremsTheoremBodyParserRuleCall_1_0() { return cTheoremsTheoremBodyParserRuleCall_1_0; }
	}
	public class FunctionNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.FunctionName");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//FunctionName:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class DatatypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Datatype");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDatatypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameTypeNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cContextAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cContextPolyContextParserRuleCall_2_0 = (RuleCall)cContextAssignment_2.eContents().get(0);
		private final Assignment cConstructorsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cConstructorsDatatypeConstructorParserRuleCall_3_0 = (RuleCall)cConstructorsAssignment_3.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cBodyElementsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cBodyElementsTypeBodyElementsParserRuleCall_5_0 = (RuleCall)cBodyElementsAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//Datatype:
		//	'Datatype' name=TypeName context+=PolyContext? constructors+=DatatypeConstructor* '{' bodyElements+=TypeBodyElements*
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'Datatype' name=TypeName context+=PolyContext? constructors+=DatatypeConstructor* '{' bodyElements+=TypeBodyElements*
		//'}'
		public Group getGroup() { return cGroup; }
		
		//'Datatype'
		public Keyword getDatatypeKeyword_0() { return cDatatypeKeyword_0; }
		
		//name=TypeName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//TypeName
		public RuleCall getNameTypeNameParserRuleCall_1_0() { return cNameTypeNameParserRuleCall_1_0; }
		
		//context+=PolyContext?
		public Assignment getContextAssignment_2() { return cContextAssignment_2; }
		
		//PolyContext
		public RuleCall getContextPolyContextParserRuleCall_2_0() { return cContextPolyContextParserRuleCall_2_0; }
		
		//constructors+=DatatypeConstructor*
		public Assignment getConstructorsAssignment_3() { return cConstructorsAssignment_3; }
		
		//DatatypeConstructor
		public RuleCall getConstructorsDatatypeConstructorParserRuleCall_3_0() { return cConstructorsDatatypeConstructorParserRuleCall_3_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//bodyElements+=TypeBodyElements*
		public Assignment getBodyElementsAssignment_5() { return cBodyElementsAssignment_5; }
		
		//TypeBodyElements
		public RuleCall getBodyElementsTypeBodyElementsParserRuleCall_5_0() { return cBodyElementsTypeBodyElementsParserRuleCall_5_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}
	public class DatatypeConstructorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.DatatypeConstructor");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBaseConstructorParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cConstructorParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//DatatypeConstructor:
		//	BaseConstructor | Constructor;
		@Override public ParserRule getRule() { return rule; }
		
		//BaseConstructor | Constructor
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BaseConstructor
		public RuleCall getBaseConstructorParserRuleCall_0() { return cBaseConstructorParserRuleCall_0; }
		
		//Constructor
		public RuleCall getConstructorParserRuleCall_1() { return cConstructorParserRuleCall_1; }
	}
	public class BaseConstructorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.BaseConstructor");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//BaseConstructor:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class ConstructorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Constructor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypedVariablesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypedVariablesTypedVariableParserRuleCall_2_0 = (RuleCall)cTypedVariablesAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Constructor:
		//	name=ID '(' typedVariables+=TypedVariable* ')';
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID '(' typedVariables+=TypedVariable* ')'
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//typedVariables+=TypedVariable*
		public Assignment getTypedVariablesAssignment_2() { return cTypedVariablesAssignment_2; }
		
		//TypedVariable
		public RuleCall getTypedVariablesTypedVariableParserRuleCall_2_0() { return cTypedVariablesTypedVariableParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class ExtendElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Extend");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cNameTypeNameCrossReference_0_0 = (CrossReference)cNameAssignment_0.eContents().get(0);
		private final RuleCall cNameTypeNameIDTerminalRuleCall_0_0_1 = (RuleCall)cNameTypeNameCrossReference_0_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExtesnionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExtesnionIDTerminalRuleCall_2_0 = (RuleCall)cExtesnionAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cBodyElementsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cBodyElementsTypeBodyElementsParserRuleCall_5_0 = (RuleCall)cBodyElementsAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//Extend:
		//	name=[TypeName] '(' extesnion=ID ')' '{' bodyElements+=TypeBodyElements* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//name=[TypeName] '(' extesnion=ID ')' '{' bodyElements+=TypeBodyElements* '}'
		public Group getGroup() { return cGroup; }
		
		//name=[TypeName]
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//[TypeName]
		public CrossReference getNameTypeNameCrossReference_0_0() { return cNameTypeNameCrossReference_0_0; }
		
		//ID
		public RuleCall getNameTypeNameIDTerminalRuleCall_0_0_1() { return cNameTypeNameIDTerminalRuleCall_0_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//extesnion=ID
		public Assignment getExtesnionAssignment_2() { return cExtesnionAssignment_2; }
		
		//ID
		public RuleCall getExtesnionIDTerminalRuleCall_2_0() { return cExtesnionIDTerminalRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//bodyElements+=TypeBodyElements*
		public Assignment getBodyElementsAssignment_5() { return cBodyElementsAssignment_5; }
		
		//TypeBodyElements
		public RuleCall getBodyElementsTypeBodyElementsParserRuleCall_5_0() { return cBodyElementsTypeBodyElementsParserRuleCall_5_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}
	public class FunctionDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.FunctionDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameFunctionNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeVariablesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeVariablesTypedVariableParserRuleCall_2_0 = (RuleCall)cTypeVariablesAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//FunctionDecl:
		//	name+=FunctionName '(' typeVariables+=TypedVariable* ')';
		@Override public ParserRule getRule() { return rule; }
		
		//name+=FunctionName '(' typeVariables+=TypedVariable* ')'
		public Group getGroup() { return cGroup; }
		
		//name+=FunctionName
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//FunctionName
		public RuleCall getNameFunctionNameParserRuleCall_0_0() { return cNameFunctionNameParserRuleCall_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//typeVariables+=TypedVariable*
		public Assignment getTypeVariablesAssignment_2() { return cTypeVariablesAssignment_2; }
		
		//TypedVariable
		public RuleCall getTypeVariablesTypedVariableParserRuleCall_2_0() { return cTypeVariablesTypedVariableParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class TheoremBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TheoremBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTheoremsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//TheoremBody:
		//	'Theorems' '{' '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'Theorems' '{' '}'
		public Group getGroup() { return cGroup; }
		
		//'Theorems'
		public Keyword getTheoremsKeyword_0() { return cTheoremsKeyword_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_2() { return cRightCurlyBracketKeyword_2; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Expression");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Expression:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//// This needs to be written. Could be worth separating this out into another 
		//// dsl reducing the complexity of this section. Specifically I need to look out for
		//// the following expressions forall exists lambda function calls.
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	
	
	private final DomainModelElements pDomainModel;
	private final TopLevelElements pTopLevel;
	private final ImportStatementElements pImportStatement;
	private final ImportElements pImport;
	private final ImportComponentElements pImportComponent;
	private final ClassDeclElements pClassDecl;
	private final ClassElements pClass;
	private final NameElements pName;
	private final TypeNameElements pTypeName;
	private final PolymorphicTypeNameElements pPolymorphicTypeName;
	private final PolyContextElements pPolyContext;
	private final PolyContextTypesElements pPolyContextTypes;
	private final PolyTypeConstraintsElements pPolyTypeConstraints;
	private final SuperTypeListElements pSuperTypeList;
	private final ConstructedTypeElements pConstructedType;
	private final TypeConstructorElements pTypeConstructor;
	private final TypeDeclContextElements pTypeDeclContext;
	private final TypedVariableElements pTypedVariable;
	private final TypeDeclarationElements pTypeDeclaration;
	private final WhereElements pWhere;
	private final TypeBodyElementsElements pTypeBodyElements;
	private final FunctionNameElements pFunctionName;
	private final DatatypeElements pDatatype;
	private final DatatypeConstructorElements pDatatypeConstructor;
	private final BaseConstructorElements pBaseConstructor;
	private final ConstructorElements pConstructor;
	private final ExtendElements pExtend;
	private final FunctionDeclElements pFunctionDecl;
	private final TheoremBodyElements pTheoremBody;
	private final ExpressionElements pExpression;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public MyDslGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pDomainModel = new DomainModelElements();
		this.pTopLevel = new TopLevelElements();
		this.pImportStatement = new ImportStatementElements();
		this.pImport = new ImportElements();
		this.pImportComponent = new ImportComponentElements();
		this.pClassDecl = new ClassDeclElements();
		this.pClass = new ClassElements();
		this.pName = new NameElements();
		this.pTypeName = new TypeNameElements();
		this.pPolymorphicTypeName = new PolymorphicTypeNameElements();
		this.pPolyContext = new PolyContextElements();
		this.pPolyContextTypes = new PolyContextTypesElements();
		this.pPolyTypeConstraints = new PolyTypeConstraintsElements();
		this.pSuperTypeList = new SuperTypeListElements();
		this.pConstructedType = new ConstructedTypeElements();
		this.pTypeConstructor = new TypeConstructorElements();
		this.pTypeDeclContext = new TypeDeclContextElements();
		this.pTypedVariable = new TypedVariableElements();
		this.pTypeDeclaration = new TypeDeclarationElements();
		this.pWhere = new WhereElements();
		this.pTypeBodyElements = new TypeBodyElementsElements();
		this.pFunctionName = new FunctionNameElements();
		this.pDatatype = new DatatypeElements();
		this.pDatatypeConstructor = new DatatypeConstructorElements();
		this.pBaseConstructor = new BaseConstructorElements();
		this.pConstructor = new ConstructorElements();
		this.pExtend = new ExtendElements();
		this.pFunctionDecl = new FunctionDeclElements();
		this.pTheoremBody = new TheoremBodyElements();
		this.pExpression = new ExpressionElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.sampleProj.mydsl.MyDsl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//DomainModel:
	//	elements+=TopLevel*;
	public DomainModelElements getDomainModelAccess() {
		return pDomainModel;
	}
	
	public ParserRule getDomainModelRule() {
		return getDomainModelAccess().getRule();
	}
	
	//// Theorem names can include white space.
	////terminal THM_NAME: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9' ' | '|'\t')*;
	//TopLevel:
	//	ImportStatement | ClassDecl;
	public TopLevelElements getTopLevelAccess() {
		return pTopLevel;
	}
	
	public ParserRule getTopLevelRule() {
		return getTopLevelAccess().getRule();
	}
	
	//ImportStatement:
	//	'Import'
	//	imports+=Import;
	public ImportStatementElements getImportStatementAccess() {
		return pImportStatement;
	}
	
	public ParserRule getImportStatementRule() {
		return getImportStatementAccess().getRule();
	}
	
	//Import:
	//	importName+=ImportComponent ('.' importName+=ImportComponent);
	public ImportElements getImportAccess() {
		return pImport;
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}
	
	//ImportComponent:
	//	name=ID;
	public ImportComponentElements getImportComponentAccess() {
		return pImportComponent;
	}
	
	public ParserRule getImportComponentRule() {
		return getImportComponentAccess().getRule();
	}
	
	//ClassDecl:
	//	Class | Datatype | Extend;
	public ClassDeclElements getClassDeclAccess() {
		return pClassDecl;
	}
	
	public ParserRule getClassDeclRule() {
		return getClassDeclAccess().getRule();
	}
	
	//Class BppClass:
	//	'Class' typeName=TypeName context=PolyContext? supertypes=SuperTypeList? '{' bodyElements+=TypeBodyElements* '}';
	public ClassElements getClassAccess() {
		return pClass;
	}
	
	public ParserRule getClassRule() {
		return getClassAccess().getRule();
	}
	
	//Name:
	//	PolymorphicTypeName | TypeName;
	public NameElements getNameAccess() {
		return pName;
	}
	
	public ParserRule getNameRule() {
		return getNameAccess().getRule();
	}
	
	//TypeName:
	//	name=ID;
	public TypeNameElements getTypeNameAccess() {
		return pTypeName;
	}
	
	public ParserRule getTypeNameRule() {
		return getTypeNameAccess().getRule();
	}
	
	///*---------------- Polymorphic Context -------------------------- */ PolymorphicTypeName:
	//	name=ID;
	public PolymorphicTypeNameElements getPolymorphicTypeNameAccess() {
		return pPolymorphicTypeName;
	}
	
	public ParserRule getPolymorphicTypeNameRule() {
		return getPolymorphicTypeNameAccess().getRule();
	}
	
	//PolyContext:
	//	'<' polyTypes+=PolyContextTypes+ '>';
	public PolyContextElements getPolyContextAccess() {
		return pPolyContext;
	}
	
	public ParserRule getPolyContextRule() {
		return getPolyContextAccess().getRule();
	}
	
	//PolyContextTypes:
	//	name=PolymorphicTypeName constraints+=PolyTypeConstraints*;
	public PolyContextTypesElements getPolyContextTypesAccess() {
		return pPolyContextTypes;
	}
	
	public ParserRule getPolyContextTypesRule() {
		return getPolyContextTypesAccess().getRule();
	}
	
	//PolyTypeConstraints:
	//	':' typeName+=[TypeName] (',' typeName+=[TypeName])*;
	public PolyTypeConstraintsElements getPolyTypeConstraintsAccess() {
		return pPolyTypeConstraints;
	}
	
	public ParserRule getPolyTypeConstraintsRule() {
		return getPolyTypeConstraintsAccess().getRule();
	}
	
	///* ------------------- SuperTypes ---------------------------------- */ /* Any constriction on the polymorphic context has to be done by declaring the polymorphic context
	// * on the new type. If necessary the polymorphic context can be used within type constructors. In the simple case 
	// * this will be infered . Required thought on checking the base types of the super types. At some points these
	// * need to be identical declarations. It is also necessary to allow EventB style type constructors at this
	// * point. e.g., an associative operator is a subtype of a closed Event-B total function.
	// */ SuperTypeList:
	//	':' superType+=ConstructedType (',' superType+=ConstructedType)*;
	public SuperTypeListElements getSuperTypeListAccess() {
		return pSuperTypeList;
	}
	
	public ParserRule getSuperTypeListRule() {
		return getSuperTypeListAccess().getRule();
	}
	
	///* Along with the normal Event-B type operator, and new B++ types the  */ ConstructedType:
	//	type+=TypeConstructor (('×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠') type+=ConstructedType)?;
	public ConstructedTypeElements getConstructedTypeAccess() {
		return pConstructedType;
	}
	
	public ParserRule getConstructedTypeRule() {
		return getConstructedTypeAccess().getRule();
	}
	
	///* Type constructor has validation rules to check that there is no context when there is a polymorphic name, 
	// * and type checking on the polymorphic context. There is also  scope rule to check the usage of polymorphic types.
	// */ TypeConstructor:
	//	typeName=[Name] context+=TypeDeclContext?;
	public TypeConstructorElements getTypeConstructorAccess() {
		return pTypeConstructor;
	}
	
	public ParserRule getTypeConstructorRule() {
		return getTypeConstructorAccess().getRule();
	}
	
	//TypeDeclContext:
	//	'<' typeName+=ConstructedType (',' typeName+=ConstructedType)* '>';
	public TypeDeclContextElements getTypeDeclContextAccess() {
		return pTypeDeclContext;
	}
	
	public ParserRule getTypeDeclContextRule() {
		return getTypeDeclContextAccess().getRule();
	}
	
	///* -------------------- Next Thing -------------------------------- */
	///* This may need to be changed when we can construct the types more. */ TypedVariable:
	//	name=ID constraints+=PolyTypeConstraints;
	public TypedVariableElements getTypedVariableAccess() {
		return pTypedVariable;
	}
	
	public ParserRule getTypedVariableRule() {
		return getTypedVariableAccess().getRule();
	}
	
	//TypeDeclaration:
	//	typeName=[TypeName] context=TypeDeclContext;
	public TypeDeclarationElements getTypeDeclarationAccess() {
		return pTypeDeclaration;
	}
	
	public ParserRule getTypeDeclarationRule() {
		return getTypeDeclarationAccess().getRule();
	}
	
	//Where:
	//	'where' expessions+=Expression (';' expressions+=Expression);
	public WhereElements getWhereAccess() {
		return pWhere;
	}
	
	public ParserRule getWhereRule() {
		return getWhereAccess().getRule();
	}
	
	//TypeBodyElements:
	//	functions+=FunctionDecl | theorems+=TheoremBody;
	public TypeBodyElementsElements getTypeBodyElementsAccess() {
		return pTypeBodyElements;
	}
	
	public ParserRule getTypeBodyElementsRule() {
		return getTypeBodyElementsAccess().getRule();
	}
	
	//FunctionName:
	//	name=ID;
	public FunctionNameElements getFunctionNameAccess() {
		return pFunctionName;
	}
	
	public ParserRule getFunctionNameRule() {
		return getFunctionNameAccess().getRule();
	}
	
	//Datatype:
	//	'Datatype' name=TypeName context+=PolyContext? constructors+=DatatypeConstructor* '{' bodyElements+=TypeBodyElements*
	//	'}';
	public DatatypeElements getDatatypeAccess() {
		return pDatatype;
	}
	
	public ParserRule getDatatypeRule() {
		return getDatatypeAccess().getRule();
	}
	
	//DatatypeConstructor:
	//	BaseConstructor | Constructor;
	public DatatypeConstructorElements getDatatypeConstructorAccess() {
		return pDatatypeConstructor;
	}
	
	public ParserRule getDatatypeConstructorRule() {
		return getDatatypeConstructorAccess().getRule();
	}
	
	//BaseConstructor:
	//	name=ID;
	public BaseConstructorElements getBaseConstructorAccess() {
		return pBaseConstructor;
	}
	
	public ParserRule getBaseConstructorRule() {
		return getBaseConstructorAccess().getRule();
	}
	
	//Constructor:
	//	name=ID '(' typedVariables+=TypedVariable* ')';
	public ConstructorElements getConstructorAccess() {
		return pConstructor;
	}
	
	public ParserRule getConstructorRule() {
		return getConstructorAccess().getRule();
	}
	
	//Extend:
	//	name=[TypeName] '(' extesnion=ID ')' '{' bodyElements+=TypeBodyElements* '}';
	public ExtendElements getExtendAccess() {
		return pExtend;
	}
	
	public ParserRule getExtendRule() {
		return getExtendAccess().getRule();
	}
	
	//FunctionDecl:
	//	name+=FunctionName '(' typeVariables+=TypedVariable* ')';
	public FunctionDeclElements getFunctionDeclAccess() {
		return pFunctionDecl;
	}
	
	public ParserRule getFunctionDeclRule() {
		return getFunctionDeclAccess().getRule();
	}
	
	//TheoremBody:
	//	'Theorems' '{' '}';
	public TheoremBodyElements getTheoremBodyAccess() {
		return pTheoremBody;
	}
	
	public ParserRule getTheoremBodyRule() {
		return getTheoremBodyAccess().getRule();
	}
	
	//Expression:
	//	name=ID;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
