/*
 * generated by Xtext 2.13.0
 */
package org.xtext.sampleProj.mydsl.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class MyDslGrammarAccess extends AbstractGrammarElementFinder {
	
	public class DomainModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.DomainModel");
		private final Assignment cElementsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cElementsTopLevelParserRuleCall_0 = (RuleCall)cElementsAssignment.eContents().get(0);
		
		//DomainModel:
		//	elements+=TopLevel*;
		@Override public ParserRule getRule() { return rule; }
		
		//elements+=TopLevel*
		public Assignment getElementsAssignment() { return cElementsAssignment; }
		
		//TopLevel
		public RuleCall getElementsTopLevelParserRuleCall_0() { return cElementsTopLevelParserRuleCall_0; }
	}
	public class THM_NAMEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.THM_NAME");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_0_2 = (RuleCall)cAlternatives_0.eContents().get(2);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//// Theorem names can include white space. Work out how to change this to any string without a ':'
		//THM_NAME:
		//	(INT | ID | WS)* ":";
		@Override public ParserRule getRule() { return rule; }
		
		//(INT | ID | WS)* ":"
		public Group getGroup() { return cGroup; }
		
		//(INT | ID | WS)*
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0_0() { return cINTTerminalRuleCall_0_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0_1() { return cIDTerminalRuleCall_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_0_2() { return cWSTerminalRuleCall_0_2; }
		
		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
	}
	public class TopLevelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TopLevel");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cImportStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cClassDeclParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cInstanceParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//TopLevel:
		//	ImportStatement | ClassDecl | Instance;
		@Override public ParserRule getRule() { return rule; }
		
		//ImportStatement | ClassDecl | Instance
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ImportStatement
		public RuleCall getImportStatementParserRuleCall_0() { return cImportStatementParserRuleCall_0; }
		
		//ClassDecl
		public RuleCall getClassDeclParserRuleCall_1() { return cClassDeclParserRuleCall_1; }
		
		//Instance
		public RuleCall getInstanceParserRuleCall_2() { return cInstanceParserRuleCall_2; }
	}
	public class ImportStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.ImportStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cImportsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImportsImportParserRuleCall_1_0 = (RuleCall)cImportsAssignment_1.eContents().get(0);
		
		//ImportStatement:
		//	'Import'
		//	imports+=Import;
		@Override public ParserRule getRule() { return rule; }
		
		//'Import' imports+=Import
		public Group getGroup() { return cGroup; }
		
		//'Import'
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }
		
		//imports+=Import
		public Assignment getImportsAssignment_1() { return cImportsAssignment_1; }
		
		//Import
		public RuleCall getImportsImportParserRuleCall_1_0() { return cImportsImportParserRuleCall_1_0; }
	}
	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Import");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cImportNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cImportNameImportComponentParserRuleCall_0_0 = (RuleCall)cImportNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cImportNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cImportNameImportComponentParserRuleCall_1_1_0 = (RuleCall)cImportNameAssignment_1_1.eContents().get(0);
		
		//Import:
		//	importName+=ImportComponent ('.' importName+=ImportComponent);
		@Override public ParserRule getRule() { return rule; }
		
		//importName+=ImportComponent ('.' importName+=ImportComponent)
		public Group getGroup() { return cGroup; }
		
		//importName+=ImportComponent
		public Assignment getImportNameAssignment_0() { return cImportNameAssignment_0; }
		
		//ImportComponent
		public RuleCall getImportNameImportComponentParserRuleCall_0_0() { return cImportNameImportComponentParserRuleCall_0_0; }
		
		//'.' importName+=ImportComponent
		public Group getGroup_1() { return cGroup_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }
		
		//importName+=ImportComponent
		public Assignment getImportNameAssignment_1_1() { return cImportNameAssignment_1_1; }
		
		//ImportComponent
		public RuleCall getImportNameImportComponentParserRuleCall_1_1_0() { return cImportNameImportComponentParserRuleCall_1_1_0; }
	}
	public class ImportComponentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.ImportComponent");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//ImportComponent:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class ClassDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.ClassDecl");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cClassParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDatatypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cExtendParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//ClassDecl:
		//	Class | Datatype | Extend;
		@Override public ParserRule getRule() { return rule; }
		
		//Class | Datatype | Extend
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Class
		public RuleCall getClassParserRuleCall_0() { return cClassParserRuleCall_0; }
		
		//Datatype
		public RuleCall getDatatypeParserRuleCall_1() { return cDatatypeParserRuleCall_1; }
		
		//Extend
		public RuleCall getExtendParserRuleCall_2() { return cExtendParserRuleCall_2; }
	}
	public class ClassElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Class");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cClassKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeNameTypeNameParserRuleCall_1_0 = (RuleCall)cTypeNameAssignment_1.eContents().get(0);
		private final Assignment cContextAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cContextPolyContextParserRuleCall_2_0 = (RuleCall)cContextAssignment_2.eContents().get(0);
		private final Assignment cSupertypesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cSupertypesSuperTypeListParserRuleCall_3_0 = (RuleCall)cSupertypesAssignment_3.eContents().get(0);
		private final Assignment cVarListAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cVarListTypeStructureParserRuleCall_4_0 = (RuleCall)cVarListAssignment_4.eContents().get(0);
		private final Assignment cWhereAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cWhereWhereParserRuleCall_5_0 = (RuleCall)cWhereAssignment_5.eContents().get(0);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cLeftCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cBodyElementsAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cBodyElementsTypeBodyElementsParserRuleCall_8_0 = (RuleCall)cBodyElementsAssignment_8.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		///* ------------------------ Class statements --------------------- */ Class BppClass:
		//	'Class' TypeName=TypeName context=PolyContext? supertypes=SuperTypeList? varList=TypeStructure? where=Where? ';'?
		//	'{' bodyElements+=TypeBodyElements* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'Class' TypeName=TypeName context=PolyContext? supertypes=SuperTypeList? varList=TypeStructure? where=Where? ';'? '{'
		//bodyElements+=TypeBodyElements* '}'
		public Group getGroup() { return cGroup; }
		
		//'Class'
		public Keyword getClassKeyword_0() { return cClassKeyword_0; }
		
		//TypeName=TypeName
		public Assignment getTypeNameAssignment_1() { return cTypeNameAssignment_1; }
		
		//TypeName
		public RuleCall getTypeNameTypeNameParserRuleCall_1_0() { return cTypeNameTypeNameParserRuleCall_1_0; }
		
		//context=PolyContext?
		public Assignment getContextAssignment_2() { return cContextAssignment_2; }
		
		//PolyContext
		public RuleCall getContextPolyContextParserRuleCall_2_0() { return cContextPolyContextParserRuleCall_2_0; }
		
		//supertypes=SuperTypeList?
		public Assignment getSupertypesAssignment_3() { return cSupertypesAssignment_3; }
		
		//SuperTypeList
		public RuleCall getSupertypesSuperTypeListParserRuleCall_3_0() { return cSupertypesSuperTypeListParserRuleCall_3_0; }
		
		//varList=TypeStructure?
		public Assignment getVarListAssignment_4() { return cVarListAssignment_4; }
		
		//TypeStructure
		public RuleCall getVarListTypeStructureParserRuleCall_4_0() { return cVarListTypeStructureParserRuleCall_4_0; }
		
		//where=Where?
		public Assignment getWhereAssignment_5() { return cWhereAssignment_5; }
		
		//Where
		public RuleCall getWhereWhereParserRuleCall_5_0() { return cWhereWhereParserRuleCall_5_0; }
		
		//';'?
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_7() { return cLeftCurlyBracketKeyword_7; }
		
		//bodyElements+=TypeBodyElements*
		public Assignment getBodyElementsAssignment_8() { return cBodyElementsAssignment_8; }
		
		//TypeBodyElements
		public RuleCall getBodyElementsTypeBodyElementsParserRuleCall_8_0() { return cBodyElementsTypeBodyElementsParserRuleCall_8_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_9() { return cRightCurlyBracketKeyword_9; }
	}
	public class GenNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.GenName");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPolymorphicTypeNameParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypeNameParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//GenName:
		//	PolymorphicTypeName | TypeName;
		@Override public ParserRule getRule() { return rule; }
		
		//PolymorphicTypeName | TypeName
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PolymorphicTypeName
		public RuleCall getPolymorphicTypeNameParserRuleCall_0() { return cPolymorphicTypeNameParserRuleCall_0; }
		
		//TypeName
		public RuleCall getTypeNameParserRuleCall_1() { return cTypeNameParserRuleCall_1; }
	}
	public class TypeNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TypeName");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//TypeName:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class PolymorphicTypeNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.PolymorphicTypeName");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		///*---------------- Polymorphic Context of -------------------------- */ PolymorphicTypeName:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class PolyContextElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.PolyContext");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPolyTypesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPolyTypesPolyContextTypesParserRuleCall_1_0 = (RuleCall)cPolyTypesAssignment_1.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//PolyContext:
		//	'<' polyTypes+=PolyContextTypes+ '>';
		@Override public ParserRule getRule() { return rule; }
		
		//'<' polyTypes+=PolyContextTypes+ '>'
		public Group getGroup() { return cGroup; }
		
		//'<'
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }
		
		//polyTypes+=PolyContextTypes+
		public Assignment getPolyTypesAssignment_1() { return cPolyTypesAssignment_1; }
		
		//PolyContextTypes
		public RuleCall getPolyTypesPolyContextTypesParserRuleCall_1_0() { return cPolyTypesPolyContextTypesParserRuleCall_1_0; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_2() { return cGreaterThanSignKeyword_2; }
	}
	public class PolyContextTypesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.PolyContextTypes");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNamePolymorphicTypeNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cConstraintsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConstraintsPolyTypeConstraintsParserRuleCall_1_0 = (RuleCall)cConstraintsAssignment_1.eContents().get(0);
		
		//PolyContextTypes:
		//	name=PolymorphicTypeName constraints+=PolyTypeConstraints*;
		@Override public ParserRule getRule() { return rule; }
		
		//name=PolymorphicTypeName constraints+=PolyTypeConstraints*
		public Group getGroup() { return cGroup; }
		
		//name=PolymorphicTypeName
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//PolymorphicTypeName
		public RuleCall getNamePolymorphicTypeNameParserRuleCall_0_0() { return cNamePolymorphicTypeNameParserRuleCall_0_0; }
		
		//constraints+=PolyTypeConstraints*
		public Assignment getConstraintsAssignment_1() { return cConstraintsAssignment_1; }
		
		//PolyTypeConstraints
		public RuleCall getConstraintsPolyTypeConstraintsParserRuleCall_1_0() { return cConstraintsPolyTypeConstraintsParserRuleCall_1_0; }
	}
	public class PolyTypeConstraintsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.PolyTypeConstraints");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cTypeNameTypeNameCrossReference_1_0 = (CrossReference)cTypeNameAssignment_1.eContents().get(0);
		private final RuleCall cTypeNameTypeNameIDTerminalRuleCall_1_0_1 = (RuleCall)cTypeNameTypeNameCrossReference_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cTypeNameAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final CrossReference cTypeNameTypeNameCrossReference_2_1_0 = (CrossReference)cTypeNameAssignment_2_1.eContents().get(0);
		private final RuleCall cTypeNameTypeNameIDTerminalRuleCall_2_1_0_1 = (RuleCall)cTypeNameTypeNameCrossReference_2_1_0.eContents().get(1);
		
		//PolyTypeConstraints:
		//	':' TypeName+=[TypeName] (',' TypeName+=[TypeName])*;
		@Override public ParserRule getRule() { return rule; }
		
		//':' TypeName+=[TypeName] (',' TypeName+=[TypeName])*
		public Group getGroup() { return cGroup; }
		
		//':'
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }
		
		//TypeName+=[TypeName]
		public Assignment getTypeNameAssignment_1() { return cTypeNameAssignment_1; }
		
		//[TypeName]
		public CrossReference getTypeNameTypeNameCrossReference_1_0() { return cTypeNameTypeNameCrossReference_1_0; }
		
		//ID
		public RuleCall getTypeNameTypeNameIDTerminalRuleCall_1_0_1() { return cTypeNameTypeNameIDTerminalRuleCall_1_0_1; }
		
		//(',' TypeName+=[TypeName])*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//TypeName+=[TypeName]
		public Assignment getTypeNameAssignment_2_1() { return cTypeNameAssignment_2_1; }
		
		//[TypeName]
		public CrossReference getTypeNameTypeNameCrossReference_2_1_0() { return cTypeNameTypeNameCrossReference_2_1_0; }
		
		//ID
		public RuleCall getTypeNameTypeNameIDTerminalRuleCall_2_1_0_1() { return cTypeNameTypeNameIDTerminalRuleCall_2_1_0_1; }
	}
	public class SuperTypeListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.SuperTypeList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSuperTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSuperTypeConstructedTypeParserRuleCall_1_0 = (RuleCall)cSuperTypeAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cSuperTypeAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cSuperTypeConstructedTypeParserRuleCall_2_1_0 = (RuleCall)cSuperTypeAssignment_2_1.eContents().get(0);
		
		///* ------------------- SuperTypes ---------------------------------- */ /* Any constriction on the polymorphic context has to be done by declaring the polymorphic context
		// * on the new type. If necessary the polymorphic context can be used within type constructors. In the simple case 
		// * this will be inferred . Required thought on checking the base types of the super types. At some points these
		// * need to be identical declarations. It is also necessary to allow EventB style type constructors at this
		// * point. e.g., an associative operator is a subtype of a closed Event-B total function.
		// */ SuperTypeList:
		//	':' superType+=ConstructedType (',' superType+=ConstructedType)*;
		@Override public ParserRule getRule() { return rule; }
		
		//':' superType+=ConstructedType (',' superType+=ConstructedType)*
		public Group getGroup() { return cGroup; }
		
		//':'
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }
		
		//superType+=ConstructedType
		public Assignment getSuperTypeAssignment_1() { return cSuperTypeAssignment_1; }
		
		//ConstructedType
		public RuleCall getSuperTypeConstructedTypeParserRuleCall_1_0() { return cSuperTypeConstructedTypeParserRuleCall_1_0; }
		
		//(',' superType+=ConstructedType)*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//superType+=ConstructedType
		public Assignment getSuperTypeAssignment_2_1() { return cSuperTypeAssignment_2_1; }
		
		//ConstructedType
		public RuleCall getSuperTypeConstructedTypeParserRuleCall_2_1_0() { return cSuperTypeConstructedTypeParserRuleCall_2_1_0; }
	}
	public class ConstructedTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.ConstructedType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeTypeConstructorParserRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Keyword cMultiplicationSignKeyword_1_0_0 = (Keyword)cAlternatives_1_0.eContents().get(0);
		private final Keyword cRightwardsArrowKeyword_1_0_1 = (Keyword)cAlternatives_1_0.eContents().get(1);
		private final Keyword cPrivateUseAreaE102Keyword_1_0_2 = (Keyword)cAlternatives_1_0.eContents().get(2);
		private final Keyword cPrivateUseAreaE100Keyword_1_0_3 = (Keyword)cAlternatives_1_0.eContents().get(3);
		private final Keyword cLeftRightArrowKeyword_1_0_4 = (Keyword)cAlternatives_1_0.eContents().get(4);
		private final Keyword cRightwardsTwoHeadedArrowWithTailKeyword_1_0_5 = (Keyword)cAlternatives_1_0.eContents().get(5);
		private final Keyword cRightwardsArrowWithVerticalStrokeKeyword_1_0_6 = (Keyword)cAlternatives_1_0.eContents().get(6);
		private final Keyword cRightwardsArrowWithTailKeyword_1_0_7 = (Keyword)cAlternatives_1_0.eContents().get(7);
		private final Keyword cRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_1_0_8 = (Keyword)cAlternatives_1_0.eContents().get(8);
		private final Keyword cRightwardsTwoHeadedArrowKeyword_1_0_9 = (Keyword)cAlternatives_1_0.eContents().get(9);
		private final Assignment cTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypeConstructedTypeParserRuleCall_1_1_0 = (RuleCall)cTypeAssignment_1_1.eContents().get(0);
		
		///* Along with the normal Event-B type operator, and new B++ types the  */ ConstructedType:
		//	type+=TypeConstructor (('×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠') type+=ConstructedType)?;
		@Override public ParserRule getRule() { return rule; }
		
		//type+=TypeConstructor (('×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠') type+=ConstructedType)?
		public Group getGroup() { return cGroup; }
		
		//type+=TypeConstructor
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//TypeConstructor
		public RuleCall getTypeTypeConstructorParserRuleCall_0_0() { return cTypeTypeConstructorParserRuleCall_0_0; }
		
		//(('×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠') type+=ConstructedType)?
		public Group getGroup_1() { return cGroup_1; }
		
		//'×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠'
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//'×'
		public Keyword getMultiplicationSignKeyword_1_0_0() { return cMultiplicationSignKeyword_1_0_0; }
		
		//'→'
		public Keyword getRightwardsArrowKeyword_1_0_1() { return cRightwardsArrowKeyword_1_0_1; }
		
		//''
		public Keyword getPrivateUseAreaE102Keyword_1_0_2() { return cPrivateUseAreaE102Keyword_1_0_2; }
		
		//''
		public Keyword getPrivateUseAreaE100Keyword_1_0_3() { return cPrivateUseAreaE100Keyword_1_0_3; }
		
		//'↔'
		public Keyword getLeftRightArrowKeyword_1_0_4() { return cLeftRightArrowKeyword_1_0_4; }
		
		//'⤖'
		public Keyword getRightwardsTwoHeadedArrowWithTailKeyword_1_0_5() { return cRightwardsTwoHeadedArrowWithTailKeyword_1_0_5; }
		
		//'⇸'
		public Keyword getRightwardsArrowWithVerticalStrokeKeyword_1_0_6() { return cRightwardsArrowWithVerticalStrokeKeyword_1_0_6; }
		
		//'↣'
		public Keyword getRightwardsArrowWithTailKeyword_1_0_7() { return cRightwardsArrowWithTailKeyword_1_0_7; }
		
		//'⤀'
		public Keyword getRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_1_0_8() { return cRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_1_0_8; }
		
		//'↠'
		public Keyword getRightwardsTwoHeadedArrowKeyword_1_0_9() { return cRightwardsTwoHeadedArrowKeyword_1_0_9; }
		
		//type+=ConstructedType
		public Assignment getTypeAssignment_1_1() { return cTypeAssignment_1_1; }
		
		//ConstructedType
		public RuleCall getTypeConstructedTypeParserRuleCall_1_1_0() { return cTypeConstructedTypeParserRuleCall_1_1_0; }
	}
	public class TypeConstructorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TypeConstructor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cTypeNameAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final CrossReference cTypeNameGenNameCrossReference_0_0_0 = (CrossReference)cTypeNameAssignment_0_0.eContents().get(0);
		private final RuleCall cTypeNameGenNameIDTerminalRuleCall_0_0_0_1 = (RuleCall)cTypeNameGenNameCrossReference_0_0_0.eContents().get(1);
		private final RuleCall cInbuiltTypeScanParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final Assignment cContextAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cContextTypeDeclContextParserRuleCall_1_0 = (RuleCall)cContextAssignment_1.eContents().get(0);
		
		///* Type constructor has validation rules to check that there is no context when there is a polymorphic name, 
		// * and type checking on the polymorphic context. There is also  scope rule to check the usage of polymorphic types.
		// * Probably need to add the predicate type to this.
		// */ TypeConstructor:
		//	(TypeName=[GenName] | InbuiltTypeScan) context+=TypeDeclContext?;
		@Override public ParserRule getRule() { return rule; }
		
		//(TypeName=[GenName] | InbuiltTypeScan) context+=TypeDeclContext?
		public Group getGroup() { return cGroup; }
		
		//TypeName=[GenName] | InbuiltTypeScan
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//TypeName=[GenName]
		public Assignment getTypeNameAssignment_0_0() { return cTypeNameAssignment_0_0; }
		
		//[GenName]
		public CrossReference getTypeNameGenNameCrossReference_0_0_0() { return cTypeNameGenNameCrossReference_0_0_0; }
		
		//ID
		public RuleCall getTypeNameGenNameIDTerminalRuleCall_0_0_0_1() { return cTypeNameGenNameIDTerminalRuleCall_0_0_0_1; }
		
		//InbuiltTypeScan
		public RuleCall getInbuiltTypeScanParserRuleCall_0_1() { return cInbuiltTypeScanParserRuleCall_0_1; }
		
		//context+=TypeDeclContext?
		public Assignment getContextAssignment_1() { return cContextAssignment_1; }
		
		//TypeDeclContext
		public RuleCall getContextTypeDeclContextParserRuleCall_1_0() { return cContextTypeDeclContextParserRuleCall_1_0; }
	}
	public class TypeDeclContextElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TypeDeclContext");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeNameConstructedTypeParserRuleCall_1_0 = (RuleCall)cTypeNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cTypeNameAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cTypeNameConstructedTypeParserRuleCall_2_1_0 = (RuleCall)cTypeNameAssignment_2_1.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//TypeDeclContext:
		//	'<' TypeName+=ConstructedType (',' TypeName+=ConstructedType)* '>';
		@Override public ParserRule getRule() { return rule; }
		
		//'<' TypeName+=ConstructedType (',' TypeName+=ConstructedType)* '>'
		public Group getGroup() { return cGroup; }
		
		//'<'
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }
		
		//TypeName+=ConstructedType
		public Assignment getTypeNameAssignment_1() { return cTypeNameAssignment_1; }
		
		//ConstructedType
		public RuleCall getTypeNameConstructedTypeParserRuleCall_1_0() { return cTypeNameConstructedTypeParserRuleCall_1_0; }
		
		//(',' TypeName+=ConstructedType)*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//TypeName+=ConstructedType
		public Assignment getTypeNameAssignment_2_1() { return cTypeNameAssignment_2_1; }
		
		//ConstructedType
		public RuleCall getTypeNameConstructedTypeParserRuleCall_2_1_0() { return cTypeNameConstructedTypeParserRuleCall_2_1_0; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_3() { return cGreaterThanSignKeyword_3; }
	}
	public class TypeStructureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TypeStructure");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVariablesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVariablesTypedVariableListParserRuleCall_1_0 = (RuleCall)cVariablesAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		///* -------------------- Type Structure ---------------------------------- */ TypeStructure:
		//	'(' variables=TypedVariableList ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' variables=TypedVariableList ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//variables=TypedVariableList
		public Assignment getVariablesAssignment_1() { return cVariablesAssignment_1; }
		
		//TypedVariableList
		public RuleCall getVariablesTypedVariableListParserRuleCall_1_0() { return cVariablesTypedVariableListParserRuleCall_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class WhereElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Where");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhereKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpessionsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpessionsQuantifierParserRuleCall_1_0 = (RuleCall)cExpessionsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cSemicolonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cExpressionsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cExpressionsRootExpressionParserRuleCall_2_1_0 = (RuleCall)cExpressionsAssignment_2_1.eContents().get(0);
		
		///* -------------------- Where Statement -------------------------------- */ /* Type checking (which is not implemented yet) is used to type check that Expression returns a 
		// * predicate. Expression has not yet been written, but is far too general to be included in the where
		// * statement.
		// */ Where:
		//	'where' expessions+=Quantifier (';' expressions+=RootExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//'where' expessions+=Quantifier (';' expressions+=RootExpression)*
		public Group getGroup() { return cGroup; }
		
		//'where'
		public Keyword getWhereKeyword_0() { return cWhereKeyword_0; }
		
		//expessions+=Quantifier
		public Assignment getExpessionsAssignment_1() { return cExpessionsAssignment_1; }
		
		//Quantifier
		public RuleCall getExpessionsQuantifierParserRuleCall_1_0() { return cExpessionsQuantifierParserRuleCall_1_0; }
		
		//(';' expressions+=RootExpression)*
		public Group getGroup_2() { return cGroup_2; }
		
		//';'
		public Keyword getSemicolonKeyword_2_0() { return cSemicolonKeyword_2_0; }
		
		//expressions+=RootExpression
		public Assignment getExpressionsAssignment_2_1() { return cExpressionsAssignment_2_1; }
		
		//RootExpression
		public RuleCall getExpressionsRootExpressionParserRuleCall_2_1_0() { return cExpressionsRootExpressionParserRuleCall_2_1_0; }
	}
	public class DatatypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Datatype");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDatatypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameTypeNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cContextAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cContextPolyContextParserRuleCall_2_0 = (RuleCall)cContextAssignment_2.eContents().get(0);
		private final Assignment cConstructorsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cConstructorsDatatypeConstructorParserRuleCall_3_0 = (RuleCall)cConstructorsAssignment_3.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cBodyElementsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cBodyElementsTypeBodyElementsParserRuleCall_5_0 = (RuleCall)cBodyElementsAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		///* ---------------------- Datatype declarations -------------------------- */ Datatype:
		//	'Datatype' name=TypeName context=PolyContext? constructors+=DatatypeConstructor* '{' bodyElements+=TypeBodyElements*
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'Datatype' name=TypeName context=PolyContext? constructors+=DatatypeConstructor* '{' bodyElements+=TypeBodyElements* '}'
		public Group getGroup() { return cGroup; }
		
		//'Datatype'
		public Keyword getDatatypeKeyword_0() { return cDatatypeKeyword_0; }
		
		//name=TypeName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//TypeName
		public RuleCall getNameTypeNameParserRuleCall_1_0() { return cNameTypeNameParserRuleCall_1_0; }
		
		//context=PolyContext?
		public Assignment getContextAssignment_2() { return cContextAssignment_2; }
		
		//PolyContext
		public RuleCall getContextPolyContextParserRuleCall_2_0() { return cContextPolyContextParserRuleCall_2_0; }
		
		//constructors+=DatatypeConstructor*
		public Assignment getConstructorsAssignment_3() { return cConstructorsAssignment_3; }
		
		//DatatypeConstructor
		public RuleCall getConstructorsDatatypeConstructorParserRuleCall_3_0() { return cConstructorsDatatypeConstructorParserRuleCall_3_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//bodyElements+=TypeBodyElements*
		public Assignment getBodyElementsAssignment_5() { return cBodyElementsAssignment_5; }
		
		//TypeBodyElements
		public RuleCall getBodyElementsTypeBodyElementsParserRuleCall_5_0() { return cBodyElementsTypeBodyElementsParserRuleCall_5_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}
	public class DatatypeConstructorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.DatatypeConstructor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVerticalLineKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cBaseConstructorParserRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cDTypeConstructorParserRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		
		///* PolyContext is the same as PolyContext used by the class declaration above. */ DatatypeConstructor:
		//	'|' (BaseConstructor | DTypeConstructor);
		@Override public ParserRule getRule() { return rule; }
		
		//'|' (BaseConstructor | DTypeConstructor)
		public Group getGroup() { return cGroup; }
		
		//'|'
		public Keyword getVerticalLineKeyword_0() { return cVerticalLineKeyword_0; }
		
		//BaseConstructor | DTypeConstructor
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//BaseConstructor
		public RuleCall getBaseConstructorParserRuleCall_1_0() { return cBaseConstructorParserRuleCall_1_0; }
		
		//DTypeConstructor
		public RuleCall getDTypeConstructorParserRuleCall_1_1() { return cDTypeConstructorParserRuleCall_1_1; }
	}
	public class BaseConstructorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.BaseConstructor");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//BaseConstructor:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class DTypeConstructorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.DTypeConstructor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cDeconsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDeconsTypedVariableListParserRuleCall_2_0 = (RuleCall)cDeconsAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		///* Typed Variable list is declared below, it is used in several situations such as functions/lambdas
		// * not just in Datatypes.
		// */ DTypeConstructor:
		//	name=ID '(' decons=TypedVariableList ')';
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID '(' decons=TypedVariableList ')'
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//decons=TypedVariableList
		public Assignment getDeconsAssignment_2() { return cDeconsAssignment_2; }
		
		//TypedVariableList
		public RuleCall getDeconsTypedVariableListParserRuleCall_2_0() { return cDeconsTypedVariableListParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class ExtendElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Extend");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cNameTypeNameCrossReference_0_0 = (CrossReference)cNameAssignment_0.eContents().get(0);
		private final RuleCall cNameTypeNameIDTerminalRuleCall_0_0_1 = (RuleCall)cNameTypeNameCrossReference_0_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExtesnionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExtesnionIDTerminalRuleCall_2_0 = (RuleCall)cExtesnionAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cBodyElementsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cBodyElementsTypeBodyElementsParserRuleCall_5_0 = (RuleCall)cBodyElementsAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		///* ------------------------ Extension statement ---------------------------- */ Extend:
		//	name=[TypeName] '(' extesnion=ID ')' '{' bodyElements+=TypeBodyElements* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//name=[TypeName] '(' extesnion=ID ')' '{' bodyElements+=TypeBodyElements* '}'
		public Group getGroup() { return cGroup; }
		
		//name=[TypeName]
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//[TypeName]
		public CrossReference getNameTypeNameCrossReference_0_0() { return cNameTypeNameCrossReference_0_0; }
		
		//ID
		public RuleCall getNameTypeNameIDTerminalRuleCall_0_0_1() { return cNameTypeNameIDTerminalRuleCall_0_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//extesnion=ID
		public Assignment getExtesnionAssignment_2() { return cExtesnionAssignment_2; }
		
		//ID
		public RuleCall getExtesnionIDTerminalRuleCall_2_0() { return cExtesnionIDTerminalRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//bodyElements+=TypeBodyElements*
		public Assignment getBodyElementsAssignment_5() { return cBodyElementsAssignment_5; }
		
		//TypeBodyElements
		public RuleCall getBodyElementsTypeBodyElementsParserRuleCall_5_0() { return cBodyElementsTypeBodyElementsParserRuleCall_5_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}
	public class TypeBodyElementsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TypeBodyElements");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cFunctionsAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cFunctionsFunctionDeclParserRuleCall_0_0 = (RuleCall)cFunctionsAssignment_0.eContents().get(0);
		private final Assignment cTheoremsAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cTheoremsTheoremBodyParserRuleCall_1_0 = (RuleCall)cTheoremsAssignment_1.eContents().get(0);
		
		///* ------------------------ TypeBodyElements ------------------------------- */ TypeBodyElements:
		//	functions+=FunctionDecl | theorems+=TheoremBody;
		@Override public ParserRule getRule() { return rule; }
		
		//functions+=FunctionDecl | theorems+=TheoremBody
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//functions+=FunctionDecl
		public Assignment getFunctionsAssignment_0() { return cFunctionsAssignment_0; }
		
		//FunctionDecl
		public RuleCall getFunctionsFunctionDeclParserRuleCall_0_0() { return cFunctionsFunctionDeclParserRuleCall_0_0; }
		
		//theorems+=TheoremBody
		public Assignment getTheoremsAssignment_1() { return cTheoremsAssignment_1; }
		
		//TheoremBody
		public RuleCall getTheoremsTheoremBodyParserRuleCall_1_0() { return cTheoremsTheoremBodyParserRuleCall_1_0; }
	}
	public class FunctionDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.FunctionDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameFunctionNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cContextAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cContextPolyContextParserRuleCall_1_0 = (RuleCall)cContextAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cVarListAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVarListTypedVariableListParserRuleCall_3_0 = (RuleCall)cVarListAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cColonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cReturnTypeAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cReturnTypeTypeConstructorParserRuleCall_6_0 = (RuleCall)cReturnTypeAssignment_6.eContents().get(0);
		private final Assignment cBodyAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cBodyFunctionBodyParserRuleCall_7_0 = (RuleCall)cBodyAssignment_7.eContents().get(0);
		
		///*------------------------- Functions --------------------------------- */ FunctionDecl:
		//	name+=FunctionName context=PolyContext? '(' varList=TypedVariableList? ')' ':' returnType=TypeConstructor
		//	body=FunctionBody;
		@Override public ParserRule getRule() { return rule; }
		
		//name+=FunctionName context=PolyContext? '(' varList=TypedVariableList? ')' ':' returnType=TypeConstructor
		//body=FunctionBody
		public Group getGroup() { return cGroup; }
		
		//name+=FunctionName
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//FunctionName
		public RuleCall getNameFunctionNameParserRuleCall_0_0() { return cNameFunctionNameParserRuleCall_0_0; }
		
		//context=PolyContext?
		public Assignment getContextAssignment_1() { return cContextAssignment_1; }
		
		//PolyContext
		public RuleCall getContextPolyContextParserRuleCall_1_0() { return cContextPolyContextParserRuleCall_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//varList=TypedVariableList?
		public Assignment getVarListAssignment_3() { return cVarListAssignment_3; }
		
		//TypedVariableList
		public RuleCall getVarListTypedVariableListParserRuleCall_3_0() { return cVarListTypedVariableListParserRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
		
		//':'
		public Keyword getColonKeyword_5() { return cColonKeyword_5; }
		
		//returnType=TypeConstructor
		public Assignment getReturnTypeAssignment_6() { return cReturnTypeAssignment_6; }
		
		//TypeConstructor
		public RuleCall getReturnTypeTypeConstructorParserRuleCall_6_0() { return cReturnTypeTypeConstructorParserRuleCall_6_0; }
		
		//body=FunctionBody
		public Assignment getBodyAssignment_7() { return cBodyAssignment_7; }
		
		//FunctionBody
		public RuleCall getBodyFunctionBodyParserRuleCall_7_0() { return cBodyFunctionBodyParserRuleCall_7_0; }
	}
	public class FunctionNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.FunctionName");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//FunctionName:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class FunctionBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.FunctionBody");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFuncInductiveParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFuncDirectDefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//FunctionBody:
		//	FuncInductive | FuncDirectDef;
		@Override public ParserRule getRule() { return rule; }
		
		//FuncInductive | FuncDirectDef
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//FuncInductive
		public RuleCall getFuncInductiveParserRuleCall_0() { return cFuncInductiveParserRuleCall_0; }
		
		//FuncDirectDef
		public RuleCall getFuncDirectDefParserRuleCall_1() { return cFuncDirectDefParserRuleCall_1; }
	}
	public class FuncDirectDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.FuncDirectDef");
		private final Assignment cExpressionAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_0 = (RuleCall)cExpressionAssignment.eContents().get(0);
		
		///* The expression will be type checked to make sure that it returns the expected type. The result of type checking
		// * will have three possible result. A negative result giving an error e.g., the type returned by the expression 
		// * cannot match the return type. An undetermined result, a proof obligation is generated so the user can prove
		// * demonstrate the expression returns the correct type. A positive result, the expected type is returned by the
		// * expression, and the user is not required to do anything. In the case of an intermediate result the type system
		// * assumes that the declaration is true, however, there will still be the unsatisfied proof obligation showing
		// * that the system is unproven */ FuncDirectDef:
		//	expression=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//expression=Expression
		public Assignment getExpressionAssignment() { return cExpressionAssignment; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_0() { return cExpressionExpressionParserRuleCall_0; }
	}
	public class FuncInductiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.FuncInductive");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMatchKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVariableNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cVariableNameTypedVariableCrossReference_1_0 = (CrossReference)cVariableNameAssignment_1.eContents().get(0);
		private final RuleCall cVariableNameTypedVariableIDTerminalRuleCall_1_0_1 = (RuleCall)cVariableNameTypedVariableCrossReference_1_0.eContents().get(1);
		private final Assignment cInductCaseAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cInductCaseFuncInductiveCaseParserRuleCall_2_0 = (RuleCall)cInductCaseAssignment_2.eContents().get(0);
		private final Assignment cInductCaseAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cInductCaseFuncInductiveCaseParserRuleCall_3_0 = (RuleCall)cInductCaseAssignment_3.eContents().get(0);
		
		//FuncInductive:
		//	'match' variableName=[TypedVariable] inductCase+=FuncInductiveCase inductCase+=FuncInductiveCase*;
		@Override public ParserRule getRule() { return rule; }
		
		//'match' variableName=[TypedVariable] inductCase+=FuncInductiveCase inductCase+=FuncInductiveCase*
		public Group getGroup() { return cGroup; }
		
		//'match'
		public Keyword getMatchKeyword_0() { return cMatchKeyword_0; }
		
		//variableName=[TypedVariable]
		public Assignment getVariableNameAssignment_1() { return cVariableNameAssignment_1; }
		
		//[TypedVariable]
		public CrossReference getVariableNameTypedVariableCrossReference_1_0() { return cVariableNameTypedVariableCrossReference_1_0; }
		
		//ID
		public RuleCall getVariableNameTypedVariableIDTerminalRuleCall_1_0_1() { return cVariableNameTypedVariableIDTerminalRuleCall_1_0_1; }
		
		//inductCase+=FuncInductiveCase
		public Assignment getInductCaseAssignment_2() { return cInductCaseAssignment_2; }
		
		//FuncInductiveCase
		public RuleCall getInductCaseFuncInductiveCaseParserRuleCall_2_0() { return cInductCaseFuncInductiveCaseParserRuleCall_2_0; }
		
		//inductCase+=FuncInductiveCase*
		public Assignment getInductCaseAssignment_3() { return cInductCaseAssignment_3; }
		
		//FuncInductiveCase
		public RuleCall getInductCaseFuncInductiveCaseParserRuleCall_3_0() { return cInductCaseFuncInductiveCaseParserRuleCall_3_0; }
	}
	public class FuncInductiveCaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.FuncInductiveCase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVerticalLineKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDeconNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cDeconNameDTypeConstructorCrossReference_1_0 = (CrossReference)cDeconNameAssignment_1.eContents().get(0);
		private final RuleCall cDeconNameDTypeConstructorIDTerminalRuleCall_1_0_1 = (RuleCall)cDeconNameDTypeConstructorCrossReference_1_0.eContents().get(1);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExpreAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpreExpressionParserRuleCall_3_0 = (RuleCall)cExpreAssignment_3.eContents().get(0);
		
		//FuncInductiveCase:
		//	'|' deconName=[DTypeConstructor] ':' expre=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//'|' deconName=[DTypeConstructor] ':' expre=Expression
		public Group getGroup() { return cGroup; }
		
		//'|'
		public Keyword getVerticalLineKeyword_0() { return cVerticalLineKeyword_0; }
		
		//deconName=[DTypeConstructor]
		public Assignment getDeconNameAssignment_1() { return cDeconNameAssignment_1; }
		
		//[DTypeConstructor]
		public CrossReference getDeconNameDTypeConstructorCrossReference_1_0() { return cDeconNameDTypeConstructorCrossReference_1_0; }
		
		//ID
		public RuleCall getDeconNameDTypeConstructorIDTerminalRuleCall_1_0_1() { return cDeconNameDTypeConstructorIDTerminalRuleCall_1_0_1; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//expre=Expression
		public Assignment getExpreAssignment_3() { return cExpreAssignment_3; }
		
		//Expression
		public RuleCall getExpreExpressionParserRuleCall_3_0() { return cExpreExpressionParserRuleCall_3_0; }
	}
	public class TheoremBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TheoremBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTheoremsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTheoremDeclAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTheoremDeclTheoremDeclParserRuleCall_2_0 = (RuleCall)cTheoremDeclAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		///* ----------------------------- Theorems -------------------------*/ TheoremBody:
		//	'Theorems' '{' theoremDecl+=TheoremDecl+ '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'Theorems' '{' theoremDecl+=TheoremDecl+ '}'
		public Group getGroup() { return cGroup; }
		
		//'Theorems'
		public Keyword getTheoremsKeyword_0() { return cTheoremsKeyword_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//theoremDecl+=TheoremDecl+
		public Assignment getTheoremDeclAssignment_2() { return cTheoremDeclAssignment_2; }
		
		//TheoremDecl
		public RuleCall getTheoremDeclTheoremDeclParserRuleCall_2_0() { return cTheoremDeclTheoremDeclParserRuleCall_2_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class TheoremDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TheoremDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cThmNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cThmNameTHM_NAMEParserRuleCall_0_0 = (RuleCall)cThmNameAssignment_0.eContents().get(0);
		private final Assignment cExpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpRootExpressionParserRuleCall_1_0 = (RuleCall)cExpAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		///* Type check that the expression is a predicate expression. */ TheoremDecl:
		//	thmName=THM_NAME exp=RootExpression ';';
		@Override public ParserRule getRule() { return rule; }
		
		//thmName=THM_NAME exp=RootExpression ';'
		public Group getGroup() { return cGroup; }
		
		//thmName=THM_NAME
		public Assignment getThmNameAssignment_0() { return cThmNameAssignment_0; }
		
		//THM_NAME
		public RuleCall getThmNameTHM_NAMEParserRuleCall_0_0() { return cThmNameTHM_NAMEParserRuleCall_0_0; }
		
		//exp=RootExpression
		public Assignment getExpAssignment_1() { return cExpAssignment_1; }
		
		//RootExpression
		public RuleCall getExpRootExpressionParserRuleCall_1_0() { return cExpRootExpressionParserRuleCall_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}
	public class TypedVariableListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TypedVariableList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVariablesOfTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVariablesOfTypeVariableTypingParserRuleCall_0_0 = (RuleCall)cVariablesOfTypeAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cVariablesOfTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cVariablesOfTypeVariableTypingParserRuleCall_1_1_0 = (RuleCall)cVariablesOfTypeAssignment_1_1.eContents().get(0);
		
		//TypedVariableList:
		//	variablesOfType+=VariableTyping (',' variablesOfType+=VariableTyping)*;
		@Override public ParserRule getRule() { return rule; }
		
		//variablesOfType+=VariableTyping (',' variablesOfType+=VariableTyping)*
		public Group getGroup() { return cGroup; }
		
		//variablesOfType+=VariableTyping
		public Assignment getVariablesOfTypeAssignment_0() { return cVariablesOfTypeAssignment_0; }
		
		//VariableTyping
		public RuleCall getVariablesOfTypeVariableTypingParserRuleCall_0_0() { return cVariablesOfTypeVariableTypingParserRuleCall_0_0; }
		
		//(',' variablesOfType+=VariableTyping)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//variablesOfType+=VariableTyping
		public Assignment getVariablesOfTypeAssignment_1_1() { return cVariablesOfTypeAssignment_1_1; }
		
		//VariableTyping
		public RuleCall getVariablesOfTypeVariableTypingParserRuleCall_1_1_0() { return cVariablesOfTypeVariableTypingParserRuleCall_1_1_0; }
	}
	public class VariableTypingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.VariableTyping");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeVarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeVarTypedVariableParserRuleCall_0_0 = (RuleCall)cTypeVarAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTypeVarAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypeVarTypedVariableParserRuleCall_1_1_0 = (RuleCall)cTypeVarAssignment_1_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeConstructedTypeParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		
		//VariableTyping:
		//	typeVar+=TypedVariable (',' typeVar+=TypedVariable)* ':' type=ConstructedType;
		@Override public ParserRule getRule() { return rule; }
		
		//typeVar+=TypedVariable (',' typeVar+=TypedVariable)* ':' type=ConstructedType
		public Group getGroup() { return cGroup; }
		
		//typeVar+=TypedVariable
		public Assignment getTypeVarAssignment_0() { return cTypeVarAssignment_0; }
		
		//TypedVariable
		public RuleCall getTypeVarTypedVariableParserRuleCall_0_0() { return cTypeVarTypedVariableParserRuleCall_0_0; }
		
		//(',' typeVar+=TypedVariable)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//typeVar+=TypedVariable
		public Assignment getTypeVarAssignment_1_1() { return cTypeVarAssignment_1_1; }
		
		//TypedVariable
		public RuleCall getTypeVarTypedVariableParserRuleCall_1_1_0() { return cTypeVarTypedVariableParserRuleCall_1_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//type=ConstructedType
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }
		
		//ConstructedType
		public RuleCall getTypeConstructedTypeParserRuleCall_3_0() { return cTypeConstructedTypeParserRuleCall_3_0; }
	}
	public class TypedVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TypedVariable");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//TypedVariable:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class TypeDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TypeDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeNameTypeNameCrossReference_0_0 = (CrossReference)cTypeNameAssignment_0.eContents().get(0);
		private final RuleCall cTypeNameTypeNameIDTerminalRuleCall_0_0_1 = (RuleCall)cTypeNameTypeNameCrossReference_0_0.eContents().get(1);
		private final Assignment cContextAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cContextTypeDeclContextParserRuleCall_1_0 = (RuleCall)cContextAssignment_1.eContents().get(0);
		
		//TypeDeclaration:
		//	TypeName=[TypeName] context=TypeDeclContext;
		@Override public ParserRule getRule() { return rule; }
		
		//TypeName=[TypeName] context=TypeDeclContext
		public Group getGroup() { return cGroup; }
		
		//TypeName=[TypeName]
		public Assignment getTypeNameAssignment_0() { return cTypeNameAssignment_0; }
		
		//[TypeName]
		public CrossReference getTypeNameTypeNameCrossReference_0_0() { return cTypeNameTypeNameCrossReference_0_0; }
		
		//ID
		public RuleCall getTypeNameTypeNameIDTerminalRuleCall_0_0_1() { return cTypeNameTypeNameIDTerminalRuleCall_0_0_1; }
		
		//context=TypeDeclContext
		public Assignment getContextAssignment_1() { return cContextAssignment_1; }
		
		//TypeDeclContext
		public RuleCall getContextTypeDeclContextParserRuleCall_1_0() { return cContextTypeDeclContextParserRuleCall_1_0; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Expression");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		///* --------------------------- Expressions -------------------------- */ Expression:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//// This needs to be written. Could be worth separating this out into another 
		//// dsl reducing the complexity of this section. Specifically I need to look out for
		//// the following expressions forall exists lambda function calls.
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class LambdaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Lambda");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGreekSmallLetterLamdaKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cContextAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cContextPolyContextParserRuleCall_1_0 = (RuleCall)cContextAssignment_1.eContents().get(0);
		private final Assignment cVarListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVarListTypedVariableListParserRuleCall_2_0 = (RuleCall)cVarListAssignment_2.eContents().get(0);
		private final Keyword cVerticalLineKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cExprAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cExprRootExpressionParserRuleCall_4_0 = (RuleCall)cExprAssignment_4.eContents().get(0);
		
		//Lambda:
		//	'λ' context=PolyContext? varList=TypedVariableList '|' expr=RootExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//'λ' context=PolyContext? varList=TypedVariableList '|' expr=RootExpression
		public Group getGroup() { return cGroup; }
		
		//'λ'
		public Keyword getGreekSmallLetterLamdaKeyword_0() { return cGreekSmallLetterLamdaKeyword_0; }
		
		//context=PolyContext?
		public Assignment getContextAssignment_1() { return cContextAssignment_1; }
		
		//PolyContext
		public RuleCall getContextPolyContextParserRuleCall_1_0() { return cContextPolyContextParserRuleCall_1_0; }
		
		//varList=TypedVariableList
		public Assignment getVarListAssignment_2() { return cVarListAssignment_2; }
		
		//TypedVariableList
		public RuleCall getVarListTypedVariableListParserRuleCall_2_0() { return cVarListTypedVariableListParserRuleCall_2_0; }
		
		//'|'
		public Keyword getVerticalLineKeyword_3() { return cVerticalLineKeyword_3; }
		
		//expr=RootExpression
		public Assignment getExprAssignment_4() { return cExprAssignment_4; }
		
		//RootExpression
		public RuleCall getExprRootExpressionParserRuleCall_4_0() { return cExprRootExpressionParserRuleCall_4_0; }
	}
	public class RootExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.RootExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLambdaParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cQuantifierParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cInfixParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		///* --------------------- Quantifiers ------------------------- */ RootExpression Expression:
		//	Lambda | Quantifier | Infix;
		@Override public ParserRule getRule() { return rule; }
		
		//Lambda | Quantifier | Infix
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Lambda
		public RuleCall getLambdaParserRuleCall_0() { return cLambdaParserRuleCall_0; }
		
		//Quantifier
		public RuleCall getQuantifierParserRuleCall_1() { return cQuantifierParserRuleCall_1; }
		
		//Infix
		public RuleCall getInfixParserRuleCall_2() { return cInfixParserRuleCall_2; }
	}
	public class QuantifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Quantifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cForAllKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cThereExistsKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Assignment cContextAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cContextPolyContextParserRuleCall_1_0 = (RuleCall)cContextAssignment_1.eContents().get(0);
		private final Assignment cVarListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVarListTypedVariableListParserRuleCall_2_0 = (RuleCall)cVarListAssignment_2.eContents().get(0);
		private final Keyword cMiddleDotKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cExprAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cExprRootExpressionParserRuleCall_4_0 = (RuleCall)cExprAssignment_4.eContents().get(0);
		
		//Quantifier:
		//	('∀' | '∃') context=PolyContext? varList=TypedVariableList '·' expr=RootExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//('∀' | '∃') context=PolyContext? varList=TypedVariableList '·' expr=RootExpression
		public Group getGroup() { return cGroup; }
		
		//'∀' | '∃'
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//'∀'
		public Keyword getForAllKeyword_0_0() { return cForAllKeyword_0_0; }
		
		//'∃'
		public Keyword getThereExistsKeyword_0_1() { return cThereExistsKeyword_0_1; }
		
		//context=PolyContext?
		public Assignment getContextAssignment_1() { return cContextAssignment_1; }
		
		//PolyContext
		public RuleCall getContextPolyContextParserRuleCall_1_0() { return cContextPolyContextParserRuleCall_1_0; }
		
		//varList=TypedVariableList
		public Assignment getVarListAssignment_2() { return cVarListAssignment_2; }
		
		//TypedVariableList
		public RuleCall getVarListTypedVariableListParserRuleCall_2_0() { return cVarListTypedVariableListParserRuleCall_2_0; }
		
		//'·'
		public Keyword getMiddleDotKeyword_3() { return cMiddleDotKeyword_3; }
		
		//expr=RootExpression
		public Assignment getExprAssignment_4() { return cExprAssignment_4; }
		
		//RootExpression
		public RuleCall getExprRootExpressionParserRuleCall_4_0() { return cExprRootExpressionParserRuleCall_4_0; }
	}
	public class PrefixElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Prefix");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNamePrefixBuiltInParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cElemAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cElemElementParserRuleCall_1_0 = (RuleCall)cElemAssignment_1.eContents().get(0);
		
		///* ---------------------- *Fix ------------------------------ */ Prefix:
		//	name=PrefixBuiltIn elem=Element;
		@Override public ParserRule getRule() { return rule; }
		
		//name=PrefixBuiltIn elem=Element
		public Group getGroup() { return cGroup; }
		
		//name=PrefixBuiltIn
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//PrefixBuiltIn
		public RuleCall getNamePrefixBuiltInParserRuleCall_0_0() { return cNamePrefixBuiltInParserRuleCall_0_0; }
		
		//elem=Element
		public Assignment getElemAssignment_1() { return cElemAssignment_1; }
		
		//Element
		public RuleCall getElemElementParserRuleCall_1_0() { return cElemElementParserRuleCall_1_0; }
	}
	public class PrefixBuiltInElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.PrefixBuiltIn");
		private final Keyword cNotSignKeyword = (Keyword)rule.eContents().get(1);
		
		//PrefixBuiltIn:
		//	'¬';
		@Override public ParserRule getRule() { return rule; }
		
		//'¬'
		public Keyword getNotSignKeyword() { return cNotSignKeyword; }
	}
	public class InfixElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Infix");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cElementParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cInfixLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Assignment cFuncNameAssignment_1_1_0 = (Assignment)cAlternatives_1_1.eContents().get(0);
		private final CrossReference cFuncNameFunctionNameCrossReference_1_1_0_0 = (CrossReference)cFuncNameAssignment_1_1_0.eContents().get(0);
		private final RuleCall cFuncNameFunctionNameIDTerminalRuleCall_1_1_0_0_1 = (RuleCall)cFuncNameFunctionNameCrossReference_1_1_0_0.eContents().get(1);
		private final Assignment cOpNameAssignment_1_1_1 = (Assignment)cAlternatives_1_1.eContents().get(1);
		private final RuleCall cOpNameInbuiltInfixParserRuleCall_1_1_1_0 = (RuleCall)cOpNameAssignment_1_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightElementParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		///* Infix operators cause problems, there are two issues one is avoiding left recursion this 
		// * is covered adequately here: https://www.eclipse.org/Xtext/documentation/307_special_languages.html#expressions 
		// * The second issue is precedence, this is also covered in the link above, however, implementing it in the 
		// * way suggested above will not scale to the creation of ones own infix functions, instead the initial implementation
		// * will require brackets for precedence. After that a system will be implemented where each infix operator will 
		// * be given a precedence value with higher values being higher precedence. It looks like this can be done by
		// * changing the parser using the MyDSLRuntimeModule to build the abstract syntax tree based on the value of the 
		// * operators.
		// * Before the precedence code is written into a parser override, all the expressions are in effect right bracketed,
		// * as you may expect from a language that is read from left to right.
		// * 
		// * TODO: Programmatically check that the function is an infix function.
		// */ Infix Expression:
		//	Element ({Infix.left=current} (funcName+=[FunctionName] | opName+=InbuiltInfix) right+=Element)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Element ({Infix.left=current} (funcName+=[FunctionName] | opName+=InbuiltInfix) right+=Element)*
		public Group getGroup() { return cGroup; }
		
		//Element
		public RuleCall getElementParserRuleCall_0() { return cElementParserRuleCall_0; }
		
		//({Infix.left=current} (funcName+=[FunctionName] | opName+=InbuiltInfix) right+=Element)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Infix.left=current}
		public Action getInfixLeftAction_1_0() { return cInfixLeftAction_1_0; }
		
		//funcName+=[FunctionName] | opName+=InbuiltInfix
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }
		
		//funcName+=[FunctionName]
		public Assignment getFuncNameAssignment_1_1_0() { return cFuncNameAssignment_1_1_0; }
		
		//[FunctionName]
		public CrossReference getFuncNameFunctionNameCrossReference_1_1_0_0() { return cFuncNameFunctionNameCrossReference_1_1_0_0; }
		
		//ID
		public RuleCall getFuncNameFunctionNameIDTerminalRuleCall_1_1_0_0_1() { return cFuncNameFunctionNameIDTerminalRuleCall_1_1_0_0_1; }
		
		//opName+=InbuiltInfix
		public Assignment getOpNameAssignment_1_1_1() { return cOpNameAssignment_1_1_1; }
		
		//InbuiltInfix
		public RuleCall getOpNameInbuiltInfixParserRuleCall_1_1_1_0() { return cOpNameInbuiltInfixParserRuleCall_1_1_1_0; }
		
		//right+=Element
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Element
		public RuleCall getRightElementParserRuleCall_1_2_0() { return cRightElementParserRuleCall_1_2_0; }
	}
	public class ElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Element");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBracketParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPrefixParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cFunctionCallParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		///* currently it will not build because the quantifier is causing recursion I think. 
		// * I think that we need a quantifier free expression to solve the problem Similar to the way
		// * precedence is handled here: https://typefox.io/parsing-expressions-with-xtext
		// */ Element Expression:
		//	Bracket | Prefix | FunctionCall;
		@Override public ParserRule getRule() { return rule; }
		
		//Bracket | Prefix | FunctionCall
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Bracket
		public RuleCall getBracketParserRuleCall_0() { return cBracketParserRuleCall_0; }
		
		//Prefix
		public RuleCall getPrefixParserRuleCall_1() { return cPrefixParserRuleCall_1; }
		
		//FunctionCall
		public RuleCall getFunctionCallParserRuleCall_2() { return cFunctionCallParserRuleCall_2; }
	}
	public class BracketElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Bracket");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cRootExpressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Bracket Expression:
		//	'(' RootExpression ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' RootExpression ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//RootExpression
		public RuleCall getRootExpressionParserRuleCall_1() { return cRootExpressionParserRuleCall_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class FunctionCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.FunctionCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeInstAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeInstTypeInstanceParserRuleCall_0_0 = (RuleCall)cTypeInstAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cArgumentsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cArgumentsInfixParserRuleCall_1_1_0 = (RuleCall)cArgumentsAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cCommaKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cArgumentsAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cArgumentsInfixParserRuleCall_1_2_1_0 = (RuleCall)cArgumentsAssignment_1_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		///* This produces an interesting issue in parsing the program because it is necessary to distinguish between the following three
		// * scenarios: 
		// * A function call f(arguments)
		// * A infix function with a bracketed argument on the right 10 f (arguments)
		// * A function used without any arguments f add g 
		// * 
		// * To solve this functions can either be Prefix, Infix, or called with bracketed arguments. You cannot call a Infix function with bracketd 
		// * arguments. To do this you would need to write another function to make this call for you. In coq this is achieved when you declare a function
		// * you can add a operator name to the function, which is either infix or prefix, this again gives the two names for the function allowing 
		// * it to be called either as an operator or a functional call.
		// * 
		// * This expressions needs a lot of programmatic checking! Starting with the count of the arguments, followed by type checking the arguments.
		// */ FunctionCall Expression:
		//	typeInst=TypeInstance ('(' arguments+=Infix? (',' arguments+=Infix)* ')')?;
		@Override public ParserRule getRule() { return rule; }
		
		//typeInst=TypeInstance ('(' arguments+=Infix? (',' arguments+=Infix)* ')')?
		public Group getGroup() { return cGroup; }
		
		//typeInst=TypeInstance
		public Assignment getTypeInstAssignment_0() { return cTypeInstAssignment_0; }
		
		//TypeInstance
		public RuleCall getTypeInstTypeInstanceParserRuleCall_0_0() { return cTypeInstTypeInstanceParserRuleCall_0_0; }
		
		//('(' arguments+=Infix? (',' arguments+=Infix)* ')')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//arguments+=Infix?
		public Assignment getArgumentsAssignment_1_1() { return cArgumentsAssignment_1_1; }
		
		//Infix
		public RuleCall getArgumentsInfixParserRuleCall_1_1_0() { return cArgumentsInfixParserRuleCall_1_1_0; }
		
		//(',' arguments+=Infix)*
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//','
		public Keyword getCommaKeyword_1_2_0() { return cCommaKeyword_1_2_0; }
		
		//arguments+=Infix
		public Assignment getArgumentsAssignment_1_2_1() { return cArgumentsAssignment_1_2_1; }
		
		//Infix
		public RuleCall getArgumentsInfixParserRuleCall_1_2_1_0() { return cArgumentsInfixParserRuleCall_1_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}
	public class ExpressionTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.ExpressionType");
		private final RuleCall cTypeNameParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//ExpressionType:
		//	TypeName;
		@Override public ParserRule getRule() { return rule; }
		
		//TypeName
		public RuleCall getTypeNameParserRuleCall() { return cTypeNameParserRuleCall; }
	}
	public class ExpressionVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.ExpressionVariable");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFunctionNameParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypedVariableParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cExpressionTypeParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//ExpressionVariable:
		//	FunctionName | TypedVariable | ExpressionType;
		@Override public ParserRule getRule() { return rule; }
		
		//FunctionName | TypedVariable | ExpressionType
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//FunctionName
		public RuleCall getFunctionNameParserRuleCall_0() { return cFunctionNameParserRuleCall_0; }
		
		//TypedVariable
		public RuleCall getTypedVariableParserRuleCall_1() { return cTypedVariableParserRuleCall_1; }
		
		//ExpressionType
		public RuleCall getExpressionTypeParserRuleCall_2() { return cExpressionTypeParserRuleCall_2; }
	}
	public class TypeInstanceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.TypeInstance");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cInstanceAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final CrossReference cInstanceExpressionVariableCrossReference_0_0 = (CrossReference)cInstanceAssignment_0.eContents().get(0);
		private final RuleCall cInstanceExpressionVariableIDTerminalRuleCall_0_0_1 = (RuleCall)cInstanceExpressionVariableCrossReference_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cTypeNameAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final CrossReference cTypeNameGenNameCrossReference_1_0_0 = (CrossReference)cTypeNameAssignment_1_0.eContents().get(0);
		private final RuleCall cTypeNameGenNameIDTerminalRuleCall_1_0_0_1 = (RuleCall)cTypeNameGenNameCrossReference_1_0_0.eContents().get(1);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cFullStopKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cElementAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final CrossReference cElementTypedVariableCrossReference_1_1_1_0 = (CrossReference)cElementAssignment_1_1_1.eContents().get(0);
		private final RuleCall cElementTypedVariableIDTerminalRuleCall_1_1_1_0_1 = (RuleCall)cElementTypedVariableCrossReference_1_1_1_0.eContents().get(1);
		
		///* With Parametric polymorphism classes e.g., Class ReflexRel<T> : T × T → Pred we can use ReflexRel directly 
		// * within an expression as it is the ReflexRel operator. However, with similar type class declarations:
		// * Class Group : Monoid where ... Does it make sense to be able to be able to use Group directly? it 
		// * refers to the whole type. I think that I'm conceptually ok to treat Group or ReflexRel as a polymorphic
		// * instance of the super type, and later treat it more like a set, It strikes me that this is a concept 
		// * already familiar to Generics where we're reasoning using a generic type (which is in a sense a subtype of
		// * its own.
		// * 
		// * The below statement needs scoping all polymorphic types have to be locally declared.
		// */ TypeInstance:
		//	instance=[ExpressionVariable] | typeName=[GenName] ('.' element+=[TypedVariable])+;
		@Override public ParserRule getRule() { return rule; }
		
		//instance=[ExpressionVariable] | typeName=[GenName] ('.' element+=[TypedVariable])+
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//instance=[ExpressionVariable]
		public Assignment getInstanceAssignment_0() { return cInstanceAssignment_0; }
		
		//[ExpressionVariable]
		public CrossReference getInstanceExpressionVariableCrossReference_0_0() { return cInstanceExpressionVariableCrossReference_0_0; }
		
		//ID
		public RuleCall getInstanceExpressionVariableIDTerminalRuleCall_0_0_1() { return cInstanceExpressionVariableIDTerminalRuleCall_0_0_1; }
		
		//typeName=[GenName] ('.' element+=[TypedVariable])+
		public Group getGroup_1() { return cGroup_1; }
		
		//typeName=[GenName]
		public Assignment getTypeNameAssignment_1_0() { return cTypeNameAssignment_1_0; }
		
		//[GenName]
		public CrossReference getTypeNameGenNameCrossReference_1_0_0() { return cTypeNameGenNameCrossReference_1_0_0; }
		
		//ID
		public RuleCall getTypeNameGenNameIDTerminalRuleCall_1_0_0_1() { return cTypeNameGenNameIDTerminalRuleCall_1_0_0_1; }
		
		//('.' element+=[TypedVariable])+
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1_1_0() { return cFullStopKeyword_1_1_0; }
		
		//element+=[TypedVariable]
		public Assignment getElementAssignment_1_1_1() { return cElementAssignment_1_1_1; }
		
		//[TypedVariable]
		public CrossReference getElementTypedVariableCrossReference_1_1_1_0() { return cElementTypedVariableCrossReference_1_1_1_0; }
		
		//ID
		public RuleCall getElementTypedVariableIDTerminalRuleCall_1_1_1_0_1() { return cElementTypedVariableIDTerminalRuleCall_1_1_1_0_1; }
	}
	public class InbuiltInfixElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.InbuiltInfix");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLeftRightDoubleArrowKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cRightwardsDoubleArrowKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cNotEqualToKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cLogicalAndKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cLogicalOrKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		
		//InbuiltInfix:
		//	'⇔' | '⇒' | '=' | '≠' | '∧' | '∨';
		@Override public ParserRule getRule() { return rule; }
		
		//'⇔' | '⇒' | '=' | '≠' | '∧' | '∨'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'⇔'
		public Keyword getLeftRightDoubleArrowKeyword_0() { return cLeftRightDoubleArrowKeyword_0; }
		
		//'⇒'
		public Keyword getRightwardsDoubleArrowKeyword_1() { return cRightwardsDoubleArrowKeyword_1; }
		
		//'='
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }
		
		//'≠'
		public Keyword getNotEqualToKeyword_3() { return cNotEqualToKeyword_3; }
		
		//'∧'
		public Keyword getLogicalAndKeyword_4() { return cLogicalAndKeyword_4; }
		
		//'∨'
		public Keyword getLogicalOrKeyword_5() { return cLogicalOrKeyword_5; }
	}
	public class InbuiltTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.InbuiltType");
		private final Keyword cPredKeyword = (Keyword)rule.eContents().get(1);
		
		///* Consider whether to add other inbuilt types such as Integers etc. Given the lack of 
		// * recursion in the inbuilt types it may be better to  */ InbuiltType:
		//	'Pred';
		@Override public ParserRule getRule() { return rule; }
		
		//'Pred'
		public Keyword getPredKeyword() { return cPredKeyword; }
	}
	public class InbuiltTypeScanElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.InbuiltTypeScan");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameInbuiltTypeParserRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//InbuiltTypeScan:
		//	name=InbuiltType;
		@Override public ParserRule getRule() { return rule; }
		
		//name=InbuiltType
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//InbuiltType
		public RuleCall getNameInbuiltTypeParserRuleCall_0() { return cNameInbuiltTypeParserRuleCall_0; }
	}
	public class InstanceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.sampleProj.mydsl.MyDsl.Instance");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cInstanceKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cClassNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cClassNameTypeNameCrossReference_1_0 = (CrossReference)cClassNameAssignment_1.eContents().get(0);
		private final RuleCall cClassNameTypeNameIDTerminalRuleCall_1_0_1 = (RuleCall)cClassNameTypeNameCrossReference_1_0.eContents().get(1);
		private final Assignment cContextAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cContextTypeDeclContextParserRuleCall_2_0 = (RuleCall)cContextAssignment_2.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cArgumentsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cArgumentsInfixParserRuleCall_4_0 = (RuleCall)cArgumentsAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cCommaKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cArgumentsAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cArgumentsInfixParserRuleCall_5_1_0 = (RuleCall)cArgumentsAssignment_5_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		///* I feel like I should need these, however, I'm not sure when they would be necessary. */ //InbuiltTypeInstance:
		////	'⊤' | '⊥'
		////;
		////
		////InbuiltTypeInstanceScan:
		////	name=InbuiltTypeInstance
		////;
		///* ------------------------------ Instance ---------------------------------------------*/ Instance:
		//	'Instance' className=[TypeName] context=TypeDeclContext '(' arguments+=Infix? (',' arguments+=Infix)* ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'Instance' className=[TypeName] context=TypeDeclContext '(' arguments+=Infix? (',' arguments+=Infix)* ')'
		public Group getGroup() { return cGroup; }
		
		//'Instance'
		public Keyword getInstanceKeyword_0() { return cInstanceKeyword_0; }
		
		//className=[TypeName]
		public Assignment getClassNameAssignment_1() { return cClassNameAssignment_1; }
		
		//[TypeName]
		public CrossReference getClassNameTypeNameCrossReference_1_0() { return cClassNameTypeNameCrossReference_1_0; }
		
		//ID
		public RuleCall getClassNameTypeNameIDTerminalRuleCall_1_0_1() { return cClassNameTypeNameIDTerminalRuleCall_1_0_1; }
		
		//context=TypeDeclContext
		public Assignment getContextAssignment_2() { return cContextAssignment_2; }
		
		//TypeDeclContext
		public RuleCall getContextTypeDeclContextParserRuleCall_2_0() { return cContextTypeDeclContextParserRuleCall_2_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }
		
		//arguments+=Infix?
		public Assignment getArgumentsAssignment_4() { return cArgumentsAssignment_4; }
		
		//Infix
		public RuleCall getArgumentsInfixParserRuleCall_4_0() { return cArgumentsInfixParserRuleCall_4_0; }
		
		//(',' arguments+=Infix)*
		public Group getGroup_5() { return cGroup_5; }
		
		//','
		public Keyword getCommaKeyword_5_0() { return cCommaKeyword_5_0; }
		
		//arguments+=Infix
		public Assignment getArgumentsAssignment_5_1() { return cArgumentsAssignment_5_1; }
		
		//Infix
		public RuleCall getArgumentsInfixParserRuleCall_5_1_0() { return cArgumentsInfixParserRuleCall_5_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }
	}
	
	
	private final DomainModelElements pDomainModel;
	private final THM_NAMEElements pTHM_NAME;
	private final TopLevelElements pTopLevel;
	private final ImportStatementElements pImportStatement;
	private final ImportElements pImport;
	private final ImportComponentElements pImportComponent;
	private final ClassDeclElements pClassDecl;
	private final ClassElements pClass;
	private final GenNameElements pGenName;
	private final TypeNameElements pTypeName;
	private final PolymorphicTypeNameElements pPolymorphicTypeName;
	private final PolyContextElements pPolyContext;
	private final PolyContextTypesElements pPolyContextTypes;
	private final PolyTypeConstraintsElements pPolyTypeConstraints;
	private final SuperTypeListElements pSuperTypeList;
	private final ConstructedTypeElements pConstructedType;
	private final TypeConstructorElements pTypeConstructor;
	private final TypeDeclContextElements pTypeDeclContext;
	private final TypeStructureElements pTypeStructure;
	private final WhereElements pWhere;
	private final DatatypeElements pDatatype;
	private final DatatypeConstructorElements pDatatypeConstructor;
	private final BaseConstructorElements pBaseConstructor;
	private final DTypeConstructorElements pDTypeConstructor;
	private final ExtendElements pExtend;
	private final TypeBodyElementsElements pTypeBodyElements;
	private final FunctionDeclElements pFunctionDecl;
	private final FunctionNameElements pFunctionName;
	private final FunctionBodyElements pFunctionBody;
	private final FuncDirectDefElements pFuncDirectDef;
	private final FuncInductiveElements pFuncInductive;
	private final FuncInductiveCaseElements pFuncInductiveCase;
	private final TheoremBodyElements pTheoremBody;
	private final TheoremDeclElements pTheoremDecl;
	private final TypedVariableListElements pTypedVariableList;
	private final VariableTypingElements pVariableTyping;
	private final TypedVariableElements pTypedVariable;
	private final TypeDeclarationElements pTypeDeclaration;
	private final ExpressionElements pExpression;
	private final LambdaElements pLambda;
	private final RootExpressionElements pRootExpression;
	private final QuantifierElements pQuantifier;
	private final PrefixElements pPrefix;
	private final PrefixBuiltInElements pPrefixBuiltIn;
	private final InfixElements pInfix;
	private final ElementElements pElement;
	private final BracketElements pBracket;
	private final FunctionCallElements pFunctionCall;
	private final ExpressionTypeElements pExpressionType;
	private final ExpressionVariableElements pExpressionVariable;
	private final TypeInstanceElements pTypeInstance;
	private final InbuiltInfixElements pInbuiltInfix;
	private final InbuiltTypeElements pInbuiltType;
	private final InbuiltTypeScanElements pInbuiltTypeScan;
	private final InstanceElements pInstance;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public MyDslGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pDomainModel = new DomainModelElements();
		this.pTHM_NAME = new THM_NAMEElements();
		this.pTopLevel = new TopLevelElements();
		this.pImportStatement = new ImportStatementElements();
		this.pImport = new ImportElements();
		this.pImportComponent = new ImportComponentElements();
		this.pClassDecl = new ClassDeclElements();
		this.pClass = new ClassElements();
		this.pGenName = new GenNameElements();
		this.pTypeName = new TypeNameElements();
		this.pPolymorphicTypeName = new PolymorphicTypeNameElements();
		this.pPolyContext = new PolyContextElements();
		this.pPolyContextTypes = new PolyContextTypesElements();
		this.pPolyTypeConstraints = new PolyTypeConstraintsElements();
		this.pSuperTypeList = new SuperTypeListElements();
		this.pConstructedType = new ConstructedTypeElements();
		this.pTypeConstructor = new TypeConstructorElements();
		this.pTypeDeclContext = new TypeDeclContextElements();
		this.pTypeStructure = new TypeStructureElements();
		this.pWhere = new WhereElements();
		this.pDatatype = new DatatypeElements();
		this.pDatatypeConstructor = new DatatypeConstructorElements();
		this.pBaseConstructor = new BaseConstructorElements();
		this.pDTypeConstructor = new DTypeConstructorElements();
		this.pExtend = new ExtendElements();
		this.pTypeBodyElements = new TypeBodyElementsElements();
		this.pFunctionDecl = new FunctionDeclElements();
		this.pFunctionName = new FunctionNameElements();
		this.pFunctionBody = new FunctionBodyElements();
		this.pFuncDirectDef = new FuncDirectDefElements();
		this.pFuncInductive = new FuncInductiveElements();
		this.pFuncInductiveCase = new FuncInductiveCaseElements();
		this.pTheoremBody = new TheoremBodyElements();
		this.pTheoremDecl = new TheoremDeclElements();
		this.pTypedVariableList = new TypedVariableListElements();
		this.pVariableTyping = new VariableTypingElements();
		this.pTypedVariable = new TypedVariableElements();
		this.pTypeDeclaration = new TypeDeclarationElements();
		this.pExpression = new ExpressionElements();
		this.pLambda = new LambdaElements();
		this.pRootExpression = new RootExpressionElements();
		this.pQuantifier = new QuantifierElements();
		this.pPrefix = new PrefixElements();
		this.pPrefixBuiltIn = new PrefixBuiltInElements();
		this.pInfix = new InfixElements();
		this.pElement = new ElementElements();
		this.pBracket = new BracketElements();
		this.pFunctionCall = new FunctionCallElements();
		this.pExpressionType = new ExpressionTypeElements();
		this.pExpressionVariable = new ExpressionVariableElements();
		this.pTypeInstance = new TypeInstanceElements();
		this.pInbuiltInfix = new InbuiltInfixElements();
		this.pInbuiltType = new InbuiltTypeElements();
		this.pInbuiltTypeScan = new InbuiltTypeScanElements();
		this.pInstance = new InstanceElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.sampleProj.mydsl.MyDsl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//DomainModel:
	//	elements+=TopLevel*;
	public DomainModelElements getDomainModelAccess() {
		return pDomainModel;
	}
	
	public ParserRule getDomainModelRule() {
		return getDomainModelAccess().getRule();
	}
	
	//// Theorem names can include white space. Work out how to change this to any string without a ':'
	//THM_NAME:
	//	(INT | ID | WS)* ":";
	public THM_NAMEElements getTHM_NAMEAccess() {
		return pTHM_NAME;
	}
	
	public ParserRule getTHM_NAMERule() {
		return getTHM_NAMEAccess().getRule();
	}
	
	//TopLevel:
	//	ImportStatement | ClassDecl | Instance;
	public TopLevelElements getTopLevelAccess() {
		return pTopLevel;
	}
	
	public ParserRule getTopLevelRule() {
		return getTopLevelAccess().getRule();
	}
	
	//ImportStatement:
	//	'Import'
	//	imports+=Import;
	public ImportStatementElements getImportStatementAccess() {
		return pImportStatement;
	}
	
	public ParserRule getImportStatementRule() {
		return getImportStatementAccess().getRule();
	}
	
	//Import:
	//	importName+=ImportComponent ('.' importName+=ImportComponent);
	public ImportElements getImportAccess() {
		return pImport;
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}
	
	//ImportComponent:
	//	name=ID;
	public ImportComponentElements getImportComponentAccess() {
		return pImportComponent;
	}
	
	public ParserRule getImportComponentRule() {
		return getImportComponentAccess().getRule();
	}
	
	//ClassDecl:
	//	Class | Datatype | Extend;
	public ClassDeclElements getClassDeclAccess() {
		return pClassDecl;
	}
	
	public ParserRule getClassDeclRule() {
		return getClassDeclAccess().getRule();
	}
	
	///* ------------------------ Class statements --------------------- */ Class BppClass:
	//	'Class' TypeName=TypeName context=PolyContext? supertypes=SuperTypeList? varList=TypeStructure? where=Where? ';'?
	//	'{' bodyElements+=TypeBodyElements* '}';
	public ClassElements getClassAccess() {
		return pClass;
	}
	
	public ParserRule getClassRule() {
		return getClassAccess().getRule();
	}
	
	//GenName:
	//	PolymorphicTypeName | TypeName;
	public GenNameElements getGenNameAccess() {
		return pGenName;
	}
	
	public ParserRule getGenNameRule() {
		return getGenNameAccess().getRule();
	}
	
	//TypeName:
	//	name=ID;
	public TypeNameElements getTypeNameAccess() {
		return pTypeName;
	}
	
	public ParserRule getTypeNameRule() {
		return getTypeNameAccess().getRule();
	}
	
	///*---------------- Polymorphic Context of -------------------------- */ PolymorphicTypeName:
	//	name=ID;
	public PolymorphicTypeNameElements getPolymorphicTypeNameAccess() {
		return pPolymorphicTypeName;
	}
	
	public ParserRule getPolymorphicTypeNameRule() {
		return getPolymorphicTypeNameAccess().getRule();
	}
	
	//PolyContext:
	//	'<' polyTypes+=PolyContextTypes+ '>';
	public PolyContextElements getPolyContextAccess() {
		return pPolyContext;
	}
	
	public ParserRule getPolyContextRule() {
		return getPolyContextAccess().getRule();
	}
	
	//PolyContextTypes:
	//	name=PolymorphicTypeName constraints+=PolyTypeConstraints*;
	public PolyContextTypesElements getPolyContextTypesAccess() {
		return pPolyContextTypes;
	}
	
	public ParserRule getPolyContextTypesRule() {
		return getPolyContextTypesAccess().getRule();
	}
	
	//PolyTypeConstraints:
	//	':' TypeName+=[TypeName] (',' TypeName+=[TypeName])*;
	public PolyTypeConstraintsElements getPolyTypeConstraintsAccess() {
		return pPolyTypeConstraints;
	}
	
	public ParserRule getPolyTypeConstraintsRule() {
		return getPolyTypeConstraintsAccess().getRule();
	}
	
	///* ------------------- SuperTypes ---------------------------------- */ /* Any constriction on the polymorphic context has to be done by declaring the polymorphic context
	// * on the new type. If necessary the polymorphic context can be used within type constructors. In the simple case 
	// * this will be inferred . Required thought on checking the base types of the super types. At some points these
	// * need to be identical declarations. It is also necessary to allow EventB style type constructors at this
	// * point. e.g., an associative operator is a subtype of a closed Event-B total function.
	// */ SuperTypeList:
	//	':' superType+=ConstructedType (',' superType+=ConstructedType)*;
	public SuperTypeListElements getSuperTypeListAccess() {
		return pSuperTypeList;
	}
	
	public ParserRule getSuperTypeListRule() {
		return getSuperTypeListAccess().getRule();
	}
	
	///* Along with the normal Event-B type operator, and new B++ types the  */ ConstructedType:
	//	type+=TypeConstructor (('×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠') type+=ConstructedType)?;
	public ConstructedTypeElements getConstructedTypeAccess() {
		return pConstructedType;
	}
	
	public ParserRule getConstructedTypeRule() {
		return getConstructedTypeAccess().getRule();
	}
	
	///* Type constructor has validation rules to check that there is no context when there is a polymorphic name, 
	// * and type checking on the polymorphic context. There is also  scope rule to check the usage of polymorphic types.
	// * Probably need to add the predicate type to this.
	// */ TypeConstructor:
	//	(TypeName=[GenName] | InbuiltTypeScan) context+=TypeDeclContext?;
	public TypeConstructorElements getTypeConstructorAccess() {
		return pTypeConstructor;
	}
	
	public ParserRule getTypeConstructorRule() {
		return getTypeConstructorAccess().getRule();
	}
	
	//TypeDeclContext:
	//	'<' TypeName+=ConstructedType (',' TypeName+=ConstructedType)* '>';
	public TypeDeclContextElements getTypeDeclContextAccess() {
		return pTypeDeclContext;
	}
	
	public ParserRule getTypeDeclContextRule() {
		return getTypeDeclContextAccess().getRule();
	}
	
	///* -------------------- Type Structure ---------------------------------- */ TypeStructure:
	//	'(' variables=TypedVariableList ')';
	public TypeStructureElements getTypeStructureAccess() {
		return pTypeStructure;
	}
	
	public ParserRule getTypeStructureRule() {
		return getTypeStructureAccess().getRule();
	}
	
	///* -------------------- Where Statement -------------------------------- */ /* Type checking (which is not implemented yet) is used to type check that Expression returns a 
	// * predicate. Expression has not yet been written, but is far too general to be included in the where
	// * statement.
	// */ Where:
	//	'where' expessions+=Quantifier (';' expressions+=RootExpression)*;
	public WhereElements getWhereAccess() {
		return pWhere;
	}
	
	public ParserRule getWhereRule() {
		return getWhereAccess().getRule();
	}
	
	///* ---------------------- Datatype declarations -------------------------- */ Datatype:
	//	'Datatype' name=TypeName context=PolyContext? constructors+=DatatypeConstructor* '{' bodyElements+=TypeBodyElements*
	//	'}';
	public DatatypeElements getDatatypeAccess() {
		return pDatatype;
	}
	
	public ParserRule getDatatypeRule() {
		return getDatatypeAccess().getRule();
	}
	
	///* PolyContext is the same as PolyContext used by the class declaration above. */ DatatypeConstructor:
	//	'|' (BaseConstructor | DTypeConstructor);
	public DatatypeConstructorElements getDatatypeConstructorAccess() {
		return pDatatypeConstructor;
	}
	
	public ParserRule getDatatypeConstructorRule() {
		return getDatatypeConstructorAccess().getRule();
	}
	
	//BaseConstructor:
	//	name=ID;
	public BaseConstructorElements getBaseConstructorAccess() {
		return pBaseConstructor;
	}
	
	public ParserRule getBaseConstructorRule() {
		return getBaseConstructorAccess().getRule();
	}
	
	///* Typed Variable list is declared below, it is used in several situations such as functions/lambdas
	// * not just in Datatypes.
	// */ DTypeConstructor:
	//	name=ID '(' decons=TypedVariableList ')';
	public DTypeConstructorElements getDTypeConstructorAccess() {
		return pDTypeConstructor;
	}
	
	public ParserRule getDTypeConstructorRule() {
		return getDTypeConstructorAccess().getRule();
	}
	
	///* ------------------------ Extension statement ---------------------------- */ Extend:
	//	name=[TypeName] '(' extesnion=ID ')' '{' bodyElements+=TypeBodyElements* '}';
	public ExtendElements getExtendAccess() {
		return pExtend;
	}
	
	public ParserRule getExtendRule() {
		return getExtendAccess().getRule();
	}
	
	///* ------------------------ TypeBodyElements ------------------------------- */ TypeBodyElements:
	//	functions+=FunctionDecl | theorems+=TheoremBody;
	public TypeBodyElementsElements getTypeBodyElementsAccess() {
		return pTypeBodyElements;
	}
	
	public ParserRule getTypeBodyElementsRule() {
		return getTypeBodyElementsAccess().getRule();
	}
	
	///*------------------------- Functions --------------------------------- */ FunctionDecl:
	//	name+=FunctionName context=PolyContext? '(' varList=TypedVariableList? ')' ':' returnType=TypeConstructor
	//	body=FunctionBody;
	public FunctionDeclElements getFunctionDeclAccess() {
		return pFunctionDecl;
	}
	
	public ParserRule getFunctionDeclRule() {
		return getFunctionDeclAccess().getRule();
	}
	
	//FunctionName:
	//	name=ID;
	public FunctionNameElements getFunctionNameAccess() {
		return pFunctionName;
	}
	
	public ParserRule getFunctionNameRule() {
		return getFunctionNameAccess().getRule();
	}
	
	//FunctionBody:
	//	FuncInductive | FuncDirectDef;
	public FunctionBodyElements getFunctionBodyAccess() {
		return pFunctionBody;
	}
	
	public ParserRule getFunctionBodyRule() {
		return getFunctionBodyAccess().getRule();
	}
	
	///* The expression will be type checked to make sure that it returns the expected type. The result of type checking
	// * will have three possible result. A negative result giving an error e.g., the type returned by the expression 
	// * cannot match the return type. An undetermined result, a proof obligation is generated so the user can prove
	// * demonstrate the expression returns the correct type. A positive result, the expected type is returned by the
	// * expression, and the user is not required to do anything. In the case of an intermediate result the type system
	// * assumes that the declaration is true, however, there will still be the unsatisfied proof obligation showing
	// * that the system is unproven */ FuncDirectDef:
	//	expression=Expression;
	public FuncDirectDefElements getFuncDirectDefAccess() {
		return pFuncDirectDef;
	}
	
	public ParserRule getFuncDirectDefRule() {
		return getFuncDirectDefAccess().getRule();
	}
	
	//FuncInductive:
	//	'match' variableName=[TypedVariable] inductCase+=FuncInductiveCase inductCase+=FuncInductiveCase*;
	public FuncInductiveElements getFuncInductiveAccess() {
		return pFuncInductive;
	}
	
	public ParserRule getFuncInductiveRule() {
		return getFuncInductiveAccess().getRule();
	}
	
	//FuncInductiveCase:
	//	'|' deconName=[DTypeConstructor] ':' expre=Expression;
	public FuncInductiveCaseElements getFuncInductiveCaseAccess() {
		return pFuncInductiveCase;
	}
	
	public ParserRule getFuncInductiveCaseRule() {
		return getFuncInductiveCaseAccess().getRule();
	}
	
	///* ----------------------------- Theorems -------------------------*/ TheoremBody:
	//	'Theorems' '{' theoremDecl+=TheoremDecl+ '}';
	public TheoremBodyElements getTheoremBodyAccess() {
		return pTheoremBody;
	}
	
	public ParserRule getTheoremBodyRule() {
		return getTheoremBodyAccess().getRule();
	}
	
	///* Type check that the expression is a predicate expression. */ TheoremDecl:
	//	thmName=THM_NAME exp=RootExpression ';';
	public TheoremDeclElements getTheoremDeclAccess() {
		return pTheoremDecl;
	}
	
	public ParserRule getTheoremDeclRule() {
		return getTheoremDeclAccess().getRule();
	}
	
	//TypedVariableList:
	//	variablesOfType+=VariableTyping (',' variablesOfType+=VariableTyping)*;
	public TypedVariableListElements getTypedVariableListAccess() {
		return pTypedVariableList;
	}
	
	public ParserRule getTypedVariableListRule() {
		return getTypedVariableListAccess().getRule();
	}
	
	//VariableTyping:
	//	typeVar+=TypedVariable (',' typeVar+=TypedVariable)* ':' type=ConstructedType;
	public VariableTypingElements getVariableTypingAccess() {
		return pVariableTyping;
	}
	
	public ParserRule getVariableTypingRule() {
		return getVariableTypingAccess().getRule();
	}
	
	//TypedVariable:
	//	name=ID;
	public TypedVariableElements getTypedVariableAccess() {
		return pTypedVariable;
	}
	
	public ParserRule getTypedVariableRule() {
		return getTypedVariableAccess().getRule();
	}
	
	//TypeDeclaration:
	//	TypeName=[TypeName] context=TypeDeclContext;
	public TypeDeclarationElements getTypeDeclarationAccess() {
		return pTypeDeclaration;
	}
	
	public ParserRule getTypeDeclarationRule() {
		return getTypeDeclarationAccess().getRule();
	}
	
	///* --------------------------- Expressions -------------------------- */ Expression:
	//	name=ID;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//Lambda:
	//	'λ' context=PolyContext? varList=TypedVariableList '|' expr=RootExpression;
	public LambdaElements getLambdaAccess() {
		return pLambda;
	}
	
	public ParserRule getLambdaRule() {
		return getLambdaAccess().getRule();
	}
	
	///* --------------------- Quantifiers ------------------------- */ RootExpression Expression:
	//	Lambda | Quantifier | Infix;
	public RootExpressionElements getRootExpressionAccess() {
		return pRootExpression;
	}
	
	public ParserRule getRootExpressionRule() {
		return getRootExpressionAccess().getRule();
	}
	
	//Quantifier:
	//	('∀' | '∃') context=PolyContext? varList=TypedVariableList '·' expr=RootExpression;
	public QuantifierElements getQuantifierAccess() {
		return pQuantifier;
	}
	
	public ParserRule getQuantifierRule() {
		return getQuantifierAccess().getRule();
	}
	
	///* ---------------------- *Fix ------------------------------ */ Prefix:
	//	name=PrefixBuiltIn elem=Element;
	public PrefixElements getPrefixAccess() {
		return pPrefix;
	}
	
	public ParserRule getPrefixRule() {
		return getPrefixAccess().getRule();
	}
	
	//PrefixBuiltIn:
	//	'¬';
	public PrefixBuiltInElements getPrefixBuiltInAccess() {
		return pPrefixBuiltIn;
	}
	
	public ParserRule getPrefixBuiltInRule() {
		return getPrefixBuiltInAccess().getRule();
	}
	
	///* Infix operators cause problems, there are two issues one is avoiding left recursion this 
	// * is covered adequately here: https://www.eclipse.org/Xtext/documentation/307_special_languages.html#expressions 
	// * The second issue is precedence, this is also covered in the link above, however, implementing it in the 
	// * way suggested above will not scale to the creation of ones own infix functions, instead the initial implementation
	// * will require brackets for precedence. After that a system will be implemented where each infix operator will 
	// * be given a precedence value with higher values being higher precedence. It looks like this can be done by
	// * changing the parser using the MyDSLRuntimeModule to build the abstract syntax tree based on the value of the 
	// * operators.
	// * Before the precedence code is written into a parser override, all the expressions are in effect right bracketed,
	// * as you may expect from a language that is read from left to right.
	// * 
	// * TODO: Programmatically check that the function is an infix function.
	// */ Infix Expression:
	//	Element ({Infix.left=current} (funcName+=[FunctionName] | opName+=InbuiltInfix) right+=Element)*;
	public InfixElements getInfixAccess() {
		return pInfix;
	}
	
	public ParserRule getInfixRule() {
		return getInfixAccess().getRule();
	}
	
	///* currently it will not build because the quantifier is causing recursion I think. 
	// * I think that we need a quantifier free expression to solve the problem Similar to the way
	// * precedence is handled here: https://typefox.io/parsing-expressions-with-xtext
	// */ Element Expression:
	//	Bracket | Prefix | FunctionCall;
	public ElementElements getElementAccess() {
		return pElement;
	}
	
	public ParserRule getElementRule() {
		return getElementAccess().getRule();
	}
	
	//Bracket Expression:
	//	'(' RootExpression ')';
	public BracketElements getBracketAccess() {
		return pBracket;
	}
	
	public ParserRule getBracketRule() {
		return getBracketAccess().getRule();
	}
	
	///* This produces an interesting issue in parsing the program because it is necessary to distinguish between the following three
	// * scenarios: 
	// * A function call f(arguments)
	// * A infix function with a bracketed argument on the right 10 f (arguments)
	// * A function used without any arguments f add g 
	// * 
	// * To solve this functions can either be Prefix, Infix, or called with bracketed arguments. You cannot call a Infix function with bracketd 
	// * arguments. To do this you would need to write another function to make this call for you. In coq this is achieved when you declare a function
	// * you can add a operator name to the function, which is either infix or prefix, this again gives the two names for the function allowing 
	// * it to be called either as an operator or a functional call.
	// * 
	// * This expressions needs a lot of programmatic checking! Starting with the count of the arguments, followed by type checking the arguments.
	// */ FunctionCall Expression:
	//	typeInst=TypeInstance ('(' arguments+=Infix? (',' arguments+=Infix)* ')')?;
	public FunctionCallElements getFunctionCallAccess() {
		return pFunctionCall;
	}
	
	public ParserRule getFunctionCallRule() {
		return getFunctionCallAccess().getRule();
	}
	
	//ExpressionType:
	//	TypeName;
	public ExpressionTypeElements getExpressionTypeAccess() {
		return pExpressionType;
	}
	
	public ParserRule getExpressionTypeRule() {
		return getExpressionTypeAccess().getRule();
	}
	
	//ExpressionVariable:
	//	FunctionName | TypedVariable | ExpressionType;
	public ExpressionVariableElements getExpressionVariableAccess() {
		return pExpressionVariable;
	}
	
	public ParserRule getExpressionVariableRule() {
		return getExpressionVariableAccess().getRule();
	}
	
	///* With Parametric polymorphism classes e.g., Class ReflexRel<T> : T × T → Pred we can use ReflexRel directly 
	// * within an expression as it is the ReflexRel operator. However, with similar type class declarations:
	// * Class Group : Monoid where ... Does it make sense to be able to be able to use Group directly? it 
	// * refers to the whole type. I think that I'm conceptually ok to treat Group or ReflexRel as a polymorphic
	// * instance of the super type, and later treat it more like a set, It strikes me that this is a concept 
	// * already familiar to Generics where we're reasoning using a generic type (which is in a sense a subtype of
	// * its own.
	// * 
	// * The below statement needs scoping all polymorphic types have to be locally declared.
	// */ TypeInstance:
	//	instance=[ExpressionVariable] | typeName=[GenName] ('.' element+=[TypedVariable])+;
	public TypeInstanceElements getTypeInstanceAccess() {
		return pTypeInstance;
	}
	
	public ParserRule getTypeInstanceRule() {
		return getTypeInstanceAccess().getRule();
	}
	
	//InbuiltInfix:
	//	'⇔' | '⇒' | '=' | '≠' | '∧' | '∨';
	public InbuiltInfixElements getInbuiltInfixAccess() {
		return pInbuiltInfix;
	}
	
	public ParserRule getInbuiltInfixRule() {
		return getInbuiltInfixAccess().getRule();
	}
	
	///* Consider whether to add other inbuilt types such as Integers etc. Given the lack of 
	// * recursion in the inbuilt types it may be better to  */ InbuiltType:
	//	'Pred';
	public InbuiltTypeElements getInbuiltTypeAccess() {
		return pInbuiltType;
	}
	
	public ParserRule getInbuiltTypeRule() {
		return getInbuiltTypeAccess().getRule();
	}
	
	//InbuiltTypeScan:
	//	name=InbuiltType;
	public InbuiltTypeScanElements getInbuiltTypeScanAccess() {
		return pInbuiltTypeScan;
	}
	
	public ParserRule getInbuiltTypeScanRule() {
		return getInbuiltTypeScanAccess().getRule();
	}
	
	///* I feel like I should need these, however, I'm not sure when they would be necessary. */ //InbuiltTypeInstance:
	////	'⊤' | '⊥'
	////;
	////
	////InbuiltTypeInstanceScan:
	////	name=InbuiltTypeInstance
	////;
	///* ------------------------------ Instance ---------------------------------------------*/ Instance:
	//	'Instance' className=[TypeName] context=TypeDeclContext '(' arguments+=Infix? (',' arguments+=Infix)* ')';
	public InstanceElements getInstanceAccess() {
		return pInstance;
	}
	
	public ParserRule getInstanceRule() {
		return getInstanceAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
