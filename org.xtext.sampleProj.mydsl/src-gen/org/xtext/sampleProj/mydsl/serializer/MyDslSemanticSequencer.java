/*
 * generated by Xtext 2.12.0
 */
package org.xtext.sampleProj.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.sampleProj.mydsl.myDsl.BaseConstructor;
import org.xtext.sampleProj.mydsl.myDsl.Constructor;
import org.xtext.sampleProj.mydsl.myDsl.Datatype;
import org.xtext.sampleProj.mydsl.myDsl.DomainModel;
import org.xtext.sampleProj.mydsl.myDsl.Expression;
import org.xtext.sampleProj.mydsl.myDsl.Extend;
import org.xtext.sampleProj.mydsl.myDsl.FunctionDecl;
import org.xtext.sampleProj.mydsl.myDsl.FunctionName;
import org.xtext.sampleProj.mydsl.myDsl.Import;
import org.xtext.sampleProj.mydsl.myDsl.ImportComponent;
import org.xtext.sampleProj.mydsl.myDsl.ImportSatement;
import org.xtext.sampleProj.mydsl.myDsl.MyDslPackage;
import org.xtext.sampleProj.mydsl.myDsl.PolyContext;
import org.xtext.sampleProj.mydsl.myDsl.PolyContextTypes;
import org.xtext.sampleProj.mydsl.myDsl.Supertype;
import org.xtext.sampleProj.mydsl.myDsl.TypeBodyElements;
import org.xtext.sampleProj.mydsl.myDsl.TypeConstraints;
import org.xtext.sampleProj.mydsl.myDsl.TypeDeclContext;
import org.xtext.sampleProj.mydsl.myDsl.TypeDeclaration;
import org.xtext.sampleProj.mydsl.myDsl.TypeName;
import org.xtext.sampleProj.mydsl.myDsl.TypedVariable;
import org.xtext.sampleProj.mydsl.myDsl.Where;
import org.xtext.sampleProj.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.BASE_CONSTRUCTOR:
				sequence_BaseConstructor(context, (BaseConstructor) semanticObject); 
				return; 
			case MyDslPackage.CLASS:
				sequence_Class(context, (org.xtext.sampleProj.mydsl.myDsl.Class) semanticObject); 
				return; 
			case MyDslPackage.CONSTRUCTOR:
				sequence_Constructor(context, (Constructor) semanticObject); 
				return; 
			case MyDslPackage.DATATYPE:
				sequence_Datatype(context, (Datatype) semanticObject); 
				return; 
			case MyDslPackage.DOMAIN_MODEL:
				sequence_DomainModel(context, (DomainModel) semanticObject); 
				return; 
			case MyDslPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case MyDslPackage.EXTEND:
				sequence_Extend(context, (Extend) semanticObject); 
				return; 
			case MyDslPackage.FUNCTION_DECL:
				sequence_FunctionDecl(context, (FunctionDecl) semanticObject); 
				return; 
			case MyDslPackage.FUNCTION_NAME:
				sequence_FunctionName(context, (FunctionName) semanticObject); 
				return; 
			case MyDslPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case MyDslPackage.IMPORT_COMPONENT:
				sequence_ImportComponent(context, (ImportComponent) semanticObject); 
				return; 
			case MyDslPackage.IMPORT_SATEMENT:
				sequence_ImportSatement(context, (ImportSatement) semanticObject); 
				return; 
			case MyDslPackage.POLY_CONTEXT:
				sequence_PolyContext(context, (PolyContext) semanticObject); 
				return; 
			case MyDslPackage.POLY_CONTEXT_TYPES:
				sequence_PolyContextTypes(context, (PolyContextTypes) semanticObject); 
				return; 
			case MyDslPackage.SUPERTYPE:
				sequence_Supertype(context, (Supertype) semanticObject); 
				return; 
			case MyDslPackage.TYPE_BODY_ELEMENTS:
				sequence_TypeBodyElements(context, (TypeBodyElements) semanticObject); 
				return; 
			case MyDslPackage.TYPE_CONSTRAINTS:
				sequence_TypeConstraints(context, (TypeConstraints) semanticObject); 
				return; 
			case MyDslPackage.TYPE_DECL_CONTEXT:
				sequence_TypeDeclContext(context, (TypeDeclContext) semanticObject); 
				return; 
			case MyDslPackage.TYPE_DECLARATION:
				sequence_TypeDeclaration(context, (TypeDeclaration) semanticObject); 
				return; 
			case MyDslPackage.TYPE_NAME:
				sequence_TypeName(context, (TypeName) semanticObject); 
				return; 
			case MyDslPackage.TYPED_VARIABLE:
				sequence_TypedVariable(context, (TypedVariable) semanticObject); 
				return; 
			case MyDslPackage.WHERE:
				sequence_Where(context, (Where) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     DatatypeConstructor returns BaseConstructor
	 *     BaseConstructor returns BaseConstructor
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_BaseConstructor(ISerializationContext context, BaseConstructor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DATATYPE_CONSTRUCTOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DATATYPE_CONSTRUCTOR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBaseConstructorAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TopLevel returns Class
	 *     ClassDecl returns Class
	 *     Class returns Class
	 *
	 * Constraint:
	 *     (name=TypeName context+=PolyContext? bodyElements+=TypeBodyElements*)
	 */
	protected void sequence_Class(ISerializationContext context, org.xtext.sampleProj.mydsl.myDsl.Class semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DatatypeConstructor returns Constructor
	 *     Constructor returns Constructor
	 *
	 * Constraint:
	 *     (name=ID typedVariables+=TypedVariable*)
	 */
	protected void sequence_Constructor(ISerializationContext context, Constructor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TopLevel returns Datatype
	 *     ClassDecl returns Datatype
	 *     Datatype returns Datatype
	 *
	 * Constraint:
	 *     (name=TypeName context+=PolyContext? constructors+=DatatypeConstructor* bodyElements+=TypeBodyElements*)
	 */
	protected void sequence_Datatype(ISerializationContext context, Datatype semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DomainModel returns DomainModel
	 *
	 * Constraint:
	 *     elements+=TopLevel+
	 */
	protected void sequence_DomainModel(ISerializationContext context, DomainModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXPRESSION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TopLevel returns Extend
	 *     ClassDecl returns Extend
	 *     Extend returns Extend
	 *
	 * Constraint:
	 *     (name=[TypeName|ID] extesnion=ID bodyElements+=TypeBodyElements*)
	 */
	protected void sequence_Extend(ISerializationContext context, Extend semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDecl returns FunctionDecl
	 *
	 * Constraint:
	 *     (name+=FunctionName typeVariables+=TypedVariable*)
	 */
	protected void sequence_FunctionDecl(ISerializationContext context, FunctionDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionName returns FunctionName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_FunctionName(ISerializationContext context, FunctionName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FUNCTION_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FUNCTION_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ImportComponent returns ImportComponent
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ImportComponent(ISerializationContext context, ImportComponent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.IMPORT_COMPONENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.IMPORT_COMPONENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportComponentAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TopLevel returns ImportSatement
	 *     ImportSatement returns ImportSatement
	 *
	 * Constraint:
	 *     imports+=Import
	 */
	protected void sequence_ImportSatement(ISerializationContext context, ImportSatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     (importName+=ImportComponent importName+=ImportComponent)
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PolyContextTypes returns PolyContextTypes
	 *
	 * Constraint:
	 *     (name=ID constraints+=TypeConstraints*)
	 */
	protected void sequence_PolyContextTypes(ISerializationContext context, PolyContextTypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PolyContext returns PolyContext
	 *
	 * Constraint:
	 *     polyTypes+=PolyContextTypes+
	 */
	protected void sequence_PolyContext(ISerializationContext context, PolyContext semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Supertype returns Supertype
	 *
	 * Constraint:
	 *     (superType+=TypeDeclaration superType+=TypeDeclaration*)
	 */
	protected void sequence_Supertype(ISerializationContext context, Supertype semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeBodyElements returns TypeBodyElements
	 *
	 * Constraint:
	 *     (functions+=FunctionDecl | theorems+=TheoremBody)
	 */
	protected void sequence_TypeBodyElements(ISerializationContext context, TypeBodyElements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeConstraints returns TypeConstraints
	 *
	 * Constraint:
	 *     (typeName+=[TypeName|ID] typeName+=[TypeName|ID]*)
	 */
	protected void sequence_TypeConstraints(ISerializationContext context, TypeConstraints semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDeclContext returns TypeDeclContext
	 *
	 * Constraint:
	 *     typeName+=[TypeName|ID]
	 */
	protected void sequence_TypeDeclContext(ISerializationContext context, TypeDeclContext semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDeclaration returns TypeDeclaration
	 *
	 * Constraint:
	 *     (typeName=[TypeName|ID] context=TypeDeclContext)
	 */
	protected void sequence_TypeDeclaration(ISerializationContext context, TypeDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TYPE_DECLARATION__TYPE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TYPE_DECLARATION__TYPE_NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TYPE_DECLARATION__CONTEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TYPE_DECLARATION__CONTEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeDeclarationAccess().getTypeNameTypeNameIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MyDslPackage.Literals.TYPE_DECLARATION__TYPE_NAME, false));
		feeder.accept(grammarAccess.getTypeDeclarationAccess().getContextTypeDeclContextParserRuleCall_1_0(), semanticObject.getContext());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeName returns TypeName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_TypeName(ISerializationContext context, TypeName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TYPE_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TYPE_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypedVariable returns TypedVariable
	 *
	 * Constraint:
	 *     (name=ID constraints+=TypeConstraints)
	 */
	protected void sequence_TypedVariable(ISerializationContext context, TypedVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Where returns Where
	 *
	 * Constraint:
	 *     (expessions+=Expression expressions+=Expression)
	 */
	protected void sequence_Where(ISerializationContext context, Where semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
