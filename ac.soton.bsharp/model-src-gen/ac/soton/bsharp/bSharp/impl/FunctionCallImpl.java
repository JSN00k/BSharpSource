/**
 * generated by Xtext 2.14.0
 */
package ac.soton.bsharp.bSharp.impl;

import ac.soton.bsharp.bSharp.BSClass;
import ac.soton.bsharp.bSharp.BSharpFactory;
import ac.soton.bsharp.bSharp.BSharpPackage;
import ac.soton.bsharp.bSharp.ClassDecl;
import ac.soton.bsharp.bSharp.ClassVarDecl;
import ac.soton.bsharp.bSharp.ConstructedType;
import ac.soton.bsharp.bSharp.Expression;
import ac.soton.bsharp.bSharp.ExpressionVariable;
import ac.soton.bsharp.bSharp.FuncCallArgs;
import ac.soton.bsharp.bSharp.FunctionCall;
import ac.soton.bsharp.bSharp.FunctionDecl;
import ac.soton.bsharp.bSharp.GenName;
import ac.soton.bsharp.bSharp.IVariableProvider;
import ac.soton.bsharp.bSharp.InstName;
import ac.soton.bsharp.bSharp.PolyType;
import ac.soton.bsharp.bSharp.TypeBuilder;
import ac.soton.bsharp.bSharp.TypeDeclContext;
import ac.soton.bsharp.bSharp.TypedVariable;

import ac.soton.bsharp.bSharp.WrappedInfix;
import ac.soton.bsharp.typeInstanceRepresentation.ITypeInstance;
import ac.soton.bsharp.typeInstanceRepresentation.StringTypeInstance;

import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;
import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;
import org.eclipse.xtext.EcoreUtil2;

/**
 * <!-- begin-user-doc -->
 * An implementation of the model object '<em><b>Function Call</b></em>'.
 * <!-- end-user-doc -->
 * <p>
 * The following features are implemented:
 * </p>
 * <ul>
 *   <li>{@link ac.soton.bsharp.bSharp.impl.FunctionCallImpl#getContext <em>Context</em>}</li>
 *   <li>{@link ac.soton.bsharp.bSharp.impl.FunctionCallImpl#getWrapped <em>Wrapped</em>}</li>
 *   <li>{@link ac.soton.bsharp.bSharp.impl.FunctionCallImpl#getCompilationObject <em>Compilation Object</em>}</li>
 *   <li>{@link ac.soton.bsharp.bSharp.impl.FunctionCallImpl#getFuncCallArgs <em>Func Call Args</em>}</li>
 *   <li>{@link ac.soton.bsharp.bSharp.impl.FunctionCallImpl#getGenInbuiltFunc <em>Gen Inbuilt Func</em>}</li>
 *   <li>{@link ac.soton.bsharp.bSharp.impl.FunctionCallImpl#getGetter <em>Getter</em>}</li>
 *   <li>{@link ac.soton.bsharp.bSharp.impl.FunctionCallImpl#getClassVarDecl <em>Class Var Decl</em>}</li>
 * </ul>
 *
 * @generated
 */
public class FunctionCallImpl extends ExpressionImpl implements FunctionCall {
	/**
	 * The cached value of the '{@link #getContext() <em>Context</em>}' containment reference.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see #getContext()
	 * @generated
	 * @ordered
	 */
	protected TypeDeclContext context;

	/**
	 * The cached value of the '{@link #getWrapped() <em>Wrapped</em>}' containment reference.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see #getWrapped()
	 * @generated
	 * @ordered
	 */
	protected WrappedInfix wrapped;

	/**
	 * The cached value of the '{@link #getCompilationObject() <em>Compilation Object</em>}' containment reference.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see #getCompilationObject()
	 * @generated
	 * @ordered
	 */
	protected EObject compilationObject;

	/**
	 * The cached value of the '{@link #getFuncCallArgs() <em>Func Call Args</em>}' containment reference list.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see #getFuncCallArgs()
	 * @generated
	 * @ordered
	 */
	protected EList<FuncCallArgs> funcCallArgs;

	/**
	 * The cached value of the '{@link #getGenInbuiltFunc() <em>Gen Inbuilt Func</em>}' containment reference.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see #getGenInbuiltFunc()
	 * @generated
	 * @ordered
	 */
	protected FunctionDecl genInbuiltFunc;

	/**
	 * The cached value of the '{@link #getGetter() <em>Getter</em>}' reference.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see #getGetter()
	 * @generated
	 * @ordered
	 */
	protected ExpressionVariable getter;

	/**
	 * The cached value of the '{@link #getClassVarDecl() <em>Class Var Decl</em>}' containment reference.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see #getClassVarDecl()
	 * @generated
	 * @ordered
	 */
	protected ClassVarDecl classVarDecl;

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	protected FunctionCallImpl() {
		super();
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	protected EClass eStaticClass() {
		return BSharpPackage.Literals.FUNCTION_CALL;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public TypeDeclContext getContext() {
		return context;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public NotificationChain basicSetContext(TypeDeclContext newContext, NotificationChain msgs) {
		TypeDeclContext oldContext = context;
		context = newContext;
		if (eNotificationRequired()) {
			ENotificationImpl notification = new ENotificationImpl(this, Notification.SET, BSharpPackage.FUNCTION_CALL__CONTEXT, oldContext, newContext);
			if (msgs == null) msgs = notification; else msgs.add(notification);
		}
		return msgs;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public void setContext(TypeDeclContext newContext) {
		if (newContext != context) {
			NotificationChain msgs = null;
			if (context != null)
				msgs = ((InternalEObject)context).eInverseRemove(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.FUNCTION_CALL__CONTEXT, null, msgs);
			if (newContext != null)
				msgs = ((InternalEObject)newContext).eInverseAdd(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.FUNCTION_CALL__CONTEXT, null, msgs);
			msgs = basicSetContext(newContext, msgs);
			if (msgs != null) msgs.dispatch();
		}
		else if (eNotificationRequired())
			eNotify(new ENotificationImpl(this, Notification.SET, BSharpPackage.FUNCTION_CALL__CONTEXT, newContext, newContext));
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public WrappedInfix getWrapped() {
		return wrapped;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public NotificationChain basicSetWrapped(WrappedInfix newWrapped, NotificationChain msgs) {
		WrappedInfix oldWrapped = wrapped;
		wrapped = newWrapped;
		if (eNotificationRequired()) {
			ENotificationImpl notification = new ENotificationImpl(this, Notification.SET, BSharpPackage.FUNCTION_CALL__WRAPPED, oldWrapped, newWrapped);
			if (msgs == null) msgs = notification; else msgs.add(notification);
		}
		return msgs;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public void setWrapped(WrappedInfix newWrapped) {
		if (newWrapped != wrapped) {
			NotificationChain msgs = null;
			if (wrapped != null)
				msgs = ((InternalEObject)wrapped).eInverseRemove(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.FUNCTION_CALL__WRAPPED, null, msgs);
			if (newWrapped != null)
				msgs = ((InternalEObject)newWrapped).eInverseAdd(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.FUNCTION_CALL__WRAPPED, null, msgs);
			msgs = basicSetWrapped(newWrapped, msgs);
			if (msgs != null) msgs.dispatch();
		}
		else if (eNotificationRequired())
			eNotify(new ENotificationImpl(this, Notification.SET, BSharpPackage.FUNCTION_CALL__WRAPPED, newWrapped, newWrapped));
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public EObject getCompilationObject() {
		return compilationObject;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public NotificationChain basicSetCompilationObject(EObject newCompilationObject, NotificationChain msgs) {
		EObject oldCompilationObject = compilationObject;
		compilationObject = newCompilationObject;
		if (eNotificationRequired()) {
			ENotificationImpl notification = new ENotificationImpl(this, Notification.SET, BSharpPackage.FUNCTION_CALL__COMPILATION_OBJECT, oldCompilationObject, newCompilationObject);
			if (msgs == null) msgs = notification; else msgs.add(notification);
		}
		return msgs;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public void setCompilationObject(EObject newCompilationObject) {
		if (newCompilationObject != compilationObject) {
			NotificationChain msgs = null;
			if (compilationObject != null)
				msgs = ((InternalEObject)compilationObject).eInverseRemove(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.FUNCTION_CALL__COMPILATION_OBJECT, null, msgs);
			if (newCompilationObject != null)
				msgs = ((InternalEObject)newCompilationObject).eInverseAdd(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.FUNCTION_CALL__COMPILATION_OBJECT, null, msgs);
			msgs = basicSetCompilationObject(newCompilationObject, msgs);
			if (msgs != null) msgs.dispatch();
		}
		else if (eNotificationRequired())
			eNotify(new ENotificationImpl(this, Notification.SET, BSharpPackage.FUNCTION_CALL__COMPILATION_OBJECT, newCompilationObject, newCompilationObject));
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public EList<FuncCallArgs> getFuncCallArgs() {
		if (funcCallArgs == null) {
			funcCallArgs = new EObjectContainmentEList<FuncCallArgs>(FuncCallArgs.class, this, BSharpPackage.FUNCTION_CALL__FUNC_CALL_ARGS);
		}
		return funcCallArgs;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public FunctionDecl getGenInbuiltFunc() {
		return genInbuiltFunc;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public NotificationChain basicSetGenInbuiltFunc(FunctionDecl newGenInbuiltFunc, NotificationChain msgs) {
		FunctionDecl oldGenInbuiltFunc = genInbuiltFunc;
		genInbuiltFunc = newGenInbuiltFunc;
		if (eNotificationRequired()) {
			ENotificationImpl notification = new ENotificationImpl(this, Notification.SET, BSharpPackage.FUNCTION_CALL__GEN_INBUILT_FUNC, oldGenInbuiltFunc, newGenInbuiltFunc);
			if (msgs == null) msgs = notification; else msgs.add(notification);
		}
		return msgs;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public void setGenInbuiltFunc(FunctionDecl newGenInbuiltFunc) {
		if (newGenInbuiltFunc != genInbuiltFunc) {
			NotificationChain msgs = null;
			if (genInbuiltFunc != null)
				msgs = ((InternalEObject)genInbuiltFunc).eInverseRemove(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.FUNCTION_CALL__GEN_INBUILT_FUNC, null, msgs);
			if (newGenInbuiltFunc != null)
				msgs = ((InternalEObject)newGenInbuiltFunc).eInverseAdd(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.FUNCTION_CALL__GEN_INBUILT_FUNC, null, msgs);
			msgs = basicSetGenInbuiltFunc(newGenInbuiltFunc, msgs);
			if (msgs != null) msgs.dispatch();
		}
		else if (eNotificationRequired())
			eNotify(new ENotificationImpl(this, Notification.SET, BSharpPackage.FUNCTION_CALL__GEN_INBUILT_FUNC, newGenInbuiltFunc, newGenInbuiltFunc));
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public ExpressionVariable getGetter() {
		if (getter != null && getter.eIsProxy()) {
			InternalEObject oldGetter = (InternalEObject)getter;
			getter = (ExpressionVariable)eResolveProxy(oldGetter);
			if (getter != oldGetter) {
				if (eNotificationRequired())
					eNotify(new ENotificationImpl(this, Notification.RESOLVE, BSharpPackage.FUNCTION_CALL__GETTER, oldGetter, getter));
			}
		}
		return getter;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public ExpressionVariable basicGetGetter() {
		return getter;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public void setGetter(ExpressionVariable newGetter) {
		ExpressionVariable oldGetter = getter;
		getter = newGetter;
		if (eNotificationRequired())
			eNotify(new ENotificationImpl(this, Notification.SET, BSharpPackage.FUNCTION_CALL__GETTER, oldGetter, getter));
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 */
	@Override
	public ClassVarDecl getClassVarDecl() {
		if (classVarDecl != null)
			return classVarDecl;
		
		if (getter == null) {
			return null;
		}
		
		ClassVarDecl cvd = BSharpFactory.eINSTANCE.createClassVarDecl();
		cvd.setTypeVar(getter);
		

		ExpressionVariable inst = getTypeInst();
			
		if (!(inst instanceof TypedVariable) && !(inst instanceof ConstructedType) && !(inst instanceof PolyType))
			return null;
		
		if (inst instanceof TypedVariable) {
			cvd.setTypedVar((TypedVariable)inst);
		} else if (inst instanceof PolyType) {
			cvd.setOwnerType((PolyType)inst);
		} else if (inst instanceof InstName) {
			cvd.setOwnerType((InstName)inst);
		} else {
			ClassDecl type = ((ConstructedType)inst).getClassDecl();
			cvd.setOwnerType(type);
		}
		
		setClassVarDecl(cvd);
		
		return classVarDecl;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public NotificationChain basicSetClassVarDecl(ClassVarDecl newClassVarDecl, NotificationChain msgs) {
		ClassVarDecl oldClassVarDecl = classVarDecl;
		classVarDecl = newClassVarDecl;
		if (eNotificationRequired()) {
			ENotificationImpl notification = new ENotificationImpl(this, Notification.SET, BSharpPackage.FUNCTION_CALL__CLASS_VAR_DECL, oldClassVarDecl, newClassVarDecl);
			if (msgs == null) msgs = notification; else msgs.add(notification);
		}
		return msgs;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public void setClassVarDecl(ClassVarDecl newClassVarDecl) {
		if (newClassVarDecl != classVarDecl) {
			NotificationChain msgs = null;
			if (classVarDecl != null)
				msgs = ((InternalEObject)classVarDecl).eInverseRemove(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.FUNCTION_CALL__CLASS_VAR_DECL, null, msgs);
			if (newClassVarDecl != null)
				msgs = ((InternalEObject)newClassVarDecl).eInverseAdd(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.FUNCTION_CALL__CLASS_VAR_DECL, null, msgs);
			msgs = basicSetClassVarDecl(newClassVarDecl, msgs);
			if (msgs != null) msgs.dispatch();
		}
		else if (eNotificationRequired())
			eNotify(new ENotificationImpl(this, Notification.SET, BSharpPackage.FUNCTION_CALL__CLASS_VAR_DECL, newClassVarDecl, newClassVarDecl));
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs) {
		switch (featureID) {
			case BSharpPackage.FUNCTION_CALL__CONTEXT:
				return basicSetContext(null, msgs);
			case BSharpPackage.FUNCTION_CALL__WRAPPED:
				return basicSetWrapped(null, msgs);
			case BSharpPackage.FUNCTION_CALL__COMPILATION_OBJECT:
				return basicSetCompilationObject(null, msgs);
			case BSharpPackage.FUNCTION_CALL__FUNC_CALL_ARGS:
				return ((InternalEList<?>)getFuncCallArgs()).basicRemove(otherEnd, msgs);
			case BSharpPackage.FUNCTION_CALL__GEN_INBUILT_FUNC:
				return basicSetGenInbuiltFunc(null, msgs);
			case BSharpPackage.FUNCTION_CALL__CLASS_VAR_DECL:
				return basicSetClassVarDecl(null, msgs);
		}
		return super.eInverseRemove(otherEnd, featureID, msgs);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public Object eGet(int featureID, boolean resolve, boolean coreType) {
		switch (featureID) {
			case BSharpPackage.FUNCTION_CALL__CONTEXT:
				return getContext();
			case BSharpPackage.FUNCTION_CALL__WRAPPED:
				return getWrapped();
			case BSharpPackage.FUNCTION_CALL__COMPILATION_OBJECT:
				return getCompilationObject();
			case BSharpPackage.FUNCTION_CALL__FUNC_CALL_ARGS:
				return getFuncCallArgs();
			case BSharpPackage.FUNCTION_CALL__GEN_INBUILT_FUNC:
				return getGenInbuiltFunc();
			case BSharpPackage.FUNCTION_CALL__GETTER:
				if (resolve) return getGetter();
				return basicGetGetter();
			case BSharpPackage.FUNCTION_CALL__CLASS_VAR_DECL:
				return getClassVarDecl();
		}
		return super.eGet(featureID, resolve, coreType);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@SuppressWarnings("unchecked")
	@Override
	public void eSet(int featureID, Object newValue) {
		switch (featureID) {
			case BSharpPackage.FUNCTION_CALL__CONTEXT:
				setContext((TypeDeclContext)newValue);
				return;
			case BSharpPackage.FUNCTION_CALL__WRAPPED:
				setWrapped((WrappedInfix)newValue);
				return;
			case BSharpPackage.FUNCTION_CALL__COMPILATION_OBJECT:
				setCompilationObject((EObject)newValue);
				return;
			case BSharpPackage.FUNCTION_CALL__FUNC_CALL_ARGS:
				getFuncCallArgs().clear();
				getFuncCallArgs().addAll((Collection<? extends FuncCallArgs>)newValue);
				return;
			case BSharpPackage.FUNCTION_CALL__GEN_INBUILT_FUNC:
				setGenInbuiltFunc((FunctionDecl)newValue);
				return;
			case BSharpPackage.FUNCTION_CALL__GETTER:
				setGetter((ExpressionVariable)newValue);
				return;
			case BSharpPackage.FUNCTION_CALL__CLASS_VAR_DECL:
				setClassVarDecl((ClassVarDecl)newValue);
				return;
		}
		super.eSet(featureID, newValue);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public void eUnset(int featureID) {
		switch (featureID) {
			case BSharpPackage.FUNCTION_CALL__CONTEXT:
				setContext((TypeDeclContext)null);
				return;
			case BSharpPackage.FUNCTION_CALL__WRAPPED:
				setWrapped((WrappedInfix)null);
				return;
			case BSharpPackage.FUNCTION_CALL__COMPILATION_OBJECT:
				setCompilationObject((EObject)null);
				return;
			case BSharpPackage.FUNCTION_CALL__FUNC_CALL_ARGS:
				getFuncCallArgs().clear();
				return;
			case BSharpPackage.FUNCTION_CALL__GEN_INBUILT_FUNC:
				setGenInbuiltFunc((FunctionDecl)null);
				return;
			case BSharpPackage.FUNCTION_CALL__GETTER:
				setGetter((ExpressionVariable)null);
				return;
			case BSharpPackage.FUNCTION_CALL__CLASS_VAR_DECL:
				setClassVarDecl((ClassVarDecl)null);
				return;
		}
		super.eUnset(featureID);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public boolean eIsSet(int featureID) {
		switch (featureID) {
			case BSharpPackage.FUNCTION_CALL__CONTEXT:
				return context != null;
			case BSharpPackage.FUNCTION_CALL__WRAPPED:
				return wrapped != null;
			case BSharpPackage.FUNCTION_CALL__COMPILATION_OBJECT:
				return compilationObject != null;
			case BSharpPackage.FUNCTION_CALL__FUNC_CALL_ARGS:
				return funcCallArgs != null && !funcCallArgs.isEmpty();
			case BSharpPackage.FUNCTION_CALL__GEN_INBUILT_FUNC:
				return genInbuiltFunc != null;
			case BSharpPackage.FUNCTION_CALL__GETTER:
				return getter != null;
			case BSharpPackage.FUNCTION_CALL__CLASS_VAR_DECL:
				return classVarDecl != null;
		}
		return super.eIsSet(featureID);
	}
	
	/* 
	 * (non-Javadoc)
	 * @see ac.soton.bsharp.bSharp.impl.ExpressionImpl#getTypeInst()
	 * If method unifies the FuncName and Wrapped infix functions. This causes a problem
	 * if we are currently validating as a additional EMF is generated that Xtext doesn't 
	 * like. getTypeInstBasic() resolves this by not converting the WrappedInfix to a functionName.
	 */
	@Override
	public ExpressionVariable getTypeInst() {
		ExpressionVariable t = super.getTypeInst();
		if (t == null) {
			WrappedInfix wrapped = getWrapped();
			if (wrapped != null) {
				return wrapped.getFuncName();
			}
		}
		
		return t;
	}
	
	public ExpressionVariable getTypeInstBasic() {
		return super.getTypeInst();
	}

	@Override
	public String constructLatexExpressionTree(String indent) {
		String name = null;
		ExpressionVariable typeInst = getTypeInst();
		if (typeInst != null) {
			name = typeInst.getName();
		}
		
		if (funcCallArgs == null || funcCallArgs.isEmpty()) {
			if (name == null)
				name = "noName";
			
			return indent + "$" + name + "$";
		}
		
		String result = indent + "[.$" + name + "$\n";
		boolean first = true;
		for (FuncCallArgs block : funcCallArgs) {
			if (!first) {
				result += " [.ApplyBlock ";
			}
			for (Expression expr : block.getArguments()) {
				result += expr.constructLatexExpressionTree("  " + indent) + "\n";
			}
			
			result += indent + "]";
		}
		
		return result;
	}
	
	@Override
	public String compileToEventBString(Boolean asPredicate) throws Exception {
		return compileToStringWithContext(this, asPredicate);
	}
	
	/* Sometimes there are wrapped function calls that need the information from the original function call passed through
	 * this function allows that. */
	@Override
	public String compileToStringWithContext(FunctionCall fc, Boolean asPredicate) throws Exception {
		ExpressionVariable getter = getGetter();
		if (getter != null) {
			ExpressionVariable typeInst = getTypeInst();
			if (typeInst instanceof InstName) {
				return getter.compileToStringWithContext(fc, asPredicate);
			}
			
			if (typeInst instanceof TypedVariable) {
				ITypeInstance ti = new StringTypeInstance((TypedVariable)typeInst);
				return ti.compileFunctionCallOfTypeInstance(fc, asPredicate, (TypedVariable)getter);
			}
		}
		
		ExpressionVariable typeInst = getTypeInst();
		ClassVarDecl classVarDecl = getClassVarDecl();
		if (classVarDecl == null) {
			return typeInst.compileToStringWithContext(fc, asPredicate);
		} else {
			return classVarDecl.compileToStringWithContext(fc, asPredicate);
		}
	}

	@Override
	public Integer eventBPrecedence(Boolean whenPredicate) {
		if (!whenPredicate)
			return 2;
		
		/* If we're expected to return a predicate then there are situations where 
		 * appending '= TRUE' is necessary. This changes the precedence to 0 as 
		 * we're really compiling an EventB equality operator.
		 */
		if (getTypeInst() instanceof FunctionDecl) {
			return 2;
		} else {
			return 0;
		}
	}

	@Override
	public Boolean requiresInferredContext() {
		ExpressionVariable typeInst = getTypeInst();
		if (typeInst instanceof TypedVariable) {
			IVariableProvider varProv = EcoreUtil2.getContainerOfType(typeInst, IVariableProvider.class);
			if (varProv instanceof BSClass)
				return true;
		}
		
		if (funcCallArgs != null && !funcCallArgs.isEmpty()) {
			List<Expression> args = funcCallArgs.get(0).getArguments();
			for (Expression argument : args) {
				if (argument.requiresInferredContext())
					return true;
			}
		}
		
		return false;
	}

	@Override
	public Expression reorderExpresionTree() {
		if (reordered) {
			return this;
		}
		reordered = true;
		
		if (funcCallArgs == null || funcCallArgs.isEmpty())
			return this;
		
		for (FuncCallArgs fca : funcCallArgs) {
			fca.reorderExpressionTree();
		}

		return this;
	}

	@Override
	public boolean referencesContainingType() {
		ExpressionVariable typeInst = getTypeInst();
		if (typeInst instanceof InstName) {
			return true;
		}
		
		ClassVarDecl classVarDecl = getClassVarDecl();
		
		if (classVarDecl != null) {
			if (classVarDecl.referencesContainingType())
				return true;
			
		}
			
		if (typeInst instanceof FunctionDecl) {
			/* In recursive definitions there is a possible infinite recursion here, as
			 * if the functionCall is a call to the function being defined checking that
			 * function for references to the supertype will always continue to check
			 * the function again.
			 */
			FunctionDecl declFunc = EcoreUtil2.getContainerOfType(this, FunctionDecl.class);
			if (declFunc == typeInst) {
				return false;
			}
			
			/* A Method is a function that implicitly uses type variables from its containing
			 * type. Within the containing type methods can also be used without explicit
			 * reference to the containing type. This is therefore an implicit reference to the
			 * containing type.
			 */
			if (((FunctionDecl) typeInst).isMethod())
				return true;
		}
		
		if (typeInst instanceof TypedVariable) {
			IVariableProvider varProv = EcoreUtil2.getContainerOfType(typeInst, IVariableProvider.class);
			
			if (varProv instanceof BSClass) {
				/* If we're using a variable from a class we have to be within that class. */
				return true;
			}
		}
		
		if (typeInst instanceof TypeBuilder) {
			if (((TypeBuilder)typeInst).referencesContainingType())
				return true;
			
		}
		


		if (context != null && context.referencesContainingType()) {
			return true;
		}
		
		
		if (funcCallArgs != null) {
			for (FuncCallArgs fca : funcCallArgs) {
				if (fca.referencesContainingType())
					return true;
			}
		}
		
		return false;
	}
	
	@Override
	public boolean isInstanceVariable() {
		ExpressionVariable typeInst = getTypeInst();
		return typeInst != null && typeInst instanceof TypedVariable && (funcCallArgs == null || funcCallArgs.isEmpty());
	}

	@Override
	public TypeBuilder calculateType() {
		// TODO: This does not appear to calculate the type when called with a context and no args.
		ClassVarDecl classVarDecl = getClassVarDecl();
		if (funcCallArgs == null || funcCallArgs.isEmpty()) {
			if (classVarDecl != null) {
				return classVarDecl.calculateType();
			} else {
				return typeInst.calculateType();
			}
		}
		
		Iterator<FuncCallArgs> iter = funcCallArgs.iterator();
		List<Expression> arguments = iter.next().getArguments();
		TypeDeclContext ctx = getContext();
		
		ExpressionVariable typeInst = getTypeInst();
		TypeBuilder type = null;
		if (arguments != null && !arguments.isEmpty()) {
			
			if (classVarDecl == null) {
				type =  typeInst.calculateReturnType(ctx, arguments);
			} else {
				type = classVarDecl.calculateReturnType(ctx, arguments);
			}
		}
		
		// TODO: validate these function calls so this can't go wrong. 
		while (iter.hasNext()) {
			if (type instanceof ConstructedType) {
				type = ((ConstructedType) type).getRight();
			}
		}
		
		return type;
	}
	 
	private HashMap<PolyType, TypeBuilder> polyTypeMap() throws Exception {
		ExpressionVariable typeInst = getTypeInst();
		if (!(typeInst instanceof FunctionDecl)) {
			return null;
		}
		
		List<PolyType> polyTypes = ((FunctionDecl)typeInst).getPolyTypeNames();
		if (polyTypes == null || polyTypes.size() == 0) {
			return null;
		}
		
		int ctxSize = polyTypes.size();
		
		List<TypeBuilder> concreteTypes = getContext().getTypeName();
		
		if (ctxSize != concreteTypes.size()) {
			throw new Exception("Context and call sizes do not match");
		}
		
		HashMap<PolyType, TypeBuilder> typeMap = new HashMap<PolyType, TypeBuilder>();
		for(int i = 0; i < ctxSize; ++i) {
			typeMap.put(polyTypes.get(i), concreteTypes.get(i));
		}
		
		return typeMap;
	}

	@Override
	public HashMap<PolyType, TypeBuilder> getAllPolyTypeMappings() throws Exception {
		FunctionCall above = EcoreUtil2.getContainerOfType(this.eContainer(), FunctionCall.class);
		
		if (above == null) {
			return polyTypeMap();
		}
		
		HashMap<PolyType, TypeBuilder> superMap = above.getAllPolyTypeMappings();
		if (superMap == null) {
			return polyTypeMap();
		}
		
		HashMap<PolyType, TypeBuilder> localMap = polyTypeMap();
		if (localMap == null) {
			return superMap;
		}
		
		superMap.putAll(localMap);
		return superMap;
	}
} //FunctionCallImpl
