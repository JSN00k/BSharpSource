/**
 * generated by Xtext 2.14.0
 */
package ac.soton.bsharp.bSharp.impl;

import ac.soton.bsharp.bSharp.BSharpFactory;
import ac.soton.bsharp.bSharp.BSharpPackage;
import ac.soton.bsharp.bSharp.Datatype;
import ac.soton.bsharp.bSharp.InbuiltInfix;
import ac.soton.bsharp.bSharp.TypeBuilder;
import ac.soton.bsharp.bSharp.TypeConstructor;
import ac.soton.bsharp.bSharp.util.ExprPredEnum;
import ac.soton.bsharp.bSharp.util.Tuple2;

import java.util.HashMap;
import java.util.Map;

import org.eclipse.emf.ecore.EClass;

/**
 * <!-- begin-user-doc -->
 * An implementation of the model object '<em><b>Inbuilt Infix</b></em>'.
 * <!-- end-user-doc -->
 *
 * @generated
 */
public class InbuiltInfixImpl extends InfixFuncImpl implements InbuiltInfix {
	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	protected InbuiltInfixImpl() {
		super();
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	protected EClass eStaticClass() {
		return BSharpPackage.Literals.INBUILT_INFIX;
	}

	@Override
	public TypeBuilder calculateType() {
		// Need to work out how the polymorphic information should be passed here.
		return null;
	}

	@Override
	public TypeBuilder calculateReturnType() {
		Datatype dt = BSharpFactory.eINSTANCE.createDatatype();
		dt.setName("Bool");
		TypeConstructor tc = BSharpFactory.eINSTANCE.createTypeConstructor();
		tc.setTypeName(dt);
		return tc;
	}
	
	static Map<String, Integer> getInfixPrecedenceMap() {
		HashMap<String, Integer> map = new HashMap<String, Integer>();
		map.put("⇔", 50);
	 	map.put("⇒", 50);
	 	map.put("=", 70);
	 	map.put("≠", 70);
	 	map.put("∧", 60);
	 	map.put("∨", 60);
	 	return map;
	}
	
	protected final Map<String, Integer> inbuiltPrecedence = getInfixPrecedenceMap();

	@Override
	public String eventBName(ExprPredEnum exprPred) {
		return name;
	}

	@Override
	public ExprPredEnum compilationResultType(ExprPredEnum desiredType) {
		return ExprPredEnum.PREDICATE;
	}

	@Override
	public boolean hasEventBInfixOp() {
		return true;
	}

	@Override
	public String latexName() {
		if (name.equals("⇔")) {
			return "\\Leftrightarrow";
		} else if (name.equals("⇒")) {
			return "\\implies";
		} else if (name.equals("≠")) {
			return "\\neq";
		} else if (name.equals("∧")) {
			return "\\land";
		} else if (name.equals("∨")) {
			return "\\lor";
		}
		
		return name;
	}

	@Override
	public Tuple2<ExprPredEnum, ExprPredEnum> infixArgumentExprPredTypes() {
		if (name.equals("=") || name.contentEquals("≠"))
			return new Tuple2<ExprPredEnum, ExprPredEnum>(ExprPredEnum.EXPRESSION, ExprPredEnum.EXPRESSION) ;
			
		return new Tuple2<ExprPredEnum, ExprPredEnum>(ExprPredEnum.PREDICATE, ExprPredEnum.PREDICATE);
	}
	
	@Override
	public Integer bSharpPrecedence() {
		return inbuiltPrecedence.get(getName());
	}
	
} //InbuiltInfixImpl
