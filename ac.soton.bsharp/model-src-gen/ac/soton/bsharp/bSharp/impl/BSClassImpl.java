/**
 * generated by Xtext 2.14.0
 */
package ac.soton.bsharp.bSharp.impl;

import ac.soton.bsharp.bSharp.BSharpPackage;
import ac.soton.bsharp.bSharp.ClassDecl;
import ac.soton.bsharp.bSharp.ConstructedType;
import ac.soton.bsharp.bSharp.BSClass;
import ac.soton.bsharp.bSharp.SuperTypeList;
import ac.soton.bsharp.bSharp.TypeBuilder;
import ac.soton.bsharp.bSharp.TypeConstructor;
import ac.soton.bsharp.bSharp.TypeDeclContext;
import ac.soton.bsharp.bSharp.TypedVariable;
import ac.soton.bsharp.bSharp.TypedVariableList;
import ac.soton.bsharp.bSharp.Where;
import ac.soton.bsharp.bSharp.util.CompilationUtil;
import ac.soton.bsharp.bSharp.util.Tuple2;
import ac.soton.bsharp.theory.util.TheoryImportCache;
import ac.soton.bsharp.theory.util.TheoryUtils;

import java.util.ArrayList;
import java.util.Collection;

import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.xtext.EcoreUtil2;
import org.eventb.core.ast.extension.IOperatorProperties.FormulaType;
import org.eventb.core.ast.extension.IOperatorProperties.Notation;
import org.eventb.theory.core.INewOperatorDefinition;


/**
 * <!-- begin-user-doc -->
 * An implementation of the model object '<em><b>Bpp Class</b></em>'.
 * <!-- end-user-doc -->
 * <p>
 * The following features are implemented:
 * </p>
 * <ul>
 *   <li>{@link ac.soton.bsharp.bSharp.impl.BSClassImpl#getSupertypes <em>Supertypes</em>}</li>
 *   <li>{@link ac.soton.bsharp.bSharp.impl.BSClassImpl#getVarList <em>Var List</em>}</li>
 *   <li>{@link ac.soton.bsharp.bSharp.impl.BSClassImpl#getWhere <em>Where</em>}</li>
 * </ul>
 */
public class BSClassImpl extends ClassDeclImpl implements BSClass {
	/**
	 * The cached value of the '{@link #getSupertypes() <em>Supertypes</em>}' containment reference.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see #getSupertypes()
	 * @generated
	 * @ordered
	 */
	protected SuperTypeList supertypes;

	/**
	 * The cached value of the '{@link #getVarList() <em>Var List</em>}' containment reference.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see #getVarList()
	 * @generated
	 * @ordered
	 */
	protected TypedVariableList varList;

	/**
	 * The cached value of the '{@link #getWhere() <em>Where</em>}' containment reference.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see #getWhere()
	 * @generated
	 * @ordered
	 */
	protected Where where;

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	protected BSClassImpl() {
		super();
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	protected EClass eStaticClass() {
		return BSharpPackage.Literals.BS_CLASS;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public SuperTypeList getSupertypes() {
		return supertypes;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public NotificationChain basicSetSupertypes(SuperTypeList newSupertypes, NotificationChain msgs) {
		SuperTypeList oldSupertypes = supertypes;
		supertypes = newSupertypes;
		if (eNotificationRequired()) {
			ENotificationImpl notification = new ENotificationImpl(this, Notification.SET, BSharpPackage.BS_CLASS__SUPERTYPES, oldSupertypes, newSupertypes);
			if (msgs == null) msgs = notification; else msgs.add(notification);
		}
		return msgs;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setSupertypes(SuperTypeList newSupertypes) {
		if (newSupertypes != supertypes) {
			NotificationChain msgs = null;
			if (supertypes != null)
				msgs = ((InternalEObject)supertypes).eInverseRemove(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.BS_CLASS__SUPERTYPES, null, msgs);
			if (newSupertypes != null)
				msgs = ((InternalEObject)newSupertypes).eInverseAdd(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.BS_CLASS__SUPERTYPES, null, msgs);
			msgs = basicSetSupertypes(newSupertypes, msgs);
			if (msgs != null) msgs.dispatch();
		}
		else if (eNotificationRequired())
			eNotify(new ENotificationImpl(this, Notification.SET, BSharpPackage.BS_CLASS__SUPERTYPES, newSupertypes, newSupertypes));
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public TypedVariableList getVarList() {
		return varList;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public NotificationChain basicSetVarList(TypedVariableList newVarList, NotificationChain msgs) {
		TypedVariableList oldVarList = varList;
		varList = newVarList;
		if (eNotificationRequired()) {
			ENotificationImpl notification = new ENotificationImpl(this, Notification.SET, BSharpPackage.BS_CLASS__VAR_LIST, oldVarList, newVarList);
			if (msgs == null) msgs = notification; else msgs.add(notification);
		}
		return msgs;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setVarList(TypedVariableList newVarList) {
		if (newVarList != varList) {
			NotificationChain msgs = null;
			if (varList != null)
				msgs = ((InternalEObject)varList).eInverseRemove(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.BS_CLASS__VAR_LIST, null, msgs);
			if (newVarList != null)
				msgs = ((InternalEObject)newVarList).eInverseAdd(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.BS_CLASS__VAR_LIST, null, msgs);
			msgs = basicSetVarList(newVarList, msgs);
			if (msgs != null) msgs.dispatch();
		}
		else if (eNotificationRequired())
			eNotify(new ENotificationImpl(this, Notification.SET, BSharpPackage.BS_CLASS__VAR_LIST, newVarList, newVarList));
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public Where getWhere() {
		return where;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public NotificationChain basicSetWhere(Where newWhere, NotificationChain msgs) {
		Where oldWhere = where;
		where = newWhere;
		if (eNotificationRequired()) {
			ENotificationImpl notification = new ENotificationImpl(this, Notification.SET, BSharpPackage.BS_CLASS__WHERE, oldWhere, newWhere);
			if (msgs == null) msgs = notification; else msgs.add(notification);
		}
		return msgs;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public void setWhere(Where newWhere) {
		if (newWhere != where) {
			NotificationChain msgs = null;
			if (where != null)
				msgs = ((InternalEObject)where).eInverseRemove(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.BS_CLASS__WHERE, null, msgs);
			if (newWhere != null)
				msgs = ((InternalEObject)newWhere).eInverseAdd(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.BS_CLASS__WHERE, null, msgs);
			msgs = basicSetWhere(newWhere, msgs);
			if (msgs != null) msgs.dispatch();
		}
		else if (eNotificationRequired())
			eNotify(new ENotificationImpl(this, Notification.SET, BSharpPackage.BS_CLASS__WHERE, newWhere, newWhere));
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs) {
		switch (featureID) {
			case BSharpPackage.BS_CLASS__SUPERTYPES:
				return basicSetSupertypes(null, msgs);
			case BSharpPackage.BS_CLASS__VAR_LIST:
				return basicSetVarList(null, msgs);
			case BSharpPackage.BS_CLASS__WHERE:
				return basicSetWhere(null, msgs);
		}
		return super.eInverseRemove(otherEnd, featureID, msgs);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public Object eGet(int featureID, boolean resolve, boolean coreType) {
		switch (featureID) {
			case BSharpPackage.BS_CLASS__SUPERTYPES:
				return getSupertypes();
			case BSharpPackage.BS_CLASS__VAR_LIST:
				return getVarList();
			case BSharpPackage.BS_CLASS__WHERE:
				return getWhere();
		}
		return super.eGet(featureID, resolve, coreType);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public void eSet(int featureID, Object newValue) {
		switch (featureID) {
			case BSharpPackage.BS_CLASS__SUPERTYPES:
				setSupertypes((SuperTypeList)newValue);
				return;
			case BSharpPackage.BS_CLASS__VAR_LIST:
				setVarList((TypedVariableList)newValue);
				return;
			case BSharpPackage.BS_CLASS__WHERE:
				setWhere((Where)newValue);
				return;
		}
		super.eSet(featureID, newValue);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public void eUnset(int featureID) {
		switch (featureID) {
			case BSharpPackage.BS_CLASS__SUPERTYPES:
				setSupertypes((SuperTypeList)null);
				return;
			case BSharpPackage.BS_CLASS__VAR_LIST:
				setVarList((TypedVariableList)null);
				return;
			case BSharpPackage.BS_CLASS__WHERE:
				setWhere((Where)null);
				return;
		}
		super.eUnset(featureID);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public boolean eIsSet(int featureID) {
		switch (featureID) {
			case BSharpPackage.BS_CLASS__SUPERTYPES:
				return supertypes != null;
			case BSharpPackage.BS_CLASS__VAR_LIST:
				return varList != null;
			case BSharpPackage.BS_CLASS__WHERE:
				return where != null;
		}
		return super.eIsSet(featureID);
	}

	public Collection<EObject> getVariablesNames() {		
		ArrayList<EObject> result = new ArrayList<EObject>();
		
		result.add(this);
		if (varList == null) {
			return result;
		}
		
		result.addAll(EcoreUtil2.getAllContentsOfType(varList, TypedVariable.class));
		return result;
	}
	
	protected IProgressMonitor nullMonitor = new NullProgressMonitor();
	

	
	/* This get's the number of polymorhic types required to construct the type class */
	public Integer eventBRequiredPolyTypes() {
		if (context != null) {
			return context.eventBPolyVarCount();
		} else if (supertypes != null) {
			/* The polyContext is inferred from the supertype. */
			ConstructedType superclass = supertypes.getFirst();
			if (superclass == null)
				return 1;
			
			BSClass sup = (BSClass)((TypeConstructor)superclass).getTypeName();
			return sup.eventBRequiredPolyTypes();
		}
		
		return 1;
	}
	
	@Override
	public void compile() throws Exception {
		compileOp();
		compileGetterOperators();
	}
	
	/* Compiles the operator used to create an instance of this type class. */
	public void compileOp() throws Exception {
		/*TODO: document this method working through a couple of event B examples to show 
		 * how and where they are compiled. Maybe Monoid and TransitiveOp.
		 */
		TheoryImportCache thyCache = CompilationUtil.getTheoryCacheForElement(this);
		
		INewOperatorDefinition op;
		try {
			op = TheoryUtils.createOperator(thyCache.theory,
					eventBolymorphicTypeConstructorName(), false, false, FormulaType.EXPRESSION, Notation.PREFIX, null, nullMonitor);
		} catch (Exception e) {
			System.err.println(" Unable to crate EventB operator " + e.getLocalizedMessage());
			return;
		}
		
		/* This creates the type variables for the EventB operator and creates arguments on
		 * the EventB operator so these type variables can then be used.
		 */
		ArrayList<Tuple2<String, String>> polyTypedVars = null;
		if (context != null) {
			polyTypedVars = context.namesAndTypesForPolyContext();
			try {
				CompilationUtil.compileTypedVariablesToOperatorArgs(polyTypedVars, op);
			} catch (Exception e) {
				System.err.println("In BSClassImpl compileOp() couldn't compile the poly context with error: " + e.getLocalizedMessage());
			}
		}
		
		String instName = constructionInstName();
		
		String opString = "{ " + instName;
		
		ArrayList<Tuple2<String, String>> typedVars = null;
		if (varList != null) {
			typedVars = varList.getCompiledVariablesAndTypes();
			opString += CompilationUtil.compileTypedVariablesToNameListWithSeparator(typedVars, " ↦ ", false);
		}
		
		opString += " | ";
		
		EList<TypeBuilder> supertypeList = null;
		if (supertypes != null) {
			supertypeList = supertypes.getSuperTypes();
		}
		
		ArrayList<Tuple2<String, String>> inferredTypes = null;
		if (supertypeList != null && !supertypeList.isEmpty()) {
			Boolean first = true;
			for (TypeBuilder constType : supertypeList) {
				if (!first) {
					opString += " ∩ ";
				} else {
					opString += instName + " ∈ ";
					first = false;
				}
				
				
				int inferredTypeCount = constType.inferredTypeCount();
				if (inferredTypeCount != 0) {
					/* We shouldn't be inferring types if there are declared types. */
					if (context != null && context.polyTypesCount() != 0)
						throw new Exception("Classes which infer types should not also have polyTypes," +
								"this should be checked for during validation");
					
					if (inferredTypes == null) {
						inferredTypes = new ArrayList<Tuple2<String, String>>();

						/*
						 * This adds extra inferred types to the inferredTypes array. if there aren't
						 * enough inferred types it adds extra, I'm not sure this is a possible
						 * situation, as I think we should validate against it.
						 */
						for (int i = inferredTypes.size(); i < inferredTypeCount; ++i) {
							// As there aren't any types in the polytype variable I can name these whatever
							// I like
							String inferredTypeName = "Ty" + String.valueOf(i);
							String eventBTypeParamName = "ℙ(" + thyCache.getEventBTypeParamNameForName(inferredTypeName) + ")";

							TheoryUtils.createArgument(op, inferredTypeName, eventBTypeParamName, null,
									nullMonitor);

							inferredTypes.add(new Tuple2<String, String>(inferredTypeName, eventBTypeParamName));
						}
					}
					
					/* If there are inferred types there should be no constructed types, and the 
					 * constructors for the inferred types should all require the same polymorphic
					 * arguments.
					 */
					TypeConstructor supertype = (TypeConstructor)constType;
					opString += ((ClassDecl)supertype).eventBolymorphicTypeConstructorName();
					opString += "(" + CompilationUtil.compileTypedVariablesToNameListWithSeparator(inferredTypes, ", ", true) + ")";
				} else {
					opString += constType.buildEventBType();
				}
			}
		}
		
		if (typedVars != null) {
			opString += CompilationUtil.compileTypedVaribalesToTypedList(typedVars, false);
		}
		
		if (where != null) {
			String whereString = where.compileToEventBPredStatements();
			if (whereString != null && !whereString.isEmpty()) {
				opString += " ∧ (" + whereString + ")";
			}
		}
		
		
		opString += "}";
		TheoryUtils.createDirectDefinition(op, opString, null, nullMonitor);
	}
	
	
	@Override
	public ArrayList<String>  getterOperatorSuffixes() {
		/* Get the complete list of operator suffixes from the super type, then append the operator 
		 * suffixes from this type.
		 */
		
		ArrayList<String> result = new ArrayList<String>();
		if (supertypes != null) {
			Collection<TypeBuilder> sTypes = supertypes.getSuperTypes();
			if (sTypes != null && !sTypes.isEmpty()) {
				TypeBuilder sup = sTypes.iterator().next();
				
				if (sup.isAbstractTypeClass()) {
					result.addAll(sup.getTypeClass().getterOperatorSuffixes());
				}
			}
		}
		
		if (varList != null) {
			ArrayList<Tuple2<String, String>> typedVars = varList.getCompiledVariablesAndTypes();
			
			for (Tuple2<String, String> typedVar : typedVars) {
				result.add("_" + typedVar.x);
			}
		}
		
		return result;
	}
	
	/* The typed list of arguments required to construct an entirely generic instance of
	 * this type. Does not include the construction of the type itself.
	 */
	@Override
	public ArrayList<Tuple2<String, String>> polyArgumentsToConstructGenericTypeClass () throws Exception {
		if (context != null) {
			return context.namesAndTypesForPolyContext();
		}
		
		if (supertypes == null) {
			throw new Exception("Type class declared without any sort of supertype");
		}
		
		Collection<TypeBuilder> sTypes = supertypes.getSuperTypes();
		if (sTypes == null || sTypes.isEmpty()) {
			throw new Exception("Type class declared without any sort of supertype");
		}
		
		TypeBuilder sup = sTypes.iterator().next();
		
		if (!sup.isAbstractTypeClass())
			throw new Exception("Type class declared without any sort of supertype");
		
		BSClass superClass = sup.getTypeClass();
		ArrayList<Tuple2<String, String>> result = superClass.polyArgumentsToConstructGenericTypeClass();
		
		return result;
	}
	
	@Override
	public ArrayList<Tuple2<String, String>> typedConstructionArgs() {
		ArrayList<Tuple2<String, String>> result;
		
		try {
			result = polyArgumentsToConstructGenericTypeClass();
		} catch (Exception e) {
			//TODO: Validation against this.
			System.err.println("Illegal type declaration, this should be validataed against.");
			return null;
		}
		
		String argsForConstructor = "(" + CompilationUtil.compileTypedVariablesToNameListWithSeparator(result, ", ", true);
		result.add(new Tuple2<String, String>(name, eventBolymorphicTypeConstructorName() + argsForConstructor));
		
		return result;
	}
	
	INewOperatorDefinition constructOpForGetterWithName(String n) {
		TheoryImportCache thyCache = CompilationUtil.getTheoryCacheForElement(this);
		INewOperatorDefinition op;
		
		try {
			op = TheoryUtils.createOperator(thyCache.theory,
					n, false, false, FormulaType.EXPRESSION, Notation.PREFIX, null, nullMonitor);
		} catch (Exception e) {
			System.err.println("Unable to crate EventB operator " + e.getLocalizedMessage());
			return null;
		}
		
		ArrayList<Tuple2<String, String>> polyArgs = typedConstructionArgs();
		
		for (Tuple2<String, String> typedVar : polyArgs) {
			try {
				TheoryUtils.createArgument(op, typedVar.x, typedVar.y, null,
						nullMonitor);
			} catch (Exception e) {
				System.err.println("Unable to create argument for operator op: " + n + " arg: " + typedVar.x + ":" + typedVar.y);
			}
		}
		
		return op;
	}
	
	public void compileGetterOperators() {
		/* I think that I'm going to use Event-B operators to pass getters onto subtypes. 
		 * This makes coding simpler. The supertype is always at prj1. of the type. */
		if (supertypes != null) {
			Collection<TypeBuilder> sTypes = supertypes.getSuperTypes();
			
			if (sTypes != null && !sTypes.isEmpty()) {
				TypeBuilder sup = sTypes.iterator().next();
				
				if (sup.isAbstractTypeClass()) {
					BSClass sType = sup.getTypeClass();
					ArrayList<String> suffixes = sType.getterOperatorSuffixes();
					
					for (String suffix : suffixes) {
						INewOperatorDefinition op = constructOpForGetterWithName(name + suffix);
						try {
							TheoryUtils.createDirectDefinition(op, sType.getName() + suffix + "(prj1(" + name + "))", 
									null, nullMonitor);
						} catch (Exception e) {
							System.err.println("Unable to create direct definition for getter op with erorr: " + e.getLocalizedMessage());
						}
						
					}
				}
			}
		}
		
		if (varList != null) {
			ArrayList<Tuple2<String, String>> varListVariables = varList.getCompiledVariablesAndTypes();
			Integer prj2sRequired = 1;
			Integer lastNdx = varListVariables.size() - 1;
			for (Tuple2<String, String> typedVar : varListVariables) {
				INewOperatorDefinition op = constructOpForGetterWithName(name + "_" + typedVar.x);
				
				String directDefString = "";
				Integer neededCloseBrackets = prj2sRequired;
				for (int i = 0; i < prj2sRequired; ++i) {
					directDefString += "prj2(";
				}
				
				if (varListVariables.indexOf(typedVar) !=  lastNdx) {
					directDefString += "prj1(";
					++neededCloseBrackets;
				}
				
				directDefString += name;
				
				for (int i = 0; i < neededCloseBrackets; ++i) {
					directDefString += ")";
				}
				
				try {
					TheoryUtils.createDirectDefinition(op, directDefString, 
							null, nullMonitor);
				} catch (Exception e) {
					System.err.println("Unable to create direct definition for getter op with erorr: " + e.getLocalizedMessage());
				}
			}
		}
	}
	
	@Override
	public Boolean isTypeClass() {
		if (varList != null) {
			if (varList.getCompiledVariablesAndTypes().size() != 0) {
				return true;
			}
		}
		
		if (supertypes != null) {
			Collection<TypeBuilder> sTypes = supertypes.getSuperTypes();
			
			if (sTypes != null && !sTypes.isEmpty()) {
				TypeBuilder sup = sTypes.iterator().next();
				return sup.isAbstractTypeClass();
			}
		}
		
		return false;
	}
	
	@Override
	public String constructionInstName() {
		return name + "Inst";
	}
	
	/* The name for the EventB operator used to construct entirely polymorphic instances of the type. */
	@Override
	public String eventBolymorphicTypeConstructorName() {
		return name + "_T";
	}
	
	/* This takes components to construct the type, e.g. to construct a monoid it'd be Monoid_C(T : T, set : Setoid)
	 * this is what is used if a type is constructed with a given context. */
	@Override
	public String eventBTypeConstructorFromTypes() {
		if (isTypeClass()) {
			return name + "_C";
		}
		
		return eventBolymorphicTypeConstructorName();
	}

	@Override
	public String constructWithTypeContext(TypeDeclContext ctx) {
		if (context == null)
			return "()";
		
		String result = eventBTypeConstructorFromTypes() + "(";
		try {
			result += context.compileCallWithTypeContext(ctx);
		} catch (Exception e) {
			System.err.print(e.getLocalizedMessage());
		}
		
		result += ")";
		
		return result;
	}

	@Override
	public String eventBPrefix() {
		// TODO Change this when user defined prefixes are added.
		return name;
	}
	
} //BppClassImpl
