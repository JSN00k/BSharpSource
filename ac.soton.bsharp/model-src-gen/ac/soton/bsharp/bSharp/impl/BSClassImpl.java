/**
 * generated by Xtext 2.14.0
 */
package ac.soton.bsharp.bSharp.impl;

import ac.soton.bsharp.bSharp.BSharpPackage;
import ac.soton.bsharp.bSharp.ClassDecl;
import ac.soton.bsharp.bSharp.ConstructedType;
import ac.soton.bsharp.bSharp.Datatype;
import ac.soton.bsharp.bSharp.Expression;
import ac.soton.bsharp.bSharp.ExpressionVariable;
import ac.soton.bsharp.bSharp.FuncCallArgs;
import ac.soton.bsharp.bSharp.FunctionCall;
import ac.soton.bsharp.bSharp.FunctionDecl;
import ac.soton.bsharp.bSharp.IClassInstance;
import ac.soton.bsharp.bSharp.InstName;
import ac.soton.bsharp.bSharp.Instance;
import ac.soton.bsharp.bSharp.PolyContext;
import ac.soton.bsharp.bSharp.PolyType;
import ac.soton.bsharp.bSharp.BSClass;
import ac.soton.bsharp.bSharp.BSharpFactory;
import ac.soton.bsharp.bSharp.SuperTypeList;
import ac.soton.bsharp.bSharp.TheoremDecl;
import ac.soton.bsharp.bSharp.TypeBuilder;
import ac.soton.bsharp.bSharp.TypeConstructor;
import ac.soton.bsharp.bSharp.TypeDeclContext;
import ac.soton.bsharp.bSharp.TypePowerSet;
import ac.soton.bsharp.bSharp.TypedVariable;
import ac.soton.bsharp.bSharp.TypedVariableList;
import ac.soton.bsharp.bSharp.Where;
import ac.soton.bsharp.bSharp.util.CompilationUtil;
import ac.soton.bsharp.bSharp.util.Tuple2;
import ac.soton.bsharp.mapletTree.IMapletNode;
import ac.soton.bsharp.mapletTree.MapletExpressionVariableLeaf;
import ac.soton.bsharp.mapletTree.MapletStringLeaf;
import ac.soton.bsharp.mapletTree.MapletTree;
import ac.soton.bsharp.theory.util.TheoryImportCache;
import ac.soton.bsharp.theory.util.TheoryUtils;
import ac.soton.bsharp.typeInstanceRepresentation.BSCompTypeInstance;
import ac.soton.bsharp.typeInstanceRepresentation.ConcreteTypeInstance;
import ac.soton.bsharp.typeInstanceRepresentation.ITypeInstance;
import ac.soton.bsharp.typeInstanceRepresentation.ITypeInstanceOpArgs;
import ac.soton.bsharp.typeInstanceRepresentation.MapletTypeInstance;
import ac.soton.bsharp.typeInstanceRepresentation.StringTypeInstance;

import java.security.acl.LastOwnerException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.security.auth.Refreshable;

import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.xtext.EcoreUtil2;
import org.eventb.core.ast.extension.IOperatorProperties.FormulaType;
import org.eventb.core.ast.extension.IOperatorProperties.Notation;
import org.eventb.theory.core.INewOperatorDefinition;

/**
 * <!-- begin-user-doc --> An implementation of the model object '<em><b>Bpp
 * Class</b></em>'. <!-- end-user-doc -->
 * <p>
 * The following features are implemented:
 * </p>
 * <ul>
 * <li>{@link ac.soton.bsharp.bSharp.impl.BSClassImpl#getSupertypes
 * <em>Supertypes</em>}</li>
 * <li>{@link ac.soton.bsharp.bSharp.impl.BSClassImpl#getVarList <em>Var
 * List</em>}</li>
 * <li>{@link ac.soton.bsharp.bSharp.impl.BSClassImpl#getWhere
 * <em>Where</em>}</li>
 * </ul>
 */
public class BSClassImpl extends ClassDeclImpl implements BSClass {
	/**
	 * The cached value of the '{@link #getSupertypes() <em>Supertypes</em>}' containment reference.
	 * <!-- begin-user-doc --> <!-- end-user-doc -->
	 * @see #getSupertypes()
	 * @generated
	 * @ordered
	 */
	protected SuperTypeList supertypes;

	/**
	 * The cached value of the '{@link #getVarList() <em>Var List</em>}' containment reference.
	 * <!-- begin-user-doc --> <!-- end-user-doc -->
	 * @see #getVarList()
	 * @generated
	 * @ordered
	 */
	protected TypedVariableList varList;

	/**
	 * The cached value of the '{@link #getWhere() <em>Where</em>}' containment reference.
	 * <!-- begin-user-doc --> <!-- end-user-doc -->
	 * @see #getWhere()
	 * @generated
	 * @ordered
	 */
	protected Where where;

	/**
	 * The cached value of the '{@link #getInstName() <em>Inst Name</em>}' containment reference.
	 * <!-- begin-user-doc --> <!-- end-user-doc -->
	 * @see #getInstName()
	 * @generated
	 * @ordered
	 */
	protected InstName instName;

	/**
	 * <!-- begin-user-doc --> <!-- end-user-doc -->
	 * @generated
	 */
	protected BSClassImpl() {
		super();
	}

	/**
	 * <!-- begin-user-doc --> <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	protected EClass eStaticClass() {
		return BSharpPackage.Literals.BS_CLASS;
	}

	/**
	 * <!-- begin-user-doc --> <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public SuperTypeList getSupertypes() {
		return supertypes;
	}

	/**
	 * <!-- begin-user-doc --> <!-- end-user-doc -->
	 * @generated
	 */
	public NotificationChain basicSetSupertypes(SuperTypeList newSupertypes, NotificationChain msgs) {
		SuperTypeList oldSupertypes = supertypes;
		supertypes = newSupertypes;
		if (eNotificationRequired()) {
			ENotificationImpl notification = new ENotificationImpl(this, Notification.SET, BSharpPackage.BS_CLASS__SUPERTYPES, oldSupertypes, newSupertypes);
			if (msgs == null) msgs = notification; else msgs.add(notification);
		}
		return msgs;
	}

	/**
	 * <!-- begin-user-doc --> <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public void setSupertypes(SuperTypeList newSupertypes) {
		if (newSupertypes != supertypes) {
			NotificationChain msgs = null;
			if (supertypes != null)
				msgs = ((InternalEObject)supertypes).eInverseRemove(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.BS_CLASS__SUPERTYPES, null, msgs);
			if (newSupertypes != null)
				msgs = ((InternalEObject)newSupertypes).eInverseAdd(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.BS_CLASS__SUPERTYPES, null, msgs);
			msgs = basicSetSupertypes(newSupertypes, msgs);
			if (msgs != null) msgs.dispatch();
		}
		else if (eNotificationRequired())
			eNotify(new ENotificationImpl(this, Notification.SET, BSharpPackage.BS_CLASS__SUPERTYPES, newSupertypes, newSupertypes));
	}

	/**
	 * <!-- begin-user-doc --> <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public TypedVariableList getVarList() {
		return varList;
	}

	/**
	 * <!-- begin-user-doc --> <!-- end-user-doc -->
	 * @generated
	 */
	public NotificationChain basicSetVarList(TypedVariableList newVarList, NotificationChain msgs) {
		TypedVariableList oldVarList = varList;
		varList = newVarList;
		if (eNotificationRequired()) {
			ENotificationImpl notification = new ENotificationImpl(this, Notification.SET, BSharpPackage.BS_CLASS__VAR_LIST, oldVarList, newVarList);
			if (msgs == null) msgs = notification; else msgs.add(notification);
		}
		return msgs;
	}

	/**
	 * <!-- begin-user-doc --> <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public void setVarList(TypedVariableList newVarList) {
		if (newVarList != varList) {
			NotificationChain msgs = null;
			if (varList != null)
				msgs = ((InternalEObject)varList).eInverseRemove(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.BS_CLASS__VAR_LIST, null, msgs);
			if (newVarList != null)
				msgs = ((InternalEObject)newVarList).eInverseAdd(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.BS_CLASS__VAR_LIST, null, msgs);
			msgs = basicSetVarList(newVarList, msgs);
			if (msgs != null) msgs.dispatch();
		}
		else if (eNotificationRequired())
			eNotify(new ENotificationImpl(this, Notification.SET, BSharpPackage.BS_CLASS__VAR_LIST, newVarList, newVarList));
	}

	/**
	 * <!-- begin-user-doc --> <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public Where getWhere() {
		return where;
	}

	/**
	 * <!-- begin-user-doc --> <!-- end-user-doc -->
	 * @generated
	 */
	public NotificationChain basicSetWhere(Where newWhere, NotificationChain msgs) {
		Where oldWhere = where;
		where = newWhere;
		if (eNotificationRequired()) {
			ENotificationImpl notification = new ENotificationImpl(this, Notification.SET, BSharpPackage.BS_CLASS__WHERE, oldWhere, newWhere);
			if (msgs == null) msgs = notification; else msgs.add(notification);
		}
		return msgs;
	}

	/**
	 * <!-- begin-user-doc --> <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public void setWhere(Where newWhere) {
		if (newWhere != where) {
			NotificationChain msgs = null;
			if (where != null)
				msgs = ((InternalEObject)where).eInverseRemove(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.BS_CLASS__WHERE, null, msgs);
			if (newWhere != null)
				msgs = ((InternalEObject)newWhere).eInverseAdd(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.BS_CLASS__WHERE, null, msgs);
			msgs = basicSetWhere(newWhere, msgs);
			if (msgs != null) msgs.dispatch();
		}
		else if (eNotificationRequired())
			eNotify(new ENotificationImpl(this, Notification.SET, BSharpPackage.BS_CLASS__WHERE, newWhere, newWhere));
	}

	/**
	 * <!-- begin-user-doc --> <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public InstName getInstName() {
		return instName;
	}

	/**
	 * <!-- begin-user-doc --> <!-- end-user-doc -->
	 * @generated
	 */
	public NotificationChain basicSetInstName(InstName newInstName, NotificationChain msgs) {
		InstName oldInstName = instName;
		instName = newInstName;
		if (eNotificationRequired()) {
			ENotificationImpl notification = new ENotificationImpl(this, Notification.SET, BSharpPackage.BS_CLASS__INST_NAME, oldInstName, newInstName);
			if (msgs == null) msgs = notification; else msgs.add(notification);
		}
		return msgs;
	}

	/**
	 * <!-- begin-user-doc --> <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public void setInstName(InstName newInstName) {
		if (newInstName != instName) {
			NotificationChain msgs = null;
			if (instName != null)
				msgs = ((InternalEObject)instName).eInverseRemove(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.BS_CLASS__INST_NAME, null, msgs);
			if (newInstName != null)
				msgs = ((InternalEObject)newInstName).eInverseAdd(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.BS_CLASS__INST_NAME, null, msgs);
			msgs = basicSetInstName(newInstName, msgs);
			if (msgs != null) msgs.dispatch();
		}
		else if (eNotificationRequired())
			eNotify(new ENotificationImpl(this, Notification.SET, BSharpPackage.BS_CLASS__INST_NAME, newInstName, newInstName));
	}

	/**
	 * <!-- begin-user-doc --> <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs) {
		switch (featureID) {
			case BSharpPackage.BS_CLASS__SUPERTYPES:
				return basicSetSupertypes(null, msgs);
			case BSharpPackage.BS_CLASS__VAR_LIST:
				return basicSetVarList(null, msgs);
			case BSharpPackage.BS_CLASS__WHERE:
				return basicSetWhere(null, msgs);
			case BSharpPackage.BS_CLASS__INST_NAME:
				return basicSetInstName(null, msgs);
		}
		return super.eInverseRemove(otherEnd, featureID, msgs);
	}

	/**
	 * <!-- begin-user-doc --> <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public Object eGet(int featureID, boolean resolve, boolean coreType) {
		switch (featureID) {
			case BSharpPackage.BS_CLASS__SUPERTYPES:
				return getSupertypes();
			case BSharpPackage.BS_CLASS__VAR_LIST:
				return getVarList();
			case BSharpPackage.BS_CLASS__WHERE:
				return getWhere();
			case BSharpPackage.BS_CLASS__INST_NAME:
				return getInstName();
		}
		return super.eGet(featureID, resolve, coreType);
	}

	/**
	 * <!-- begin-user-doc --> <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public void eSet(int featureID, Object newValue) {
		switch (featureID) {
			case BSharpPackage.BS_CLASS__SUPERTYPES:
				setSupertypes((SuperTypeList)newValue);
				return;
			case BSharpPackage.BS_CLASS__VAR_LIST:
				setVarList((TypedVariableList)newValue);
				return;
			case BSharpPackage.BS_CLASS__WHERE:
				setWhere((Where)newValue);
				return;
			case BSharpPackage.BS_CLASS__INST_NAME:
				setInstName((InstName)newValue);
				return;
		}
		super.eSet(featureID, newValue);
	}

	/**
	 * <!-- begin-user-doc --> <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public void eUnset(int featureID) {
		switch (featureID) {
			case BSharpPackage.BS_CLASS__SUPERTYPES:
				setSupertypes((SuperTypeList)null);
				return;
			case BSharpPackage.BS_CLASS__VAR_LIST:
				setVarList((TypedVariableList)null);
				return;
			case BSharpPackage.BS_CLASS__WHERE:
				setWhere((Where)null);
				return;
			case BSharpPackage.BS_CLASS__INST_NAME:
				setInstName((InstName)null);
				return;
		}
		super.eUnset(featureID);
	}

	/**
	 * <!-- begin-user-doc --> <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public boolean eIsSet(int featureID) {
		switch (featureID) {
			case BSharpPackage.BS_CLASS__SUPERTYPES:
				return supertypes != null;
			case BSharpPackage.BS_CLASS__VAR_LIST:
				return varList != null;
			case BSharpPackage.BS_CLASS__WHERE:
				return where != null;
			case BSharpPackage.BS_CLASS__INST_NAME:
				return instName != null;
		}
		return super.eIsSet(featureID);
	}
	
	protected PolyContext context = null;
	
	@Override
	public PolyContext getContext() {
		if (context != null)
			return context;
		
		if (rawContext !=  null) {
			context = rawContext;
			return context;
		}
		
		SuperTypeList superTypeList = getSupertypes();
		if (superTypeList == null || superTypeList.isEmpty()) {
			return null;
		}
		
		TypeBuilder firstSType = superTypeList.getFirst();
		
		ClassDecl classDecl = firstSType.getClassDecl();
		if (classDecl == null)
			return null;
		
		/* If the super type has an attached context then it has to be complete.
		 * This means that the types must either be declared in context of this
		 * BSClass (in which case we'd have had a raw context and wouldn't have 
		 * got to this point). Or they must be entirely concrete types. In which
		 * case the current type doesn't have a polyContext.
		 */
		TypeDeclContext declContext = ((TypeConstructor)firstSType).getContext();
		if (declContext != null) {
			return null;
		}
		
		context = EcoreUtil2.copy(classDecl.getContext());
		return context;
	}

	public Collection<ExpressionVariable> getVariablesNames() {
		ArrayList<ExpressionVariable> result = new ArrayList<ExpressionVariable>();

		if (instName != null)
			result.add(instName);

		if (varList == null) {
			return result;
		}

		result.addAll(EcoreUtil2.getAllContentsOfType(varList, TypedVariable.class));
		return result;
	}

	protected IProgressMonitor nullMonitor = new NullProgressMonitor();

	/*
	 * This get's the number of polymorhic types required to construct the type
	 * class
	 */
	public Integer eventBRequiredPolyTypes() {
		PolyContext context = getContext();
		if (context == null)
			return 0;
		
		return context.polyTypesCount();
	}

	@Override
	public void compile(IProgressMonitor monitor) throws Exception {
		compileOp();
		compileGetterOperators();
		block.compile(monitor);
	}

	public boolean isNewTypeClass() {
		if (supertypes == null)
			return false;

		EList<TypeBuilder> supers = supertypes.getSuperTypes();
		if (supers.size() != 1)
			return false;

		TypeBuilder sup = supers.get(0);
		if (sup.isAbstractTypeClass())
			return false;

		return varList != null && varList.varCount() != 0;
	}

	protected Integer compiledMatchStatements = 0;

	protected ITypeInstance typeInstance = null;

	/*
	 * Get type instance is used during compilation of the op for the type class. As
	 * a result it actually contains an instance representing the supertype.
	 */
	@Override
	public ITypeInstance getInferredTypeInstance() {
		/*
		 * Changing the way that this works could allow the creation of a constructed
		 * type rather than a destructed type. For now this is a big change, and needs
		 * to be left for latter.
		 */
		return typeInstance;
	}

	/* Compiles the operator used to create an instance of this type class. */
	public void compileOp() throws Exception {
		PolyContext context = getContext();
		compiledMatchStatements = 0;
		/*
		 * TODO: document this method working through a couple of event B examples to
		 * show how and where they are compiled. Maybe Monoid and TransitiveOp.
		 */

		/*
		 * Due to a bug in the EventB language the instance name here is modified with a
		 * '1' The TypeEnvironmentBuilder needs fixing to resolve this issue.
		 */
		String iName = instanceName();
		TheoryImportCache thyCache = CompilationUtil.getTheoryCacheForElement(this);

		INewOperatorDefinition op;
		try {
			op = TheoryUtils.createOperator(thyCache.theory, eventBPolymorphicTypeConstructorName(), false, false,
					FormulaType.EXPRESSION, Notation.PREFIX, null, nullMonitor);
		} catch (Exception e) {
			System.err.println(" Unable to crate EventB operator " + e.getLocalizedMessage());
			return;
		}

		/*
		 * This creates the type variables for the EventB operator and creates arguments
		 * on the EventB operator so these type variables can then be used.
		 */
		ArrayList<Tuple2<String, String>> polyTypedVars = null;
		if (context != null) {
			polyTypedVars = context.namesAndTypesForPolyContext(thyCache);
			try {
				CompilationUtil.compileTypedVariablesToOperatorArgs(polyTypedVars, op);
			} catch (Exception e) {
				System.err.println("In BSClassImpl compileOp() couldn't compile the poly context with error: "
						+ e.getLocalizedMessage());
			}
		}
		
		BSClass superT = supertypes.getFirst().getTypeClass();
		TypedVariableList varList = getVarList();
		if (superT != null || (varList != null && ! varList.isEmpty())) {
			typeInstance = new BSCompTypeInstance(this, polyTypedVars, instanceName(), this);
		} else {
			typeInstance = new StringTypeInstance(this, polyTypedVars, instanceName(), this);
		}

		String opString = "{ " + iName;
		ArrayList<Tuple2<String, String>> typedVars = null;
		if (varList != null) {
			typedVars = varList.getCompiledVariablesAndTypes();
			opString += CompilationUtil.compileTypedVariablesToNameListWithSeparator(typedVars, " ↦ ", false,
					typedVars.size() > 1);
		}

		opString += " ∣ ";
		if (supertypes.isPowerSet())
			opString += iName + "=";
		else
			opString += iName + " ∈ ";

		opString += supertypes.generateSuperTypeString(contextToConstructSuperType());

		if (typedVars != null) {
			opString += CompilationUtil.compileTypedVaribalesToTypedList(typedVars, false);
		}

		if (where != null) {
			String whereString = where.compileToEventBPredStatements();
			if (whereString != null && !whereString.isEmpty()) {
				opString += " ∧ (" + whereString + ")";
			}
		}

		opString += "}";
		TheoryUtils.createDirectDefinition(op, opString, null, nullMonitor);
	}
	
	TypeDeclContext contextToConstructSuperType() {
		PolyContext context = getContext();
		
		if (context == null || context.isEmpty())
			return null;
		
		TypeDeclContext result = BSharpFactory.eINSTANCE.createTypeDeclContext();
		List<TypeBuilder> wrappedPolyTypes = result.getTypeName();
		
		for (PolyType pt : context.getPolyTypes()) {
			TypeConstructor tc = BSharpFactory.eINSTANCE.createTypeConstructor();
			tc.setTypeName(pt);
			wrappedPolyTypes.add(tc);
		}
		
		return result;
	}

	@Override
	public ArrayList<String> getterOperatorNames() {
		/*
		 * Get the complete list of operator suffixes from the super type, then append
		 * the operator suffixes from this type.
		 */

		ArrayList<String> result = new ArrayList<String>();
		if (supertypes != null) {
			Collection<TypeBuilder> sTypes = supertypes.getSuperTypes();
			if (sTypes != null && !sTypes.isEmpty()) {
				TypeBuilder sup = sTypes.iterator().next();

				if (sup.isAbstractTypeClass()) {
					result.addAll(sup.getTypeClass().getterOperatorNames());
				}
			}
		}

		if (varList != null) {
			List<String> typedVars = varList.getVariableNames();

			for (String typedVar : typedVars) {
				result.add(typedVar);
			}
		}

		return result;
	}

	/*
	 * The typed list of arguments required to construct an entirely generic
	 * instance of this type. Does not include the construction of the type itself.
	 */
	@Override
	public ArrayList<Tuple2<String, String>> polyArgumentsToConstructGenericTypeClass(TheoryImportCache theoryCache)
			throws Exception {
		PolyContext context = getContext();
		
		TheoryImportCache thyCache = null;
		if (theoryCache == null) {
			thyCache = CompilationUtil.getTheoryCacheForElement(this);
		} else {
			thyCache = theoryCache;
		}

		if (context == null)
			return new ArrayList<Tuple2<String,String>>();
		else
			return context.namesAndTypesForPolyContext(thyCache);

//		if (supertypes == null) {
//			throw new Exception("Type class declared without any sort of supertype");
//		}
//
//		Collection<TypeBuilder> sTypes = supertypes.getSuperTypes();
//		if (sTypes == null || sTypes.isEmpty()) {
//			throw new Exception("Type class declared without any sort of supertype");
//		}
//
//		TypeBuilder sup = sTypes.iterator().next();
//
//		if (!sup.isAbstractTypeClass())
//			throw new Exception("Type class declared without any sort of supertype");
//
//		BSClass superClass = sup.getTypeClass();
//		ArrayList<Tuple2<String, String>> result = superClass.polyArgumentsToConstructGenericTypeClass(thyCache);
//
//		return result;
	}

	@Override
	public ITypeInstanceOpArgs genericTypeInstance(EObject context) {
		TheoryImportCache thyCache = CompilationUtil.getTheoryCacheForElement(context);
		ArrayList<Tuple2<String, String>> typeConstructors;

		try {
			typeConstructors = polyArgumentsToConstructGenericTypeClass(thyCache);
		} catch (Exception e) {
			// TODO: Validation against this.
			System.err.println("Illegal type declaration, this should be validataed against.");
			return null;
		}

		IMapletNode mappedVariables = mappedVariables(typeConstructors.get(typeConstructors.size() - 1).x);
		if (mappedVariables == null) {
			String argsForConstructor = "("
					+ CompilationUtil.compileTypedVariablesToNameListWithSeparator(typeConstructors, ", ", true) + ")";
			typeConstructors.add(new Tuple2<String, String>(instanceName(),
					eventBPolymorphicTypeConstructorName() + argsForConstructor));
		}

		StringTypeInstance res = new StringTypeInstance(this, typeConstructors, instanceName(), context);
		res.setIsInferredTypeInst(true);

		return res;
	}

	/*
	 * Only the variables from this declaration, does not include variables from the
	 * supertypes.
	 */
	public IMapletNode localMappedVars() {
		TypedVariableList vl = getVarList();
		if (vl == null || vl.isEmpty())
			return null;

		ArrayList<TypedVariable> typedVars = vl.getTypedVariables();
		boolean first = true;
		IMapletNode c = null;
		for (TypedVariable tv : typedVars) {
			if (first) {
				c = new MapletStringLeaf(tv.getName());
				first = false;
				continue;
			}

			c = new MapletTree(c, new MapletStringLeaf(tv.getName()));
		}

		return c;
	}

	public IMapletNode mappedVariables(String superTypeString) {
		BSClass superT = supertypes.getFirst().getTypeClass();
		IMapletNode superVars = null;

		if (superT != null)
			superVars = ((BSClassImpl) superT).mappedVariables(superTypeString);

		IMapletNode myVars = localMappedVars();

		if (myVars == null && superVars == null) {
			/*
			 * The current type is a subtype of a constructed type class with no variables
			 * of its own.
			 */
			return null;
		}

		if (myVars == null)
			return superVars;

		if (superVars == null) {
			superVars = new MapletStringLeaf(superTypeString);
		}

		return new MapletTree(superVars, myVars);
	}

	/*
	 * This is currently used by theorems to generate the inferred type arguments.
	 * It currently can't be used in methods as elements are not stored in an
	 * individually typed way.
	 */
	@Override
	public ITypeInstance deconstructedTypeInstance(EObject context, String instName) {
		TheoryImportCache thyCache = CompilationUtil.getTheoryCacheForElement(context);
		ArrayList<Tuple2<String, String>> typeConstructors;

		try {
			typeConstructors = polyArgumentsToConstructGenericTypeClass(thyCache);
		} catch (Exception e) {
			// TODO: Validation against this.
			System.err.println("Illegal type declaration, this should be validataed against.");
			e.printStackTrace();
			return null;
		}

		IMapletNode mappedVariables = mappedVariables(baseType().buildEventBType());

		if (mappedVariables == null) {
			String argsForConstructor = "("
					+ CompilationUtil.compileTypedVariablesToNameListWithSeparator(typeConstructors, ", ", true) + ")";
			typeConstructors.add(new Tuple2<String, String>(instanceName(),
					eventBPolymorphicTypeConstructorName() + argsForConstructor));
		}

		MapletTypeInstance res = new MapletTypeInstance(this, typeConstructors, mappedVariables, context);
		res.setIsInferredTypeInst(true);
		return res;
	}
	
	@Override
	public TypeBuilder baseTypeForTypeDeclarationContext(TypeDeclContext tdContext) {
		PolyContext ctx = getContext();
		
		if (ctx == null || ctx.isEmpty()) {
			if (tdContext != null && !tdContext.isEmpty()) {
				try {
					throw new Exception("Variables in type declaration context don't match variables in polyContext");
				} catch (Exception e) {
					System.err.println("Variables in type declaration context don't match variables in polyContext");
					e.printStackTrace();
					return null;
				}
			}
			
			SuperTypeList superTypes = getSupertypes();
			if (superTypes == null || superTypes.isEmpty()) {
				try {
					throw new Exception("Type Class has no supertype");
				} catch (Exception e) {
					System.err.println("Type Class has no supertype");
					e.printStackTrace();
					return null;
				}
			}
				
			TypeConstructor tc = (TypeConstructor) superTypes.getFirst();
			TypeDeclContext tdc = tc.getContext();
			ClassDecl classDecl = tc.getClassDecl();
			return classDecl.baseTypeForTypeDeclarationContext(tdc);
		}
		
		TypeBuilder baseType = baseType().reorderTypeTree();
		List<PolyType> polyTypes = ctx.getPolyTypes();
		List<TypeBuilder> concreteTypes = tdContext.getTypeName();
		int tdContextSize = concreteTypes.size();
		int ctxSize = polyTypes.size();
		if (ctxSize != tdContextSize) {
			try {
				throw new Exception("Variables in type declaration context don't match variables in polyContext");
			} catch (Exception e) {
				System.err.println("Variables in type declaration context don't match variables in polyContext");
				e.printStackTrace();
				return null;
			}
		}
		
		HashMap<PolyType, TypeBuilder> typeMap = new HashMap<PolyType, TypeBuilder>();
		for(int i = 0; i < tdContextSize; ++i) {
			typeMap.put(polyTypes.get(i), concreteTypes.get(i));
		}

		TypeBuilder varReplaced = baseType.copyWithConcreteTypes(typeMap);
		return varReplaced;
	}

	INewOperatorDefinition constructOpForGetterWithName(String n) {
		TheoryImportCache thyCache = CompilationUtil.getTheoryCacheForElement(this);
		INewOperatorDefinition op;

		try {
			op = TheoryUtils.createOperator(thyCache.theory, n, false, false, FormulaType.EXPRESSION, Notation.PREFIX,
					null, nullMonitor);
		} catch (Exception e) {
			System.err.println("Unable to crate EventB operator " + e.getLocalizedMessage());
			return null;
		}

		ArrayList<Tuple2<String, String>> polyArgs = genericTypeInstance(this).individuallyTypedConstructionArgs();

		for (Tuple2<String, String> typedVar : polyArgs) {
			try {
				TheoryUtils.createArgument(op, typedVar.x, typedVar.y, null, nullMonitor);
			} catch (Exception e) {
				System.err.println(
						"Unable to create argument for operator op: " + n + " arg: " + typedVar.x + ":" + typedVar.y);
			}
		}

		return op;
	}

	@Override
	public String getterForOpName(String opName) {
		return name + "_" + opName;
	}
	
	protected HashMap<String, ArrayList<Integer>> prjMapForOpName = null;
	HashMap<String, ArrayList<Integer>> localProjectionsforOpNameMap() {
		if (prjMapForOpName != null)
			return prjMapForOpName;
		
		prjMapForOpName = new HashMap<String, ArrayList<Integer>>();
		TypedVariableList varList = getVarList();
		if (varList == null) {
			return prjMapForOpName;
		}
		
		List<String> varListVariables = varList.getVariableNames();
		Integer varsCount = varListVariables.size();
		Integer prj1sRequired = varsCount - 1;
		Boolean isFirst = true;
		for (String varName : varListVariables) {
			ArrayList<Integer> prjs = new ArrayList<Integer>();
			
			if (!isFirst) {
				prjs.add(2);
			}
			
			isFirst = false;
			for (int i = 0; i < prj1sRequired; ++i) {
				prjs.add(1);
			}
			
			prj1sRequired--;
			prjs.add(2);
			
			prjMapForOpName.put(varName, prjs);
		}
		
		return prjMapForOpName;
	}
	
	String wrapStringInPrjs(String t, List<Integer> prjs) {
		String result = "";
		for (Integer i : prjs) {
			result += "prj" + i.toString() + "(";
		}
		
		result += t;
		
		for (int i = 0; i < prjs.size(); ++i) {
			result += ")";
		}
		
		return result;
	}
	
	@Override
	public String wrapInstInPrjsForOpWithName (String inst, String opName){
		Map<String, ArrayList<Integer>> prjMap = localProjectionsforOpNameMap();
		if (prjMap.containsKey(opName)) {
			return wrapStringInPrjs(inst, prjMap.get(opName));
		} else {
			Collection<TypeBuilder> sTypes = supertypes.getSuperTypes();
			TypeBuilder sup = sTypes.iterator().next();
			BSClass sType = sup.getTypeClass();
			
			TypedVariableList varList = getVarList();
			if (varList == null || varList.count() == 0) {
				/* If there are no required elements then the structure is directly inherited from the supertype,
				 * and there is no need to access the supertype with a call of prj1.
				 */
				return sType.wrapInstInPrjsForOpWithName(inst, opName);
			}
			
			return  sType.wrapInstInPrjsForOpWithName("prj1(" + inst + ")", opName);
		}
	}
	
	public void compileGetterOperators() {
		List<String> ops = getterOperatorNames();
		String iName = instanceName();
		
		for (String opName : ops) {
			INewOperatorDefinition op = constructOpForGetterWithName(getterForOpName(opName));
			
			try {
				TheoryUtils.createDirectDefinition(op, wrapInstInPrjsForOpWithName(iName, opName), null, nullMonitor);
			} catch (Exception e) {
				System.err.println(
						"Unable to create direct definition for getter op with erorr: " + e.getLocalizedMessage());
			}
		}
	}
	
	@Override
	public List<Integer> prjsForTypedVariable(TypedVariable typedVariable) {
		Map<String, ArrayList<Integer>> prjMap = localProjectionsforOpNameMap();
		return prjMap.get(typedVariable.getName());
	}

	@Override
	public Boolean isTypeClass() {
		if (varList != null) {
			if (varList.getCompiledVariablesAndTypes().size() != 0) {
				return true;
			}
		}

		if (supertypes != null) {
			Collection<TypeBuilder> sTypes = supertypes.getSuperTypes();

			if (sTypes != null && !sTypes.isEmpty()) {
				TypeBuilder sup = sTypes.iterator().next();
				return sup.isAbstractTypeClass();
			}
		}

		return false;
	}

	@Override
	public String instanceName() {
		return instName.getName();
	}

	/*
	 * The name for the EventB operator used to construct entirely polymorphic
	 * instances of the type.
	 */
	@Override
	public String eventBPolymorphicTypeConstructorName() {
		return name;
	}

	@Override
	public String constructWithTypeContext(TypeDeclContext ctx) {
		//Use This to solve the porblem.
		PolyContext context = getContext();


		String result = eventBPolymorphicTypeConstructorName();
		
		if (context == null)
			return "()";

		try {
			result += context.compileCallWithTypeContext(ctx);
		} catch (Exception e) {
			System.err.print(e.getLocalizedMessage());
		}

		return result;
	}
	
	@Override
	public String constructWithTypeInstances(List<ITypeInstance> instList) {
		PolyContext context = getContext();
		if (context == null) {
			return eventBPolymorphicTypeConstructorName() + "()";
		}
		
		String result = eventBPolymorphicTypeConstructorName();
		
		result += context.compileEventBTypeConstructorArguments(instList);
		return result;
	}
	
	/* ---------------------------------------------------------------------
	 * Implements IVarType:
	 *  Operators to use when the type class is used in a functional
	 * way. I think this includes when the inferred instance of the type class
	 * is used
	 * ---------------------------------------------------------------------
	 */
	
	@Override
	public String evBSeparatorForFunc() {
		return " ↦ ";
	}

	@Override
	public String getEventBFunctypeForCall(FunctionCall fc) throws Exception{
		PolyContext context = getContext();
		TypeDeclContext ctx = fc.getContext();
		List<FuncCallArgs> argumentBlocks = fc.getFuncCallArgs();
		boolean noArgs = argumentBlocks == null || argumentBlocks.isEmpty();
		String result;
		
		if (ctx == null && noArgs) {
			return eventBPolymorphicTypeConstructorName();
		}
		
		if (ctx != null) {
			result = eventBPolymorphicTypeConstructorName() + context.compileCallWithTypeContext(ctx);
		} else {
			if (EcoreUtil2.getContainerOfType(fc, TheoremDecl.class) != null
					|| EcoreUtil2.getContainerOfType(fc, FunctionDecl.class) != null)
				result = eventBPolymorphicTypeConstructorName();
			else {
				/* We need to know about the type this was referenced from. */
				BSClass containingClass = EcoreUtil2.getContainerOfType(fc, BSClass.class);

				if (containingClass != null && containingClass == this) {
					/* Due to a name change this requires special casing. */
					result = containingClass.instanceName();
				} else {
					result = eventBPolymorphicTypeConstructorName();
				}
			}
		}
		
		return result;
	}
	
	@Override
	public String getParaContextArgs(FunctionCall fc) throws Exception {
		return null;
	}
	
	@Override
	public String compileToStringWithContext(FunctionCall fc, Boolean asPred) throws Exception {
		TypeDeclContext ctx = fc.getContext();
		List<FuncCallArgs> argumentBlocks = fc.getFuncCallArgs();
		boolean noArgs = argumentBlocks == null || argumentBlocks.isEmpty();
		if (ctx == null && noArgs) {
			//TODO varidation.
			throw new Exception(
					"This should be validated against, a type class appears wihtout context or argument, "
							+ "if asPred is true this definitely doesn't work. It may be possible for"
							+ "this to work when asPred is false, this work has not been done.");
		}
		
		/* Due to issues with the type hierarchy BSClassImpl is not 
		 * a subclass of ExpressionVariableImpl, so instead I call super
		 * as shown below.
		 */
		return ExpressionVariableImpl.compileToStringWithContextFunc(this, fc, asPred);
	}

	@Override
	public String eventBPrefix() {
		// TODO Fix this when a prefix can be manually set.
		return getName();
	}

	/* Reduces the type to the BSharp type without any Type classes within it. */
	@Override
	public TypeBuilder identType() {
		TypeBuilder result = null;
		TypeBuilder superType = supertypes.getFirst();
		if (superType.isAbstractTypeClass()) {
			result = superType.getTypeClass().identType();
		} else {
			result = superType;
		}

		if (varList == null)
			return result;

		ArrayList<Tuple2<TypedVariable, TypeBuilder>> typedVars = varList.getVariablesWithBSharpTypes();
		TypeBuilder res = null;
		for (Tuple2<TypedVariable, TypeBuilder> typeVar : typedVars) {
			if (res == null)
				res = typeVar.y;
			else {
				ConstructedType newRes = BSharpFactory.eINSTANCE.createConstructedType();
				newRes.setLeft(res);
				newRes.setRight(typeVar.y);
				res = newRes;
			}
		}

		if (res == null)
			return result;

		ConstructedType newRes = BSharpFactory.eINSTANCE.createConstructedType();
		newRes.setLeft(result);
		newRes.setRight(res);

		return newRes;
	}

	@Override
	public Integer prjsRequiredForSupertype(BSClass sType) {
		/*
		 * To do this I want to do type analysis, this involves expanding all of the
		 * Type classes, to build a type tree. This is done for both this type and
		 * sType. The type trees can then be compared to calculate the number of prjs
		 * required.
		 */
		if (sType == this)
			return 0;

		if (supertypes == null)
			return null;

		EList<TypeBuilder> sTypes = supertypes.getSuperTypes();

		for (TypeBuilder supT : sTypes) {
			BSClass s = supT.getTypeClass();
			if (s == null)
				continue;

			Integer prjs = s.prjsRequiredForSupertype(sType);
			/*
			 * If there are no new variables then the supertype doesn't require an extra
			 * prj.
			 */
			TypedVariableList varList = getVarList();
			if (prjs != null && varList != null && varList.varCount() != 0)
				return prjs + 1;
			else
				return prjs;
		}

		return null;
	}

	@Override
	public Integer prjsRequiredForBaseType() {
		if (supertypes != null) {
			TypeBuilder super1 = supertypes.getFirst();
			super1.reorderTypeTree();

			if (super1.isBaseType()) {
				if (varList != null && varList.varCount() != 0)
					return 1;
				else
					return 0;
			}

			Integer res = ((BSClass) ((TypeConstructor) super1).getTypeName()).prjsRequiredForBaseType();

			if (varList != null && varList.varCount() != 0) {
				return res + 1;
			}

			return res;
		}

		return 0;
	}

	/*
	 * The base type is the type before any additional variables have been added.
	 * Importantly this base type will reference all of the possible polymorphic
	 * types that are available. By examining the base types the relevant prj calls
	 * can be generated to deconstruct instances to fill in the EventB polymorphic
	 * context.
	 */
	@Override
	public TypeBuilder baseType() {
		if (supertypes != null) {
			TypeBuilder super1 = supertypes.getFirst();
			super1.reorderTypeTree();

			/*
			 * It's likely that we'll need to unwrap a power set here. As the base type of a
			 * type class needs to be a power set of a type.
			 */

			if (super1 instanceof TypePowerSet) {
				super1 = ((TypePowerSet) super1).getChild();
			}
			
			if (super1 instanceof TypeConstructor) {
				TypeDeclContext ctx = ((TypeConstructor)super1).getContext();
				if (ctx != null) {
					return ((ClassDecl)((TypeConstructor) super1).getTypeName()).baseTypeForTypeDeclarationContext(ctx);
				}
			}

			if (super1.isBaseType())
				return super1;

			return ((BSClass) ((TypeConstructor) super1).getTypeName()).baseType();
		}

		return null;
	}

	@Override
	public String deconstructEventBTypeToArguments(String deconstructionType) {
		Integer prjsRequired = prjsRequiredForBaseType();

		String deconType = CompilationUtil.wrapNameInPrj1s(deconstructionType, prjsRequired);

		TypeBuilder baseType = baseType();
		String result = baseType.getPrimativeTypesListByDeconstruction(deconType);

		if (result == null || result.isEmpty()) {
			result = deconType;
		} else {
			result += ", " + deconstructionType;
		}

		return result;
	}
	
	/* Uses the type constructor to construct the type from the type instance. The context
	 * needs to be passed about to determine which objects are in scope. */
	@Override
	public String constructorArgsForTypeInstance(ITypeInstance typeInst) {
		String result = typeInst.baseTypeDeconstructedToPrimativeTypes(baseType());
		result += ", " + typeInst.eventBTypeInstanceForType(this);
		
		return result;
	}
	
	/* As an example T.equ will give Setoid_equ(..., T), this is complicated
	 * as T may be a subclass of Setoid. As typeInst is an ITypeInstance there
	 * is no way to deconstruct it without using the getter functions. 
	 */
	public String applyGetter(PolyType ownerType, ExpressionVariable typeInst) {
		TypedVariableList varList = EcoreUtil2.getContainerOfType(typeInst, TypedVariableList.class);
		if (varList != null && varList.eContainer() instanceof BSClass) {
			String getterFunc = getterForOpName(typeInst.getName());
			String result = getterFunc + "(";
			ArrayList<String> polyTypes = ownerType.typeNames();

			boolean first = true;
			for (String tName : polyTypes) {
				if (!first) {
					result += ", ";
				}
				first = false;

				result += tName;
			}

			result += ")";
			
			return result;
		}
		
		return null;
	}

	@Override
	public String expandSupertypeMemberReferencedInWhere(TypedVariable var) {
		TypeBuilder superT = supertypes.getFirst();
		BSClass bsSuper = superT.getTypeClass();

		String result = bsSuper.getterForOpName(var.getName()) + "(";
		ArrayList<String> types = context.namesForPolyContextTypes();

		boolean first = true;
		for (String type : types) {
			if (!first) {
				result += ", ";
			}
			first = false;

			result += type;
		}

		if (!first)
			result += ", ";

		result += instanceName() + ")";
		return result;
	}

	/*
	 * If we have an expression such as T : Setoid in a polymophic in eventB this
	 * becomes T1 : POW(T_EvB), T : Setoid_T(T1), this method will return T1. If the
	 * Setoid was a subset of T ** T then it would return T1 ** T1.
	 */
	@Override
	public String baseTypeStringForPolymorphicType(PolyType p) {
		String baseName = p.getName();
		Integer neededPolys = eventBRequiredPolyTypes();
		ArrayList<String> requiredEBTypes = new ArrayList<String>();

		for (Integer i = 1; i <= neededPolys; ++i) {
			requiredEBTypes.add(baseName + i.toString());
		}

		TypeBuilder baseType = baseType();
		return baseType.constructWithTypes(requiredEBTypes);
	}

	/*
	 * In type class declarations such as the Monoid declaration you can do a :
	 * Monoid. This will return the name of the type used to construct the monoid.
	 */
	@Override
	public String baseTypeFromBSContext() {
		PolyContext context = getContext();
		ArrayList<String> polyTypedVars = context.namesForPolyContextTypes();
		TypeBuilder baseType = baseType();
		return baseType.constructWithTypes(polyTypedVars);
	}

	@Override
	public String inferredPolyTypeArgsForType(ClassDecl t) {

		ArrayList<String> constrTypeVars = context.namesForPolyContextTypes();

		String result = "";
		boolean first = true;
		for (int i = 0; i < constrTypeVars.size(); ++i) {
			if (!first)
				result += ", ";

			first = false;

			result += constrTypeVars;
		}

		int prjsRequired;

		if (t instanceof Datatype)
			prjsRequired = prjsRequiredForBaseType() - 1;
		else
			prjsRequired = prjsRequiredForSupertype((BSClass) t) - 1;

		String instName = instanceName();
		CompilationUtil.wrapNameInPrj1s(instName, prjsRequired);

		if (!first) {
			result += ", ";
		}

		return result += instName;
	}

	@Override
	public String opNameForMatchStatement(MatchStatementImpl match) {
		return name + "_M" + (compiledMatchStatements++).toString();
	}

	@Override
	public TypeBuilder calculateReturnType() {
		/*
		 * I think that I need some serious consideration about whether this should ever
		 * happen. I don't think that it should.
		 */
		return null;
	}

	@Override
	public TypeBuilder calculateType() {
		TypePowerSet tps = BSharpFactory.eINSTANCE.createTypePowerSet();
		TypeConstructor tc = BSharpFactory.eINSTANCE.createTypeConstructor();
		tc.setTypeName(this);
		tps.setChild(tps);
		return tps;
	}

	@Override
	public Collection<? extends Tuple2<String, String>> inScopeTypedVariables() {
		/*
		 * Check for a supertype and get it's in scope varaibles, then append any
		 * additional variables from the varlist.
		 */
		TypeBuilder superT = supertypes.getFirst();
		BSClass bsSuper = superT.getTypeClass();

		ArrayList<Tuple2<String, String>> result = new ArrayList<Tuple2<String, String>>();
		if (bsSuper != null) {
			result.addAll(bsSuper.inScopeTypedVariables());
		}

		result.addAll(varList.getCompiledVariablesAndTypes());
		return result;
	}

	@Override
	public ClassDecl getFirstSupertypeTypeClass() {
		return supertypes.getFirst().getTypeClass();
	}
	
	@Override
	public IMapletNode concreteTypeMapletTree(List<IClassInstance> types, List<Expression> arguments, Instance declInst,
			EObject context) {
		if (types.size() != 1) {
			/* This shouldn't be too dificult to fix, it simply requires compiling the type class 
			 * with the types. This would result in a stringNode, it would be nicer to store the
			 * type with a datastructure until it needs to be compiled.
			 */
			try {
				throw new Exception("Type classes with mulitple polymorphic types are not yet handled");
			} catch (Exception e) {
				System.err.println("Type classes with mulitple polymorphic types are not yet handled");
				return null;
			}
		}
		
		List<Expression> args = arguments;
		IClassInstance type = types.get(0);
		int argsCount = args.size();
		TypedVariableList varList = getVarList();
		int requiredArgsCount;
		
		if (varList == null)
			requiredArgsCount = 0;
		else 
			requiredArgsCount = varList.count();
		
		if (requiredArgsCount > argsCount && argsCount != 0) {
			try {
				throw new Exception("Wrong number of arguments to create an instance of this"
						+ "type class. This should have been validated against.");
			} catch (Exception e) {
				System.err.println("Wrong number of arguments to create an instance of this"
						+ "type class. This should have been validated against.");
				return null;
			}
		}
		
		SuperTypeList supers = getSupertypes();
		IMapletNode result = null;
		
		if (argsCount > requiredArgsCount) {
			List<Expression> myVars = args.subList(argsCount - requiredArgsCount, argsCount);
			List<Expression> otherVars = args.subList(0, argsCount - requiredArgsCount);
			
			BSClass superT = supers.getFirst().getTypeClass();
			if (superT == null) {
				try {
					throw new Exception("Too many args for creating a type class");
				} catch (Exception e) {
					return null;
				}
			}
				
			IMapletNode left = superT.concreteTypeMapletTree(types, otherVars, declInst, context);
			if (!myVars.isEmpty()) {
				result = CompilationUtil.mapletNodeFromExpressionArray(myVars);
				result = result.appendNodeToLeft(left);
			} else {
				result = left;
			}
			
			return result;
		}
		
		if (argsCount == requiredArgsCount) {
			if (!supers.getFirst().isAbstractTypeClass()) {
				/* We're at the end of the process. Just need to create the ITypeInstance
				 * with the variables that have been passed.
				 */
				ClassDecl baseType = null;
				if (types instanceof Instance) {
					baseType = ((Instance)type).getBaseType();
				} else {
					baseType = (ClassDecl)type;
				}
				
				result = CompilationUtil.mapletNodeFromExpressionArray(args);
			}
			
			/* We've used all of the args. */
			if (argsCount != 0) {
				result = CompilationUtil.mapletNodeFromExpressionArray(args);
				args = new ArrayList<Expression>();
				argsCount = 0;
			}
		}
		
		IMapletNode superTypeNode = null;
		BSClass superT = supers.getFirst().getTypeClass();
		if (argsCount == 0 && superT == null) {
			superTypeNode = new MapletExpressionVariableLeaf((ClassDecl) type);
		} else if (argsCount != 0) {
			superTypeNode = superT.concreteTypeMapletTree(types, args, declInst, context);
		} else if (superT != null) {
			/*
			 * There is additional type information in an other instance variable. This cans
			 * either be reached directly if type is an instance variable declaration, or it
			 * is necessary to search the type and its extensions for for an unnamed
			 * instance of one of the supertypes.
			 */
			if (type instanceof Instance) {
				superTypeNode = ((Instance) type).concreteInstanceMapletTree();
			} else {
				/*
				 * It is necessary to find a default super instance of the current instance. Any
				 * one will do, there should be validation to check that there aren't
				 * contradictory super instances.
				 */
				ConcreteTypeInstance superInst = declInst.findSuperTypeInstanceOfType(superT, context);

				if (superInst == null) {
					try {
						throw new Exception("Insufficient variables for Instance method."
								+ "This should have been validated against");
					} catch (Exception e) {
						System.err.println("Insufficient variables for Instance method."
								+ "This should have been validated against");
						return null;
					}
				}

				superTypeNode = superInst.getTree();
			}
		}
		
		if (result != null && superTypeNode != null)
			return result.appendNodeToLeft(superTypeNode);
		else if (result != null)
			return result;
		else
			return superTypeNode;
	}
	
	@Override
	public int variablesCount() {
		TypedVariableList varList = getVarList();
		if (varList == null)
			return 0;
		
		return varList.count();
	}
	
	/* Fills the array with the type classes that can be built with the number of arguments */
	@Override
	public
	void typeClassesConstructableFromArgCount(int argsCount, ArrayList<BSClass> result) {
		
		int requiredArgsCount = variablesCount();
		
		if (requiredArgsCount == argsCount) {
			result.add(this);
			return;
		}
		
		if (argsCount > requiredArgsCount) {
			SuperTypeList supers = getSupertypes();
			BSClass superT = supers.getFirst().getTypeClass();
			
			superT.typeClassesConstructableFromArgCount(argsCount - requiredArgsCount, result);
			result.add(this);
			return;
		}
	}
	
	@Override
	public
	List<BSClass> typeClassesConstructableWithArgs(List<Expression> args) {
		ArrayList<BSClass> result = new ArrayList<BSClass>();
		typeClassesConstructableFromArgCount(args.size(), result);
		return result;
	}
	
	@Override
	public boolean isSuperType(ClassDecl possibleSType) {
		SuperTypeList st = getSupertypes();
		
		if (st == null || st.isEmpty())
			return false;
		
		return st.containsTypeRecursive(possibleSType);
	}
	
	@Override
	public boolean isDirectSuperType(ClassDecl possibleSType) {
		SuperTypeList st = getSupertypes();
		
		if (st == null || st.isEmpty())
			return false;
		
		return st.containsType(possibleSType);
	}

	@Override
	public ITypeInstance typeInstanceForContext(EObject context) {
		/* The generic type instance is the one that will work most 
		 * generically until I can sort out typing on tree based type
		 * instances.
		 */
		return genericTypeInstance(context);
	}
} // BppClassImpl
