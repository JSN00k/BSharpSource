/**
 * generated by Xtext 2.14.0
 */
package ac.soton.bsharp.bSharp.impl;

import ac.soton.bsharp.bSharp.BSClass;
import ac.soton.bsharp.bSharp.BSharpFactory;
import ac.soton.bsharp.bSharp.BSharpPackage;
import ac.soton.bsharp.bSharp.ClassDecl;
import ac.soton.bsharp.bSharp.Expression;
import ac.soton.bsharp.bSharp.QuantLambda;
import ac.soton.bsharp.bSharp.TheoremDecl;
import ac.soton.bsharp.bSharp.TypedVariable;
import ac.soton.bsharp.bSharp.impl.QuantLambdaImpl.QuantLambdaType;
import ac.soton.bsharp.bSharp.util.CompilationUtil;
import ac.soton.bsharp.theory.util.TheoryImportCache;
import ac.soton.bsharp.theory.util.TheoryUtils;
import ac.soton.bsharp.typeInstanceRepresentation.ITypeInstance;

import java.util.Collection;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;
import org.eclipse.xtext.EcoreUtil2;

/**
 * <!-- begin-user-doc -->
 * An implementation of the model object '<em><b>Theorem Decl</b></em>'.
 * <!-- end-user-doc -->
 * <p>
 * The following features are implemented:
 * </p>
 * <ul>
 *   <li>{@link ac.soton.bsharp.bSharp.impl.TheoremDeclImpl#getName <em>Name</em>}</li>
 *   <li>{@link ac.soton.bsharp.bSharp.impl.TheoremDeclImpl#getExpr <em>Expr</em>}</li>
 *   <li>{@link ac.soton.bsharp.bSharp.impl.TheoremDeclImpl#getGeneratedQuants <em>Generated Quants</em>}</li>
 * </ul>
 *
 * @generated
 */
public class TheoremDeclImpl extends IExpressionContainerImpl implements TheoremDecl {
	/**
	 * The default value of the '{@link #getName() <em>Name</em>}' attribute.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see #getName()
	 * @generated
	 * @ordered
	 */
	protected static final String NAME_EDEFAULT = null;

	/**
	 * The cached value of the '{@link #getName() <em>Name</em>}' attribute.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see #getName()
	 * @generated
	 * @ordered
	 */
	protected String name = NAME_EDEFAULT;

	/**
	 * The cached value of the '{@link #getExpr() <em>Expr</em>}' containment reference.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see #getExpr()
	 * @generated
	 * @ordered
	 */
	protected Expression expr;

	/**
	 * The cached value of the '{@link #getGeneratedQuants() <em>Generated Quants</em>}' containment reference list.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see #getGeneratedQuants()
	 * @generated
	 * @ordered
	 */
	protected EList<QuantLambda> generatedQuants;

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	protected TheoremDeclImpl() {
		super();
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	protected EClass eStaticClass() {
		return BSharpPackage.Literals.THEOREM_DECL;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public String getName() {
		return name;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public void setName(String newName) {
		String oldName = name;
		name = newName;
		if (eNotificationRequired())
			eNotify(new ENotificationImpl(this, Notification.SET, BSharpPackage.THEOREM_DECL__NAME, oldName, name));
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public Expression getExpr() {
		return expr;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public NotificationChain basicSetExpr(Expression newExpr, NotificationChain msgs) {
		Expression oldExpr = expr;
		expr = newExpr;
		if (eNotificationRequired()) {
			ENotificationImpl notification = new ENotificationImpl(this, Notification.SET, BSharpPackage.THEOREM_DECL__EXPR, oldExpr, newExpr);
			if (msgs == null) msgs = notification; else msgs.add(notification);
		}
		return msgs;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public void setExpr(Expression newExpr) {
		if (newExpr != expr) {
			NotificationChain msgs = null;
			if (expr != null)
				msgs = ((InternalEObject)expr).eInverseRemove(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.THEOREM_DECL__EXPR, null, msgs);
			if (newExpr != null)
				msgs = ((InternalEObject)newExpr).eInverseAdd(this, EOPPOSITE_FEATURE_BASE - BSharpPackage.THEOREM_DECL__EXPR, null, msgs);
			msgs = basicSetExpr(newExpr, msgs);
			if (msgs != null) msgs.dispatch();
		}
		else if (eNotificationRequired())
			eNotify(new ENotificationImpl(this, Notification.SET, BSharpPackage.THEOREM_DECL__EXPR, newExpr, newExpr));
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public EList<QuantLambda> getGeneratedQuants() {
		if (generatedQuants == null) {
			generatedQuants = new EObjectContainmentEList<QuantLambda>(QuantLambda.class, this, BSharpPackage.THEOREM_DECL__GENERATED_QUANTS);
		}
		return generatedQuants;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs) {
		switch (featureID) {
			case BSharpPackage.THEOREM_DECL__EXPR:
				return basicSetExpr(null, msgs);
			case BSharpPackage.THEOREM_DECL__GENERATED_QUANTS:
				return ((InternalEList<?>)getGeneratedQuants()).basicRemove(otherEnd, msgs);
		}
		return super.eInverseRemove(otherEnd, featureID, msgs);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public Object eGet(int featureID, boolean resolve, boolean coreType) {
		switch (featureID) {
			case BSharpPackage.THEOREM_DECL__NAME:
				return getName();
			case BSharpPackage.THEOREM_DECL__EXPR:
				return getExpr();
			case BSharpPackage.THEOREM_DECL__GENERATED_QUANTS:
				return getGeneratedQuants();
		}
		return super.eGet(featureID, resolve, coreType);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@SuppressWarnings("unchecked")
	@Override
	public void eSet(int featureID, Object newValue) {
		switch (featureID) {
			case BSharpPackage.THEOREM_DECL__NAME:
				setName((String)newValue);
				return;
			case BSharpPackage.THEOREM_DECL__EXPR:
				setExpr((Expression)newValue);
				return;
			case BSharpPackage.THEOREM_DECL__GENERATED_QUANTS:
				getGeneratedQuants().clear();
				getGeneratedQuants().addAll((Collection<? extends QuantLambda>)newValue);
				return;
		}
		super.eSet(featureID, newValue);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public void eUnset(int featureID) {
		switch (featureID) {
			case BSharpPackage.THEOREM_DECL__NAME:
				setName(NAME_EDEFAULT);
				return;
			case BSharpPackage.THEOREM_DECL__EXPR:
				setExpr((Expression)null);
				return;
			case BSharpPackage.THEOREM_DECL__GENERATED_QUANTS:
				getGeneratedQuants().clear();
				return;
		}
		super.eUnset(featureID);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public boolean eIsSet(int featureID) {
		switch (featureID) {
			case BSharpPackage.THEOREM_DECL__NAME:
				return NAME_EDEFAULT == null ? name != null : !NAME_EDEFAULT.equals(name);
			case BSharpPackage.THEOREM_DECL__EXPR:
				return expr != null;
			case BSharpPackage.THEOREM_DECL__GENERATED_QUANTS:
				return generatedQuants != null && !generatedQuants.isEmpty();
		}
		return super.eIsSet(featureID);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public String toString() {
		if (eIsProxy()) return super.toString();

		StringBuilder result = new StringBuilder(super.toString());
		result.append(" (name: ");
		result.append(name);
		result.append(')');
		return result.toString();
	}
	
	protected IProgressMonitor nullMonitor = new NullProgressMonitor();
	
	protected ITypeInstance typeInst = null;
	
	private String theoremPrefix = null;
	
	public String getTheoremName() {
		if (theoremPrefix != null)
			return theoremPrefix + " " + getName();
		
		return getName();
	}
	
	@Override public void compileWithTypeInstancesForInferredType(ITypeInstance typeInstance, String theoremPrefix) {
		this.theoremPrefix = theoremPrefix;
		compileWithTypeInstancesForInferredType(typeInstance);
		this.theoremPrefix = null;
	}
	
	String createClassRepPrefix() {
		ITypeInstance classTypeInst = getInferredTypeInstance();
		String result = "∀";
		result += CompilationUtil.compileVariablesNamesToArgumentsWithSeparator(classTypeInst.typeAndVariableNames(), ", ", true);
		result += "·";
		result += CompilationUtil.compileTypedVaribalesToTypedList(classTypeInst.typingStatementForInstance(), true);
		result += " ⇒ ";
		return result;
	}
	
	@Override
	public void compileWithTypeInstancesForInferredType(ITypeInstance typeInstance) {
		expr = expr.reorderExpresionTree();
		String ebPred = null;
		
		if (!expr.referencesContainingType()) {
			/* I don't need to worry about the type instance the expr won't use it anyway. */
			try {
				ebPred = expr.compileToEventBString(true);
			} catch (Exception e) {
				System.err.println("Unable to compile expression with error: " + e.getLocalizedMessage());
				return;
			}
		} else {
			if (typeInstance == null) {
				ClassDecl containingType = CompilationUtil.getClassDecl(this);
				this.typeInst = ((BSClass)containingType).deconstructedTypeInstance(this, null);
			} else {
				this.typeInst = typeInstance;
			}

			if (typeInst.isInferredTypeInst())
				ebPred = createClassRepPrefix();
			else 
				ebPred = "";
			
			boolean addBrackets = typeInst.isInferredTypeInst() && expr instanceof QuantLambda;
			try {
				if (addBrackets)
					ebPred += "(";
				
				ebPred += expr.compileToEventBString(true);
				
				if (addBrackets)
					ebPred += ")";
			} catch (Exception e) {
				System.err.println("Unable to compile expression with error: " + e.getLocalizedMessage());
				e.printStackTrace();
				return;
			}
		}
		
		TheoryImportCache thyCache;
		
		if (typeInst == null) {
			thyCache = CompilationUtil.getTheoryCacheForElement(this);
		} else {
			thyCache = CompilationUtil.getTheoryCacheForElement(this.typeInst.getContext());
		}
		try {
			TheoryUtils.createTheorem(thyCache.theory, getTheoremName(), ebPred, nullMonitor);
		} catch (Exception e) {
			System.err.println("Unable to create EventB theorem with error: " + e.getLocalizedMessage());
		}
		
		this.typeInst = null;
	}
	
	@Override
	public void compile() {
		compileWithTypeInstancesForInferredType(null);
	}
	
	@Override
	public String baseTypeForBSClass(BSClass typeName) {
		if (expr instanceof QuantLambda) {
			return ((QuantLambda)expr).baseTypeForBSClass(typeName);
		}
		
		return null;
	}

	@Override
	public String getNameExpressionForVariable(TypedVariable typedVariable) {
		if (expr instanceof QuantLambda) {
			return ((QuantLambda)expr).getNameExpressionForVariable(typedVariable);
		}
		
		return null;
	}

	@Override
	public ITypeInstance getInferredTypeInstance() {		
		return typeInst;
	}

} //TheoremDeclImpl
