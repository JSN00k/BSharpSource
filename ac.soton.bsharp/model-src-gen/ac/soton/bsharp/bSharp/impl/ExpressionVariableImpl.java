/**
 * generated by Xtext 2.14.0
 */
package ac.soton.bsharp.bSharp.impl;

import ac.soton.bsharp.bSharp.BSharpPackage;
import ac.soton.bsharp.bSharp.Expression;
import ac.soton.bsharp.bSharp.ExpressionVariable;
import ac.soton.bsharp.bSharp.FuncCallArgs;
import ac.soton.bsharp.bSharp.FunctionCall;
import ac.soton.bsharp.bSharp.IVarType;
import ac.soton.bsharp.bSharp.PolyType;
import ac.soton.bsharp.bSharp.TypeBuilder;
import ac.soton.bsharp.bSharp.TypeDeclContext;
import ac.soton.bsharp.bSharp.util.CompilationUtil;

import java.util.List;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;

/**
 * <!-- begin-user-doc -->
 * An implementation of the model object '<em><b>Expression Variable</b></em>'.
 * <!-- end-user-doc -->
 *
 * @generated
 */
public abstract class ExpressionVariableImpl extends NamedObjectImpl implements ExpressionVariable {
	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	protected ExpressionVariableImpl() {
		super();
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	protected EClass eStaticClass() {
		return BSharpPackage.Literals.EXPRESSION_VARIABLE;
	}

	@Override
	public String descriptiveName() {
		// TODO Auto-generated method stub
		return name;
	}
	
	@Override 
	public String getEventBFunctypeForCall(FunctionCall fc) {
		return getName();
	}
	
	public String evBSeparatorForFunc() {
		return " ↦ ";
	}

	@Override
	public String compileToStringWithContext(FunctionCall fc, Boolean asPred)  throws Exception {
		return compileToStringWithContextFunc(this, fc, asPred);
	}
	
	public static String compileToStringWithContextFunc(IVarType var, FunctionCall fc, Boolean asPred)  throws Exception {
		TypeDeclContext ctx = fc.getContext();
		List<FuncCallArgs> argBlock = fc.getFuncCallArgs();
		boolean argsAreEmpty = argBlock == null || argBlock.isEmpty();
		String result = var.getEventBFunctypeForCall(fc);
		
		/* The compiled parametric context args, a list of comma separated args ending with the trailing 
		 * comma when necessary. */
		String parametricContextArgs = var.getParaContextArgs(fc);
		
		if (!argsAreEmpty) {
			List<Expression> firstArgs = argBlock.get(0).getArguments();
			String sep = var.evBSeparatorForFunc();
			int blocksCount = argBlock.size();
			for (int i = 0; i < blocksCount - 1; ++i) {
				if (parametricContextArgs != null) {
					result += "(" + parametricContextArgs + CompilationUtil.compileExpressionListWithSeperator(argBlock.get(i).getArguments(), sep) + ")";
					parametricContextArgs = null;
				} else {
					result += "(" + CompilationUtil.compileExpressionListWithSeperator(argBlock.get(i).getArguments(), sep) + ")";
				}
				sep = " ↦ ";
			}
			
			String lastBlock;
			if (parametricContextArgs != null) {
				lastBlock = "(" + parametricContextArgs + CompilationUtil.compileExpressionListWithSeperator(argBlock.get(blocksCount - 1).getArguments(), sep) + ")";
			} else {
				lastBlock = "(" + CompilationUtil.compileExpressionListWithSeperator(argBlock.get(blocksCount - 1).getArguments(), sep) + ")";
			}
			
			boolean returnTypeIsBoolean = false;
			try {
				returnTypeIsBoolean = var.calculateReturnType(ctx, firstArgs).isBoolType();
			} catch (Exception e) {
				/* I'm skeptical that this is always correct as polymorphic types are not replaced with
				 * concrete types when they could be. This needs to be fixed in future implementation.
				 * In this instance the chances are that if we can't calculate the return type it's not
				 * a boolean.
				 */
				System.err.println("Unable to calculate return type.");
			}
			
			if (returnTypeIsBoolean) {
				result = lastBlock + " ∈ " + result;
				if (!asPred) {
					result = "bool(" + result + ")";
				}
			} else {
				result += lastBlock;
			}
			
			return result;
		} else if (parametricContextArgs != null) {
			result += "(" + parametricContextArgs.substring(0, parametricContextArgs.length() - 1) + ")";
		}
		
		if (asPred) {
			result += " = TRUE";
		}
		
		return result;
	}
	
	@Override
	public String getParaContextArgs(FunctionCall fc) throws Exception {
		return null;
	}
} //ExpressionVariableImpl
