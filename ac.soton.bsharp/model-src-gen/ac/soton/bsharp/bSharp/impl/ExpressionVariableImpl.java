/**
 * generated by Xtext 2.14.0
 */
package ac.soton.bsharp.bSharp.impl;

import ac.soton.bsharp.bSharp.BSharpPackage;
import ac.soton.bsharp.bSharp.Expression;
import ac.soton.bsharp.bSharp.ExpressionVariable;
import ac.soton.bsharp.bSharp.FuncCallArgs;
import ac.soton.bsharp.bSharp.FunctionCall;
import ac.soton.bsharp.bSharp.PolyType;
import ac.soton.bsharp.bSharp.TypeBuilder;
import ac.soton.bsharp.bSharp.TypeDeclContext;
import ac.soton.bsharp.bSharp.util.CompilationUtil;

import java.util.List;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;

/**
 * <!-- begin-user-doc -->
 * An implementation of the model object '<em><b>Expression Variable</b></em>'.
 * <!-- end-user-doc -->
 *
 * @generated
 */
public abstract class ExpressionVariableImpl extends NamedObjectImpl implements ExpressionVariable {
	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	protected ExpressionVariableImpl() {
		super();
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	protected EClass eStaticClass() {
		return BSharpPackage.Literals.EXPRESSION_VARIABLE;
	}

	@Override
	public String descriptiveName() {
		// TODO Auto-generated method stub
		return name;
	}

	@Override
	public String compileToStringWithContextAndArguments(FunctionCall fc, Boolean asPred)  throws Exception {
		/* TODO: This is the third time I've come across very similar methods, the others were 
		 * BSClassImpl.compileToStringWithContextAndArguments(FunctionCall fc, Boolean asPred)
		 * and 
		 * BSClassImpl.(ExpressionVariable typeInst, PolyType ownerType, FunctionCall fc,
			Boolean asPred)
		 * Ideally these should be encapsulated.	
		 */
		TypeDeclContext ctx = fc.getContext();
		
		if (ctx != null) {
			/* I don't believe that there is any way that a type variable can have a context. */
			throw new Exception("Validate against this, a type variable shouldn't be able to have" +
			" a poly context applied to it.");
		}
		
		List<FuncCallArgs> argBlock = fc.getFuncCallArgs();
		boolean argsAreEmpty = argBlock == null || argBlock.isEmpty();
		String result = name;
		
		if (!argsAreEmpty) {
			int blocksCount = argBlock.size();
			for (int i = 0; i < blocksCount - 1; ++i) {
				result += "(" + CompilationUtil.compileExpressionListWithSeperator(argBlock.get(i).getArguments(), " ↦ ") + ")";
			}
			
			String lastBlock = "(" + CompilationUtil.compileExpressionListWithSeperator(argBlock.get(blocksCount - 1).getArguments(), " ↦ ") + ")";
			
			if (calculateReturnType().isBoolType()) {
				result = lastBlock + "∈" + result;
				if (!asPred) {
					result = "bool(" + result + ")";
				}
			} else {
				result += lastBlock;
			}
			
			return result;
		}
		
		if (asPred) {
			result += " = TRUE";
		}
		
		return result;
	}


} //ExpressionVariableImpl
