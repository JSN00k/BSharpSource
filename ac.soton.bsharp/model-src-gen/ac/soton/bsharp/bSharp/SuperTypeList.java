/**
 * generated by Xtext 2.14.0
 */
package ac.soton.bsharp.bSharp;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EObject;

import ac.soton.bsharp.theory.util.TheoryImportCache;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Super Type List</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link ac.soton.bsharp.bSharp.SuperTypeList#getSuperTypes <em>Super Types</em>}</li>
 * </ul>
 *
 * @see ac.soton.bsharp.bSharp.BSharpPackage#getSuperTypeList()
 * @model
 * @generated
 */
public interface SuperTypeList extends EObject {
	/**
	 * Returns the value of the '<em><b>Super Types</b></em>' containment reference list.
	 * The list contents are of type {@link ac.soton.bsharp.bSharp.ConstructedType}.
	 * <!-- begin-user-doc -->
	 * <p>
	 * If the meaning of the '<em>Super Types</em>' containment reference list isn't clear,
	 * there really should be more of a description here...
	 * </p>
	 * <!-- end-user-doc -->
	 * @return the value of the '<em>Super Types</em>' containment reference list.
	 * @see ac.soton.bsharp.bSharp.BSharpPackage#getSuperTypeList_SuperTypes()
	 * @model containment="true"
	 * @generated
	 */
	EList<ConstructedType> getSuperTypes();

	public void setupCompilation(TheoryImportCache theoryCache);
	
	/* EventB set comprehension has the form { a |-> b |-> c | a \in type /\ b\in type ...
	 * when compiling supertypes if the supertypes are disjoint then they each need a variable,
	 * Then these variables need to be typed separately. Finally for supertypes that share an 
	 * ancestor it is necessary to find that common ancestor, and rebuild the rest of the type
	 * from there. This is a matter of adding the extra type definition variables from the 
	 * superclasses.
	 */
	public String compileToSetCompVariableList();
	public String compileToSetCompTyping();
	
	
} // SuperTypeList
