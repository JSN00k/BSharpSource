/*
 * generated by Xtext 2.14.0
 */
package ac.soton.bsharp.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class BSharpGrammarAccess extends AbstractGrammarElementFinder {
	
	public class DomainModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.DomainModel");
		private final Assignment cElementsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cElementsTopLevelParserRuleCall_0 = (RuleCall)cElementsAssignment.eContents().get(0);
		
		//DomainModel:
		//	elements+=TopLevel*;
		@Override public ParserRule getRule() { return rule; }
		
		//elements+=TopLevel*
		public Assignment getElementsAssignment() { return cElementsAssignment; }
		
		//TopLevel
		public RuleCall getElementsTopLevelParserRuleCall_0() { return cElementsTopLevelParserRuleCall_0; }
	}
	public class THM_NAMEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.THM_NAME");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_0_2 = (RuleCall)cAlternatives_0.eContents().get(2);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//// Theorem names can include white space. Work out how to change this to any string without a ':'
		//THM_NAME:
		//	(INT | ID | WS)* ":";
		@Override public ParserRule getRule() { return rule; }
		
		//(INT | ID | WS)* ":"
		public Group getGroup() { return cGroup; }
		
		//(INT | ID | WS)*
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0_0() { return cINTTerminalRuleCall_0_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0_1() { return cIDTerminalRuleCall_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_0_2() { return cWSTerminalRuleCall_0_2; }
		
		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
	}
	public class TopLevelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.TopLevel");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cImportStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cClassDeclParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cExtendParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cInstanceParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//TopLevel:
		//	ImportStatement | ClassDecl | Extend | Instance;
		@Override public ParserRule getRule() { return rule; }
		
		//ImportStatement | ClassDecl | Extend | Instance
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ImportStatement
		public RuleCall getImportStatementParserRuleCall_0() { return cImportStatementParserRuleCall_0; }
		
		//ClassDecl
		public RuleCall getClassDeclParserRuleCall_1() { return cClassDeclParserRuleCall_1; }
		
		//Extend
		public RuleCall getExtendParserRuleCall_2() { return cExtendParserRuleCall_2; }
		
		//Instance
		public RuleCall getInstanceParserRuleCall_3() { return cInstanceParserRuleCall_3; }
	}
	public class ClassDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.ClassDecl");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cClassParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDatatypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ClassDecl:
		//	Class | Datatype;
		@Override public ParserRule getRule() { return rule; }
		
		//Class | Datatype
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Class
		public RuleCall getClassParserRuleCall_0() { return cClassParserRuleCall_0; }
		
		//Datatype
		public RuleCall getDatatypeParserRuleCall_1() { return cDatatypeParserRuleCall_1; }
	}
	public class InbuiltTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.InbuiltType");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cNamePredKeyword_0 = (Keyword)cNameAssignment.eContents().get(0);
		
		///* There are three Types which can be used as type variables, inbuilt types, types create
		// * with ClassDecl (type classes and Datatypes) and Polymorphic types. There are different
		// * occasions where each of these can be used.
		// */ /* Consider whether to add other inbuilt types such as Integers etc. Given the lack of 
		// * recursion in the inbuilt types it may be better to build them instead. We need Pred
		// * as it is going to have special rules to deal with the separation of expressions and 
		// * predicates in Event B. */ InbuiltType:
		//	name='Pred';
		@Override public ParserRule getRule() { return rule; }
		
		//name='Pred'
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//'Pred'
		public Keyword getNamePredKeyword_0() { return cNamePredKeyword_0; }
	}
	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.Type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cClassDeclParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cInbuiltTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Type:
		//	ClassDecl | InbuiltType;
		@Override public ParserRule getRule() { return rule; }
		
		//ClassDecl | InbuiltType
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ClassDecl
		public RuleCall getClassDeclParserRuleCall_0() { return cClassDeclParserRuleCall_0; }
		
		//InbuiltType
		public RuleCall getInbuiltTypeParserRuleCall_1() { return cInbuiltTypeParserRuleCall_1; }
	}
	public class GenNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.GenName");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPolymorphicTypeNameParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//GenName:
		//	PolymorphicTypeName | Type;
		@Override public ParserRule getRule() { return rule; }
		
		//PolymorphicTypeName | Type
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PolymorphicTypeName
		public RuleCall getPolymorphicTypeNameParserRuleCall_0() { return cPolymorphicTypeNameParserRuleCall_0; }
		
		//Type
		public RuleCall getTypeParserRuleCall_1() { return cTypeParserRuleCall_1; }
	}
	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		///* -------------------------- Import Statements -------------------- */ /* I had hoped to use a python style import, however this seems to be fighting 
		// * the system, and would require a custom implementation of DefaultDeclarativeQualifiedNameProvider.
		// * To increase the development speed I am using the java style imports instead.
		// */ QualifiedName:
		//	ID ('.' ID)*;
		@Override public ParserRule getRule() { return rule; }
		
		//ID ('.' ID)*
		public Group getGroup() { return cGroup; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//('.' ID)*
		public Group getGroup_1() { return cGroup_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}
	public class QualifiedNameWithWildcardElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.QualifiedNameWithWildcard");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cQualifiedNameParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopAsteriskKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//QualifiedNameWithWildcard:
		//	QualifiedName '.*'?;
		@Override public ParserRule getRule() { return rule; }
		
		//QualifiedName '.*'?
		public Group getGroup() { return cGroup; }
		
		//QualifiedName
		public RuleCall getQualifiedNameParserRuleCall_0() { return cQualifiedNameParserRuleCall_0; }
		
		//'.*'?
		public Keyword getFullStopAsteriskKeyword_1() { return cFullStopAsteriskKeyword_1; }
	}
	public class ImportStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.ImportStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cImportsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImportsQualifiedNameWithWildcardParserRuleCall_1_0 = (RuleCall)cImportsAssignment_1.eContents().get(0);
		
		//ImportStatement:
		//	'Import'
		//	imports+=QualifiedNameWithWildcard+;
		@Override public ParserRule getRule() { return rule; }
		
		//'Import' imports+=QualifiedNameWithWildcard+
		public Group getGroup() { return cGroup; }
		
		//'Import'
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }
		
		//imports+=QualifiedNameWithWildcard+
		public Assignment getImportsAssignment_1() { return cImportsAssignment_1; }
		
		//QualifiedNameWithWildcard
		public RuleCall getImportsQualifiedNameWithWildcardParserRuleCall_1_0() { return cImportsQualifiedNameWithWildcardParserRuleCall_1_0; }
	}
	public class ClassElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.Class");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cClassKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cContextAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cContextPolyContextParserRuleCall_2_0 = (RuleCall)cContextAssignment_2.eContents().get(0);
		private final Assignment cSupertypesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cSupertypesSuperTypeListParserRuleCall_3_0 = (RuleCall)cSupertypesAssignment_3.eContents().get(0);
		private final Assignment cVarListAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cVarListTypeStructureParserRuleCall_4_0 = (RuleCall)cVarListAssignment_4.eContents().get(0);
		private final Assignment cWhereAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cWhereWhereParserRuleCall_5_0 = (RuleCall)cWhereAssignment_5.eContents().get(0);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cLeftCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cBodyElementsAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cBodyElementsTypeBodyElementsParserRuleCall_8_0 = (RuleCall)cBodyElementsAssignment_8.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		///* ------------------------ Class statements --------------------- */ Class BppClass:
		//	'Class' name=ID context=PolyContext? supertypes=SuperTypeList? varList=TypeStructure? where=Where? ';'?
		//	'{' bodyElements+=TypeBodyElements* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'Class' name=ID context=PolyContext? supertypes=SuperTypeList? varList=TypeStructure? where=Where? ';'? '{'
		//bodyElements+=TypeBodyElements* '}'
		public Group getGroup() { return cGroup; }
		
		//'Class'
		public Keyword getClassKeyword_0() { return cClassKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//context=PolyContext?
		public Assignment getContextAssignment_2() { return cContextAssignment_2; }
		
		//PolyContext
		public RuleCall getContextPolyContextParserRuleCall_2_0() { return cContextPolyContextParserRuleCall_2_0; }
		
		//supertypes=SuperTypeList?
		public Assignment getSupertypesAssignment_3() { return cSupertypesAssignment_3; }
		
		//SuperTypeList
		public RuleCall getSupertypesSuperTypeListParserRuleCall_3_0() { return cSupertypesSuperTypeListParserRuleCall_3_0; }
		
		//varList=TypeStructure?
		public Assignment getVarListAssignment_4() { return cVarListAssignment_4; }
		
		//TypeStructure
		public RuleCall getVarListTypeStructureParserRuleCall_4_0() { return cVarListTypeStructureParserRuleCall_4_0; }
		
		//where=Where?
		public Assignment getWhereAssignment_5() { return cWhereAssignment_5; }
		
		//Where
		public RuleCall getWhereWhereParserRuleCall_5_0() { return cWhereWhereParserRuleCall_5_0; }
		
		//';'?
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_7() { return cLeftCurlyBracketKeyword_7; }
		
		//bodyElements+=TypeBodyElements*
		public Assignment getBodyElementsAssignment_8() { return cBodyElementsAssignment_8; }
		
		//TypeBodyElements
		public RuleCall getBodyElementsTypeBodyElementsParserRuleCall_8_0() { return cBodyElementsTypeBodyElementsParserRuleCall_8_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_9() { return cRightCurlyBracketKeyword_9; }
	}
	public class PolymorphicTypeNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.PolymorphicTypeName");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		///*---------------- Polymorphic Context of -------------------------- */ PolymorphicTypeName:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class PolyContextElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.PolyContext");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPolyTypesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPolyTypesPolyContextTypesParserRuleCall_1_0 = (RuleCall)cPolyTypesAssignment_1.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//PolyContext:
		//	'<' polyTypes+=PolyContextTypes+ '>';
		@Override public ParserRule getRule() { return rule; }
		
		//'<' polyTypes+=PolyContextTypes+ '>'
		public Group getGroup() { return cGroup; }
		
		//'<'
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }
		
		//polyTypes+=PolyContextTypes+
		public Assignment getPolyTypesAssignment_1() { return cPolyTypesAssignment_1; }
		
		//PolyContextTypes
		public RuleCall getPolyTypesPolyContextTypesParserRuleCall_1_0() { return cPolyTypesPolyContextTypesParserRuleCall_1_0; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_2() { return cGreaterThanSignKeyword_2; }
	}
	public class PolyContextTypesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.PolyContextTypes");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNamePolymorphicTypeNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cConstraintsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConstraintsPolyTypeConstraintsParserRuleCall_1_0 = (RuleCall)cConstraintsAssignment_1.eContents().get(0);
		
		//PolyContextTypes:
		//	name=PolymorphicTypeName constraints+=PolyTypeConstraints*;
		@Override public ParserRule getRule() { return rule; }
		
		//name=PolymorphicTypeName constraints+=PolyTypeConstraints*
		public Group getGroup() { return cGroup; }
		
		//name=PolymorphicTypeName
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//PolymorphicTypeName
		public RuleCall getNamePolymorphicTypeNameParserRuleCall_0_0() { return cNamePolymorphicTypeNameParserRuleCall_0_0; }
		
		//constraints+=PolyTypeConstraints*
		public Assignment getConstraintsAssignment_1() { return cConstraintsAssignment_1; }
		
		//PolyTypeConstraints
		public RuleCall getConstraintsPolyTypeConstraintsParserRuleCall_1_0() { return cConstraintsPolyTypeConstraintsParserRuleCall_1_0; }
	}
	public class PolyTypeConstraintsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.PolyTypeConstraints");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cTypeNameClassDeclCrossReference_1_0 = (CrossReference)cTypeNameAssignment_1.eContents().get(0);
		private final RuleCall cTypeNameClassDeclQualifiedNameParserRuleCall_1_0_1 = (RuleCall)cTypeNameClassDeclCrossReference_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cTypeNameAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final CrossReference cTypeNameClassDeclCrossReference_2_1_0 = (CrossReference)cTypeNameAssignment_2_1.eContents().get(0);
		private final RuleCall cTypeNameClassDeclQualifiedNameParserRuleCall_2_1_0_1 = (RuleCall)cTypeNameClassDeclCrossReference_2_1_0.eContents().get(1);
		
		//PolyTypeConstraints:
		//	':' TypeName+=[ClassDecl|QualifiedName] (',' TypeName+=[ClassDecl|QualifiedName])*;
		@Override public ParserRule getRule() { return rule; }
		
		//':' TypeName+=[ClassDecl|QualifiedName] (',' TypeName+=[ClassDecl|QualifiedName])*
		public Group getGroup() { return cGroup; }
		
		//':'
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }
		
		//TypeName+=[ClassDecl|QualifiedName]
		public Assignment getTypeNameAssignment_1() { return cTypeNameAssignment_1; }
		
		//[ClassDecl|QualifiedName]
		public CrossReference getTypeNameClassDeclCrossReference_1_0() { return cTypeNameClassDeclCrossReference_1_0; }
		
		//QualifiedName
		public RuleCall getTypeNameClassDeclQualifiedNameParserRuleCall_1_0_1() { return cTypeNameClassDeclQualifiedNameParserRuleCall_1_0_1; }
		
		//(',' TypeName+=[ClassDecl|QualifiedName])*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//TypeName+=[ClassDecl|QualifiedName]
		public Assignment getTypeNameAssignment_2_1() { return cTypeNameAssignment_2_1; }
		
		//[ClassDecl|QualifiedName]
		public CrossReference getTypeNameClassDeclCrossReference_2_1_0() { return cTypeNameClassDeclCrossReference_2_1_0; }
		
		//QualifiedName
		public RuleCall getTypeNameClassDeclQualifiedNameParserRuleCall_2_1_0_1() { return cTypeNameClassDeclQualifiedNameParserRuleCall_2_1_0_1; }
	}
	public class SuperTypeListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.SuperTypeList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSuperTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSuperTypeConstructedTypeParserRuleCall_1_0 = (RuleCall)cSuperTypeAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cSuperTypeAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cSuperTypeConstructedTypeParserRuleCall_2_1_0 = (RuleCall)cSuperTypeAssignment_2_1.eContents().get(0);
		
		///* ------------------- SuperTypes ---------------------------------- */ /* Any constriction on the polymorphic context has to be done by declaring the polymorphic context
		// * on the new type. If necessary the polymorphic context can be used within type constructors. In the simple case 
		// * this will be inferred . Required thought on checking the base types of the super types. At some points these
		// * need to be identical declarations. It is also necessary to allow EventB style type constructors at this
		// * point. e.g., an associative operator is a subtype of a closed Event-B total function.
		// */ SuperTypeList:
		//	':' superType+=ConstructedType (',' superType+=ConstructedType)*;
		@Override public ParserRule getRule() { return rule; }
		
		//':' superType+=ConstructedType (',' superType+=ConstructedType)*
		public Group getGroup() { return cGroup; }
		
		//':'
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }
		
		//superType+=ConstructedType
		public Assignment getSuperTypeAssignment_1() { return cSuperTypeAssignment_1; }
		
		//ConstructedType
		public RuleCall getSuperTypeConstructedTypeParserRuleCall_1_0() { return cSuperTypeConstructedTypeParserRuleCall_1_0; }
		
		//(',' superType+=ConstructedType)*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//superType+=ConstructedType
		public Assignment getSuperTypeAssignment_2_1() { return cSuperTypeAssignment_2_1; }
		
		//ConstructedType
		public RuleCall getSuperTypeConstructedTypeParserRuleCall_2_1_0() { return cSuperTypeConstructedTypeParserRuleCall_2_1_0; }
	}
	public class ConstructedTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.ConstructedType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeTypeConstructorParserRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cConstructorsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Alternatives cConstructorsAlternatives_1_0_0 = (Alternatives)cConstructorsAssignment_1_0.eContents().get(0);
		private final Keyword cConstructorsMultiplicationSignKeyword_1_0_0_0 = (Keyword)cConstructorsAlternatives_1_0_0.eContents().get(0);
		private final Keyword cConstructorsRightwardsArrowKeyword_1_0_0_1 = (Keyword)cConstructorsAlternatives_1_0_0.eContents().get(1);
		private final Keyword cConstructorsPrivateUseAreaE102Keyword_1_0_0_2 = (Keyword)cConstructorsAlternatives_1_0_0.eContents().get(2);
		private final Keyword cConstructorsPrivateUseAreaE100Keyword_1_0_0_3 = (Keyword)cConstructorsAlternatives_1_0_0.eContents().get(3);
		private final Keyword cConstructorsLeftRightArrowKeyword_1_0_0_4 = (Keyword)cConstructorsAlternatives_1_0_0.eContents().get(4);
		private final Keyword cConstructorsRightwardsTwoHeadedArrowWithTailKeyword_1_0_0_5 = (Keyword)cConstructorsAlternatives_1_0_0.eContents().get(5);
		private final Keyword cConstructorsRightwardsArrowWithVerticalStrokeKeyword_1_0_0_6 = (Keyword)cConstructorsAlternatives_1_0_0.eContents().get(6);
		private final Keyword cConstructorsRightwardsArrowWithTailKeyword_1_0_0_7 = (Keyword)cConstructorsAlternatives_1_0_0.eContents().get(7);
		private final Keyword cConstructorsRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_1_0_0_8 = (Keyword)cConstructorsAlternatives_1_0_0.eContents().get(8);
		private final Keyword cConstructorsRightwardsTwoHeadedArrowKeyword_1_0_0_9 = (Keyword)cConstructorsAlternatives_1_0_0.eContents().get(9);
		private final Assignment cTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypeConstructedTypeParserRuleCall_1_1_0 = (RuleCall)cTypeAssignment_1_1.eContents().get(0);
		
		///* Along with the normal Event-B type operator, and new B++ types the  */ ConstructedType:
		//	type+=TypeConstructor (constructors+=('×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠')
		//	type+=ConstructedType)?;
		@Override public ParserRule getRule() { return rule; }
		
		//type+=TypeConstructor (constructors+=('×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠') type+=ConstructedType)?
		public Group getGroup() { return cGroup; }
		
		//type+=TypeConstructor
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//TypeConstructor
		public RuleCall getTypeTypeConstructorParserRuleCall_0_0() { return cTypeTypeConstructorParserRuleCall_0_0; }
		
		//(constructors+=('×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠') type+=ConstructedType)?
		public Group getGroup_1() { return cGroup_1; }
		
		//constructors+=('×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠')
		public Assignment getConstructorsAssignment_1_0() { return cConstructorsAssignment_1_0; }
		
		//('×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠')
		public Alternatives getConstructorsAlternatives_1_0_0() { return cConstructorsAlternatives_1_0_0; }
		
		//'×'
		public Keyword getConstructorsMultiplicationSignKeyword_1_0_0_0() { return cConstructorsMultiplicationSignKeyword_1_0_0_0; }
		
		//'→'
		public Keyword getConstructorsRightwardsArrowKeyword_1_0_0_1() { return cConstructorsRightwardsArrowKeyword_1_0_0_1; }
		
		//''
		public Keyword getConstructorsPrivateUseAreaE102Keyword_1_0_0_2() { return cConstructorsPrivateUseAreaE102Keyword_1_0_0_2; }
		
		//''
		public Keyword getConstructorsPrivateUseAreaE100Keyword_1_0_0_3() { return cConstructorsPrivateUseAreaE100Keyword_1_0_0_3; }
		
		//'↔'
		public Keyword getConstructorsLeftRightArrowKeyword_1_0_0_4() { return cConstructorsLeftRightArrowKeyword_1_0_0_4; }
		
		//'⤖'
		public Keyword getConstructorsRightwardsTwoHeadedArrowWithTailKeyword_1_0_0_5() { return cConstructorsRightwardsTwoHeadedArrowWithTailKeyword_1_0_0_5; }
		
		//'⇸'
		public Keyword getConstructorsRightwardsArrowWithVerticalStrokeKeyword_1_0_0_6() { return cConstructorsRightwardsArrowWithVerticalStrokeKeyword_1_0_0_6; }
		
		//'↣'
		public Keyword getConstructorsRightwardsArrowWithTailKeyword_1_0_0_7() { return cConstructorsRightwardsArrowWithTailKeyword_1_0_0_7; }
		
		//'⤀'
		public Keyword getConstructorsRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_1_0_0_8() { return cConstructorsRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_1_0_0_8; }
		
		//'↠'
		public Keyword getConstructorsRightwardsTwoHeadedArrowKeyword_1_0_0_9() { return cConstructorsRightwardsTwoHeadedArrowKeyword_1_0_0_9; }
		
		//type+=ConstructedType
		public Assignment getTypeAssignment_1_1() { return cTypeAssignment_1_1; }
		
		//ConstructedType
		public RuleCall getTypeConstructedTypeParserRuleCall_1_1_0() { return cTypeConstructedTypeParserRuleCall_1_1_0; }
	}
	public class TypeConstructorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.TypeConstructor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeNameGenNameCrossReference_0_0 = (CrossReference)cTypeNameAssignment_0.eContents().get(0);
		private final RuleCall cTypeNameGenNameQualifiedNameParserRuleCall_0_0_1 = (RuleCall)cTypeNameGenNameCrossReference_0_0.eContents().get(1);
		private final Assignment cContextAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cContextTypeDeclContextParserRuleCall_1_0 = (RuleCall)cContextAssignment_1.eContents().get(0);
		
		///* Type constructor has validation rules to check that there is no context when there is a polymorphic name, 
		// * and type checking on the polymorphic context. There is also  scope rule to check the usage of polymorphic types.
		// * Probably need to add the predicate type to this.
		// */ TypeConstructor:
		//	TypeName=[GenName|QualifiedName] context+=TypeDeclContext?;
		@Override public ParserRule getRule() { return rule; }
		
		//TypeName=[GenName|QualifiedName] context+=TypeDeclContext?
		public Group getGroup() { return cGroup; }
		
		//TypeName=[GenName|QualifiedName]
		public Assignment getTypeNameAssignment_0() { return cTypeNameAssignment_0; }
		
		//[GenName|QualifiedName]
		public CrossReference getTypeNameGenNameCrossReference_0_0() { return cTypeNameGenNameCrossReference_0_0; }
		
		//QualifiedName
		public RuleCall getTypeNameGenNameQualifiedNameParserRuleCall_0_0_1() { return cTypeNameGenNameQualifiedNameParserRuleCall_0_0_1; }
		
		//context+=TypeDeclContext?
		public Assignment getContextAssignment_1() { return cContextAssignment_1; }
		
		//TypeDeclContext
		public RuleCall getContextTypeDeclContextParserRuleCall_1_0() { return cContextTypeDeclContextParserRuleCall_1_0; }
	}
	public class TypeDeclContextElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.TypeDeclContext");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeNameConstructedTypeParserRuleCall_1_0 = (RuleCall)cTypeNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cTypeNameAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cTypeNameConstructedTypeParserRuleCall_2_1_0 = (RuleCall)cTypeNameAssignment_2_1.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//TypeDeclContext:
		//	'<' TypeName+=ConstructedType (',' TypeName+=ConstructedType)* '>';
		@Override public ParserRule getRule() { return rule; }
		
		//'<' TypeName+=ConstructedType (',' TypeName+=ConstructedType)* '>'
		public Group getGroup() { return cGroup; }
		
		//'<'
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }
		
		//TypeName+=ConstructedType
		public Assignment getTypeNameAssignment_1() { return cTypeNameAssignment_1; }
		
		//ConstructedType
		public RuleCall getTypeNameConstructedTypeParserRuleCall_1_0() { return cTypeNameConstructedTypeParserRuleCall_1_0; }
		
		//(',' TypeName+=ConstructedType)*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//TypeName+=ConstructedType
		public Assignment getTypeNameAssignment_2_1() { return cTypeNameAssignment_2_1; }
		
		//ConstructedType
		public RuleCall getTypeNameConstructedTypeParserRuleCall_2_1_0() { return cTypeNameConstructedTypeParserRuleCall_2_1_0; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_3() { return cGreaterThanSignKeyword_3; }
	}
	public class TypeStructureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.TypeStructure");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVariablesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVariablesTypedVariableListParserRuleCall_1_0 = (RuleCall)cVariablesAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		///* -------------------- Type Structure ---------------------------------- */ TypeStructure:
		//	'(' variables=TypedVariableList ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' variables=TypedVariableList ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//variables=TypedVariableList
		public Assignment getVariablesAssignment_1() { return cVariablesAssignment_1; }
		
		//TypedVariableList
		public RuleCall getVariablesTypedVariableListParserRuleCall_1_0() { return cVariablesTypedVariableListParserRuleCall_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class WhereElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.Where");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhereKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpessionsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpessionsQuantifierParserRuleCall_1_0 = (RuleCall)cExpessionsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cSemicolonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cExpressionsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cExpressionsRootExpressionParserRuleCall_2_1_0 = (RuleCall)cExpressionsAssignment_2_1.eContents().get(0);
		
		///* -------------------- Where Statement -------------------------------- */ /* Type checking (which is not implemented yet) is used to type check that Expression returns a 
		// * predicate. Expression has not yet been written, but is far too general to be included in the where
		// * statement.
		// */ Where:
		//	'where' expessions+=Quantifier (';' expressions+=RootExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//'where' expessions+=Quantifier (';' expressions+=RootExpression)*
		public Group getGroup() { return cGroup; }
		
		//'where'
		public Keyword getWhereKeyword_0() { return cWhereKeyword_0; }
		
		//expessions+=Quantifier
		public Assignment getExpessionsAssignment_1() { return cExpessionsAssignment_1; }
		
		//Quantifier
		public RuleCall getExpessionsQuantifierParserRuleCall_1_0() { return cExpessionsQuantifierParserRuleCall_1_0; }
		
		//(';' expressions+=RootExpression)*
		public Group getGroup_2() { return cGroup_2; }
		
		//';'
		public Keyword getSemicolonKeyword_2_0() { return cSemicolonKeyword_2_0; }
		
		//expressions+=RootExpression
		public Assignment getExpressionsAssignment_2_1() { return cExpressionsAssignment_2_1; }
		
		//RootExpression
		public RuleCall getExpressionsRootExpressionParserRuleCall_2_1_0() { return cExpressionsRootExpressionParserRuleCall_2_1_0; }
	}
	public class DatatypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.Datatype");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDatatypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cContextAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cContextPolyContextParserRuleCall_2_0 = (RuleCall)cContextAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cVerticalLineKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cConstructorsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cConstructorsDatatypeConstructorParserRuleCall_3_1_0 = (RuleCall)cConstructorsAssignment_3_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cBodyElementsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cBodyElementsTypeBodyElementsParserRuleCall_5_0 = (RuleCall)cBodyElementsAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		///* ---------------------- Datatype declarations -------------------------- */ Datatype:
		//	'Datatype' name=ID context=PolyContext? ('|' constructors+=DatatypeConstructor)+ '{' bodyElements+=TypeBodyElements*
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'Datatype' name=ID context=PolyContext? ('|' constructors+=DatatypeConstructor)+ '{' bodyElements+=TypeBodyElements* '}'
		public Group getGroup() { return cGroup; }
		
		//'Datatype'
		public Keyword getDatatypeKeyword_0() { return cDatatypeKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//context=PolyContext?
		public Assignment getContextAssignment_2() { return cContextAssignment_2; }
		
		//PolyContext
		public RuleCall getContextPolyContextParserRuleCall_2_0() { return cContextPolyContextParserRuleCall_2_0; }
		
		//('|' constructors+=DatatypeConstructor)+
		public Group getGroup_3() { return cGroup_3; }
		
		//'|'
		public Keyword getVerticalLineKeyword_3_0() { return cVerticalLineKeyword_3_0; }
		
		//constructors+=DatatypeConstructor
		public Assignment getConstructorsAssignment_3_1() { return cConstructorsAssignment_3_1; }
		
		//DatatypeConstructor
		public RuleCall getConstructorsDatatypeConstructorParserRuleCall_3_1_0() { return cConstructorsDatatypeConstructorParserRuleCall_3_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//bodyElements+=TypeBodyElements*
		public Assignment getBodyElementsAssignment_5() { return cBodyElementsAssignment_5; }
		
		//TypeBodyElements
		public RuleCall getBodyElementsTypeBodyElementsParserRuleCall_5_0() { return cBodyElementsTypeBodyElementsParserRuleCall_5_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}
	public class DatatypeConstructorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.DatatypeConstructor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cDeconsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cDeconsTypedVariableListParserRuleCall_1_1_0 = (RuleCall)cDeconsAssignment_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		///* PolyContext is the same as PolyContext used by the class declaration above. */ DatatypeConstructor:
		//	name=ID ('(' decons=TypedVariableList ')')?;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID ('(' decons=TypedVariableList ')')?
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//('(' decons=TypedVariableList ')')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//decons=TypedVariableList
		public Assignment getDeconsAssignment_1_1() { return cDeconsAssignment_1_1; }
		
		//TypedVariableList
		public RuleCall getDeconsTypedVariableListParserRuleCall_1_1_0() { return cDeconsTypedVariableListParserRuleCall_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}
	public class ExtendElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.Extend");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExtendKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cNameClassDeclCrossReference_1_0 = (CrossReference)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameClassDeclQualifiedNameParserRuleCall_1_0_1 = (RuleCall)cNameClassDeclCrossReference_1_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExtensionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExtensionIDTerminalRuleCall_3_0 = (RuleCall)cExtensionAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cLeftCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cBodyElementsAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cBodyElementsTypeBodyElementsParserRuleCall_6_0 = (RuleCall)cBodyElementsAssignment_6.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		///* ------------------------ Extension statement ---------------------------- */ Extend:
		//	'Extend' name=[ClassDecl|QualifiedName] '(' extension=ID ')' '{' bodyElements+=TypeBodyElements* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'Extend' name=[ClassDecl|QualifiedName] '(' extension=ID ')' '{' bodyElements+=TypeBodyElements* '}'
		public Group getGroup() { return cGroup; }
		
		//'Extend'
		public Keyword getExtendKeyword_0() { return cExtendKeyword_0; }
		
		//name=[ClassDecl|QualifiedName]
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//[ClassDecl|QualifiedName]
		public CrossReference getNameClassDeclCrossReference_1_0() { return cNameClassDeclCrossReference_1_0; }
		
		//QualifiedName
		public RuleCall getNameClassDeclQualifiedNameParserRuleCall_1_0_1() { return cNameClassDeclQualifiedNameParserRuleCall_1_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//extension=ID
		public Assignment getExtensionAssignment_3() { return cExtensionAssignment_3; }
		
		//ID
		public RuleCall getExtensionIDTerminalRuleCall_3_0() { return cExtensionIDTerminalRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_5() { return cLeftCurlyBracketKeyword_5; }
		
		//bodyElements+=TypeBodyElements*
		public Assignment getBodyElementsAssignment_6() { return cBodyElementsAssignment_6; }
		
		//TypeBodyElements
		public RuleCall getBodyElementsTypeBodyElementsParserRuleCall_6_0() { return cBodyElementsTypeBodyElementsParserRuleCall_6_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_7() { return cRightCurlyBracketKeyword_7; }
	}
	public class TypeBodyElementsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.TypeBodyElements");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cFunctionsAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cFunctionsFunctionDeclParserRuleCall_0_0 = (RuleCall)cFunctionsAssignment_0.eContents().get(0);
		private final Assignment cTheoremsAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cTheoremsTheoremBodyParserRuleCall_1_0 = (RuleCall)cTheoremsAssignment_1.eContents().get(0);
		
		///* ------------------------ TypeBodyElements ------------------------------- */ TypeBodyElements:
		//	functions+=FunctionDecl | theorems+=TheoremBody;
		@Override public ParserRule getRule() { return rule; }
		
		//functions+=FunctionDecl | theorems+=TheoremBody
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//functions+=FunctionDecl
		public Assignment getFunctionsAssignment_0() { return cFunctionsAssignment_0; }
		
		//FunctionDecl
		public RuleCall getFunctionsFunctionDeclParserRuleCall_0_0() { return cFunctionsFunctionDeclParserRuleCall_0_0; }
		
		//theorems+=TheoremBody
		public Assignment getTheoremsAssignment_1() { return cTheoremsAssignment_1; }
		
		//TheoremBody
		public RuleCall getTheoremsTheoremBodyParserRuleCall_1_0() { return cTheoremsTheoremBodyParserRuleCall_1_0; }
	}
	public class FunctionDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.FunctionDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameFunctionNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cContextAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cContextPolyContextParserRuleCall_1_0 = (RuleCall)cContextAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cVarListAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVarListTypedVariableListParserRuleCall_3_0 = (RuleCall)cVarListAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cColonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cReturnTypeAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cReturnTypeTypeConstructorParserRuleCall_6_0 = (RuleCall)cReturnTypeAssignment_6.eContents().get(0);
		private final Assignment cInfixAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final Keyword cInfixINFIXKeyword_7_0 = (Keyword)cInfixAssignment_7.eContents().get(0);
		private final Assignment cPrecedenceAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cPrecedenceINTTerminalRuleCall_8_0 = (RuleCall)cPrecedenceAssignment_8.eContents().get(0);
		private final Assignment cExprAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cExprRootExpressionParserRuleCall_9_0 = (RuleCall)cExprAssignment_9.eContents().get(0);
		
		///*------------------------- Functions --------------------------------- */ FunctionDecl:
		//	name=FunctionName context=PolyContext? '(' varList=TypedVariableList? ')' ':' returnType=TypeConstructor
		//	infix='INFIX'? precedence=INT? expr=RootExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//name=FunctionName context=PolyContext? '(' varList=TypedVariableList? ')' ':' returnType=TypeConstructor infix='INFIX'?
		//precedence=INT? expr=RootExpression
		public Group getGroup() { return cGroup; }
		
		//name=FunctionName
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//FunctionName
		public RuleCall getNameFunctionNameParserRuleCall_0_0() { return cNameFunctionNameParserRuleCall_0_0; }
		
		//context=PolyContext?
		public Assignment getContextAssignment_1() { return cContextAssignment_1; }
		
		//PolyContext
		public RuleCall getContextPolyContextParserRuleCall_1_0() { return cContextPolyContextParserRuleCall_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//varList=TypedVariableList?
		public Assignment getVarListAssignment_3() { return cVarListAssignment_3; }
		
		//TypedVariableList
		public RuleCall getVarListTypedVariableListParserRuleCall_3_0() { return cVarListTypedVariableListParserRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
		
		//':'
		public Keyword getColonKeyword_5() { return cColonKeyword_5; }
		
		//returnType=TypeConstructor
		public Assignment getReturnTypeAssignment_6() { return cReturnTypeAssignment_6; }
		
		//TypeConstructor
		public RuleCall getReturnTypeTypeConstructorParserRuleCall_6_0() { return cReturnTypeTypeConstructorParserRuleCall_6_0; }
		
		//infix='INFIX'?
		public Assignment getInfixAssignment_7() { return cInfixAssignment_7; }
		
		//'INFIX'
		public Keyword getInfixINFIXKeyword_7_0() { return cInfixINFIXKeyword_7_0; }
		
		//precedence=INT?
		public Assignment getPrecedenceAssignment_8() { return cPrecedenceAssignment_8; }
		
		//INT
		public RuleCall getPrecedenceINTTerminalRuleCall_8_0() { return cPrecedenceINTTerminalRuleCall_8_0; }
		
		//expr=RootExpression
		public Assignment getExprAssignment_9() { return cExprAssignment_9; }
		
		//RootExpression
		public RuleCall getExprRootExpressionParserRuleCall_9_0() { return cExprRootExpressionParserRuleCall_9_0; }
	}
	public class FunctionNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.FunctionName");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//FunctionName:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class MatchStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.MatchStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMatchKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cMatchAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cMatchDatatypeConstructorCrossReference_1_0 = (CrossReference)cMatchAssignment_1.eContents().get(0);
		private final RuleCall cMatchDatatypeConstructorIDTerminalRuleCall_1_0_1 = (RuleCall)cMatchDatatypeConstructorCrossReference_1_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cInductCaseAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cInductCaseMatchCaseParserRuleCall_3_0 = (RuleCall)cInductCaseAssignment_3.eContents().get(0);
		private final Assignment cInductCaseAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cInductCaseMatchCaseParserRuleCall_4_0 = (RuleCall)cInductCaseAssignment_4.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//MatchStatement:
		//	'match' match=[DatatypeConstructor] '{'
		//	inductCase+=MatchCase inductCase+=MatchCase* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'match' match=[DatatypeConstructor] '{' inductCase+=MatchCase inductCase+=MatchCase* '}'
		public Group getGroup() { return cGroup; }
		
		//'match'
		public Keyword getMatchKeyword_0() { return cMatchKeyword_0; }
		
		//match=[DatatypeConstructor]
		public Assignment getMatchAssignment_1() { return cMatchAssignment_1; }
		
		//[DatatypeConstructor]
		public CrossReference getMatchDatatypeConstructorCrossReference_1_0() { return cMatchDatatypeConstructorCrossReference_1_0; }
		
		//ID
		public RuleCall getMatchDatatypeConstructorIDTerminalRuleCall_1_0_1() { return cMatchDatatypeConstructorIDTerminalRuleCall_1_0_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//inductCase+=MatchCase
		public Assignment getInductCaseAssignment_3() { return cInductCaseAssignment_3; }
		
		//MatchCase
		public RuleCall getInductCaseMatchCaseParserRuleCall_3_0() { return cInductCaseMatchCaseParserRuleCall_3_0; }
		
		//inductCase+=MatchCase*
		public Assignment getInductCaseAssignment_4() { return cInductCaseAssignment_4; }
		
		//MatchCase
		public RuleCall getInductCaseMatchCaseParserRuleCall_4_0() { return cInductCaseMatchCaseParserRuleCall_4_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}
	public class MatchCaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.MatchCase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVerticalLineKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDeconNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cDeconNameTypedVariableCrossReference_1_0 = (CrossReference)cDeconNameAssignment_1.eContents().get(0);
		private final RuleCall cDeconNameTypedVariableIDTerminalRuleCall_1_0_1 = (RuleCall)cDeconNameTypedVariableCrossReference_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cVariablesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cVariablesTypedVariableParserRuleCall_2_1_0 = (RuleCall)cVariablesAssignment_2_1.eContents().get(0);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final Keyword cCommaKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cVariablesAssignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final RuleCall cVariablesTypedVariableParserRuleCall_2_2_1_0 = (RuleCall)cVariablesAssignment_2_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cExprAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cExprRootExpressionParserRuleCall_4_0 = (RuleCall)cExprAssignment_4.eContents().get(0);
		
		//MatchCase:
		//	'|' deconName=[TypedVariable] ('(' variables+=TypedVariable (',' variables+=TypedVariable)* ')')? ':'
		//	expr=RootExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//'|' deconName=[TypedVariable] ('(' variables+=TypedVariable (',' variables+=TypedVariable)* ')')? ':'
		//expr=RootExpression
		public Group getGroup() { return cGroup; }
		
		//'|'
		public Keyword getVerticalLineKeyword_0() { return cVerticalLineKeyword_0; }
		
		//deconName=[TypedVariable]
		public Assignment getDeconNameAssignment_1() { return cDeconNameAssignment_1; }
		
		//[TypedVariable]
		public CrossReference getDeconNameTypedVariableCrossReference_1_0() { return cDeconNameTypedVariableCrossReference_1_0; }
		
		//ID
		public RuleCall getDeconNameTypedVariableIDTerminalRuleCall_1_0_1() { return cDeconNameTypedVariableIDTerminalRuleCall_1_0_1; }
		
		//('(' variables+=TypedVariable (',' variables+=TypedVariable)* ')')?
		public Group getGroup_2() { return cGroup_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }
		
		//variables+=TypedVariable
		public Assignment getVariablesAssignment_2_1() { return cVariablesAssignment_2_1; }
		
		//TypedVariable
		public RuleCall getVariablesTypedVariableParserRuleCall_2_1_0() { return cVariablesTypedVariableParserRuleCall_2_1_0; }
		
		//(',' variables+=TypedVariable)*
		public Group getGroup_2_2() { return cGroup_2_2; }
		
		//','
		public Keyword getCommaKeyword_2_2_0() { return cCommaKeyword_2_2_0; }
		
		//variables+=TypedVariable
		public Assignment getVariablesAssignment_2_2_1() { return cVariablesAssignment_2_2_1; }
		
		//TypedVariable
		public RuleCall getVariablesTypedVariableParserRuleCall_2_2_1_0() { return cVariablesTypedVariableParserRuleCall_2_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_3() { return cRightParenthesisKeyword_2_3; }
		
		//':'
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }
		
		//expr=RootExpression
		public Assignment getExprAssignment_4() { return cExprAssignment_4; }
		
		//RootExpression
		public RuleCall getExprRootExpressionParserRuleCall_4_0() { return cExprRootExpressionParserRuleCall_4_0; }
	}
	public class TheoremBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.TheoremBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTheoremsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTheoremDeclAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTheoremDeclTheoremDeclParserRuleCall_2_0 = (RuleCall)cTheoremDeclAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		///* ----------------------------- Theorems -------------------------*/ TheoremBody:
		//	'Theorems' '{' theoremDecl+=TheoremDecl+ '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'Theorems' '{' theoremDecl+=TheoremDecl+ '}'
		public Group getGroup() { return cGroup; }
		
		//'Theorems'
		public Keyword getTheoremsKeyword_0() { return cTheoremsKeyword_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//theoremDecl+=TheoremDecl+
		public Assignment getTheoremDeclAssignment_2() { return cTheoremDeclAssignment_2; }
		
		//TheoremDecl
		public RuleCall getTheoremDeclTheoremDeclParserRuleCall_2_0() { return cTheoremDeclTheoremDeclParserRuleCall_2_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class TheoremDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.TheoremDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameTHM_NAMEParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprRootExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		///* Type check that the expression is a predicate expression. From a lexing point
		// * of view the semicolon is necessary because the THM_NAME rule is not good enough.
		// */ TheoremDecl:
		//	name=THM_NAME expr=RootExpression ';';
		@Override public ParserRule getRule() { return rule; }
		
		//name=THM_NAME expr=RootExpression ';'
		public Group getGroup() { return cGroup; }
		
		//name=THM_NAME
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//THM_NAME
		public RuleCall getNameTHM_NAMEParserRuleCall_0_0() { return cNameTHM_NAMEParserRuleCall_0_0; }
		
		//expr=RootExpression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }
		
		//RootExpression
		public RuleCall getExprRootExpressionParserRuleCall_1_0() { return cExprRootExpressionParserRuleCall_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}
	public class TypedVariableListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.TypedVariableList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVariablesOfTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVariablesOfTypeVariableTypingParserRuleCall_0_0 = (RuleCall)cVariablesOfTypeAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cVariablesOfTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cVariablesOfTypeVariableTypingParserRuleCall_1_1_0 = (RuleCall)cVariablesOfTypeAssignment_1_1.eContents().get(0);
		
		//TypedVariableList:
		//	variablesOfType+=VariableTyping (',' variablesOfType+=VariableTyping)*;
		@Override public ParserRule getRule() { return rule; }
		
		//variablesOfType+=VariableTyping (',' variablesOfType+=VariableTyping)*
		public Group getGroup() { return cGroup; }
		
		//variablesOfType+=VariableTyping
		public Assignment getVariablesOfTypeAssignment_0() { return cVariablesOfTypeAssignment_0; }
		
		//VariableTyping
		public RuleCall getVariablesOfTypeVariableTypingParserRuleCall_0_0() { return cVariablesOfTypeVariableTypingParserRuleCall_0_0; }
		
		//(',' variablesOfType+=VariableTyping)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//variablesOfType+=VariableTyping
		public Assignment getVariablesOfTypeAssignment_1_1() { return cVariablesOfTypeAssignment_1_1; }
		
		//VariableTyping
		public RuleCall getVariablesOfTypeVariableTypingParserRuleCall_1_1_0() { return cVariablesOfTypeVariableTypingParserRuleCall_1_1_0; }
	}
	public class VariableTypingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.VariableTyping");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeVarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeVarTypedVariableParserRuleCall_0_0 = (RuleCall)cTypeVarAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTypeVarAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypeVarTypedVariableParserRuleCall_1_1_0 = (RuleCall)cTypeVarAssignment_1_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeConstructedTypeParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		
		//VariableTyping:
		//	typeVar+=TypedVariable (',' typeVar+=TypedVariable)* ':' type=ConstructedType;
		@Override public ParserRule getRule() { return rule; }
		
		//typeVar+=TypedVariable (',' typeVar+=TypedVariable)* ':' type=ConstructedType
		public Group getGroup() { return cGroup; }
		
		//typeVar+=TypedVariable
		public Assignment getTypeVarAssignment_0() { return cTypeVarAssignment_0; }
		
		//TypedVariable
		public RuleCall getTypeVarTypedVariableParserRuleCall_0_0() { return cTypeVarTypedVariableParserRuleCall_0_0; }
		
		//(',' typeVar+=TypedVariable)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//typeVar+=TypedVariable
		public Assignment getTypeVarAssignment_1_1() { return cTypeVarAssignment_1_1; }
		
		//TypedVariable
		public RuleCall getTypeVarTypedVariableParserRuleCall_1_1_0() { return cTypeVarTypedVariableParserRuleCall_1_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//type=ConstructedType
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }
		
		//ConstructedType
		public RuleCall getTypeConstructedTypeParserRuleCall_3_0() { return cTypeConstructedTypeParserRuleCall_3_0; }
	}
	public class TypedVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.TypedVariable");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//TypedVariable:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class LambdaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.Lambda");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cQTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cQTypeGreekSmallLetterLamdaKeyword_0_0 = (Keyword)cQTypeAssignment_0.eContents().get(0);
		private final Assignment cContextAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cContextPolyContextParserRuleCall_1_0 = (RuleCall)cContextAssignment_1.eContents().get(0);
		private final Assignment cVarListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVarListTypedVariableListParserRuleCall_2_0 = (RuleCall)cVarListAssignment_2.eContents().get(0);
		private final Keyword cVerticalLineKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cExprAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cExprRootExpressionParserRuleCall_4_0 = (RuleCall)cExprAssignment_4.eContents().get(0);
		
		///* --------------------------- Expressions -------------------------- */
		///* --------------------------- Lambda and Quantifier ---------------- */
		///* The structure of Lambda and Quantifier are so similar that they're going to share a class */ Lambda QuantLambda:
		//	qType='λ' context=PolyContext? varList=TypedVariableList '|' expr=RootExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//qType='λ' context=PolyContext? varList=TypedVariableList '|' expr=RootExpression
		public Group getGroup() { return cGroup; }
		
		//qType='λ'
		public Assignment getQTypeAssignment_0() { return cQTypeAssignment_0; }
		
		//'λ'
		public Keyword getQTypeGreekSmallLetterLamdaKeyword_0_0() { return cQTypeGreekSmallLetterLamdaKeyword_0_0; }
		
		//context=PolyContext?
		public Assignment getContextAssignment_1() { return cContextAssignment_1; }
		
		//PolyContext
		public RuleCall getContextPolyContextParserRuleCall_1_0() { return cContextPolyContextParserRuleCall_1_0; }
		
		//varList=TypedVariableList
		public Assignment getVarListAssignment_2() { return cVarListAssignment_2; }
		
		//TypedVariableList
		public RuleCall getVarListTypedVariableListParserRuleCall_2_0() { return cVarListTypedVariableListParserRuleCall_2_0; }
		
		//'|'
		public Keyword getVerticalLineKeyword_3() { return cVerticalLineKeyword_3; }
		
		//expr=RootExpression
		public Assignment getExprAssignment_4() { return cExprAssignment_4; }
		
		//RootExpression
		public RuleCall getExprRootExpressionParserRuleCall_4_0() { return cExprRootExpressionParserRuleCall_4_0; }
	}
	public class QuantifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.Quantifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cQTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cQTypeAlternatives_0_0 = (Alternatives)cQTypeAssignment_0.eContents().get(0);
		private final Keyword cQTypeForAllKeyword_0_0_0 = (Keyword)cQTypeAlternatives_0_0.eContents().get(0);
		private final Keyword cQTypeThereExistsKeyword_0_0_1 = (Keyword)cQTypeAlternatives_0_0.eContents().get(1);
		private final Assignment cContextAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cContextPolyContextParserRuleCall_1_0 = (RuleCall)cContextAssignment_1.eContents().get(0);
		private final Assignment cVarListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVarListTypedVariableListParserRuleCall_2_0 = (RuleCall)cVarListAssignment_2.eContents().get(0);
		private final Keyword cMiddleDotKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cExprAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cExprRootExpressionParserRuleCall_4_0 = (RuleCall)cExprAssignment_4.eContents().get(0);
		
		//Quantifier QuantLambda:
		//	qType=('∀' | '∃') context=PolyContext? varList=TypedVariableList '·' expr=RootExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//qType=('∀' | '∃') context=PolyContext? varList=TypedVariableList '·' expr=RootExpression
		public Group getGroup() { return cGroup; }
		
		//qType=('∀' | '∃')
		public Assignment getQTypeAssignment_0() { return cQTypeAssignment_0; }
		
		//('∀' | '∃')
		public Alternatives getQTypeAlternatives_0_0() { return cQTypeAlternatives_0_0; }
		
		//'∀'
		public Keyword getQTypeForAllKeyword_0_0_0() { return cQTypeForAllKeyword_0_0_0; }
		
		//'∃'
		public Keyword getQTypeThereExistsKeyword_0_0_1() { return cQTypeThereExistsKeyword_0_0_1; }
		
		//context=PolyContext?
		public Assignment getContextAssignment_1() { return cContextAssignment_1; }
		
		//PolyContext
		public RuleCall getContextPolyContextParserRuleCall_1_0() { return cContextPolyContextParserRuleCall_1_0; }
		
		//varList=TypedVariableList
		public Assignment getVarListAssignment_2() { return cVarListAssignment_2; }
		
		//TypedVariableList
		public RuleCall getVarListTypedVariableListParserRuleCall_2_0() { return cVarListTypedVariableListParserRuleCall_2_0; }
		
		//'·'
		public Keyword getMiddleDotKeyword_3() { return cMiddleDotKeyword_3; }
		
		//expr=RootExpression
		public Assignment getExprAssignment_4() { return cExprAssignment_4; }
		
		//RootExpression
		public RuleCall getExprRootExpressionParserRuleCall_4_0() { return cExprRootExpressionParserRuleCall_4_0; }
	}
	public class RootExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.RootExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLambdaParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cQuantifierParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cInfixParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cMatchStatementParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//RootExpression Expression:
		//	Lambda | Quantifier | Infix | MatchStatement;
		@Override public ParserRule getRule() { return rule; }
		
		//Lambda | Quantifier | Infix | MatchStatement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Lambda
		public RuleCall getLambdaParserRuleCall_0() { return cLambdaParserRuleCall_0; }
		
		//Quantifier
		public RuleCall getQuantifierParserRuleCall_1() { return cQuantifierParserRuleCall_1; }
		
		//Infix
		public RuleCall getInfixParserRuleCall_2() { return cInfixParserRuleCall_2; }
		
		//MatchStatement
		public RuleCall getMatchStatementParserRuleCall_3() { return cMatchStatementParserRuleCall_3; }
	}
	public class PrefixElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.Prefix");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNamePrefixBuiltInParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cElemAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cElemElementParserRuleCall_1_0 = (RuleCall)cElemAssignment_1.eContents().get(0);
		
		///* ---------------------- *Fix ------------------------------ */ Prefix:
		//	name=PrefixBuiltIn elem=Element;
		@Override public ParserRule getRule() { return rule; }
		
		//name=PrefixBuiltIn elem=Element
		public Group getGroup() { return cGroup; }
		
		//name=PrefixBuiltIn
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//PrefixBuiltIn
		public RuleCall getNamePrefixBuiltInParserRuleCall_0_0() { return cNamePrefixBuiltInParserRuleCall_0_0; }
		
		//elem=Element
		public Assignment getElemAssignment_1() { return cElemAssignment_1; }
		
		//Element
		public RuleCall getElemElementParserRuleCall_1_0() { return cElemElementParserRuleCall_1_0; }
	}
	public class PrefixBuiltInElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.PrefixBuiltIn");
		private final Keyword cNotSignKeyword = (Keyword)rule.eContents().get(1);
		
		//PrefixBuiltIn:
		//	'¬';
		@Override public ParserRule getRule() { return rule; }
		
		//'¬'
		public Keyword getNotSignKeyword() { return cNotSignKeyword; }
	}
	public class InfixElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.Infix");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cElementParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cInfixLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Assignment cFuncNameAssignment_1_1_0 = (Assignment)cAlternatives_1_1.eContents().get(0);
		private final CrossReference cFuncNameFunctionNameCrossReference_1_1_0_0 = (CrossReference)cFuncNameAssignment_1_1_0.eContents().get(0);
		private final RuleCall cFuncNameFunctionNameIDTerminalRuleCall_1_1_0_0_1 = (RuleCall)cFuncNameFunctionNameCrossReference_1_1_0_0.eContents().get(1);
		private final Assignment cOpNameAssignment_1_1_1 = (Assignment)cAlternatives_1_1.eContents().get(1);
		private final RuleCall cOpNameInbuiltInfixParserRuleCall_1_1_1_0 = (RuleCall)cOpNameAssignment_1_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightElementParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		///* Infix operators cause problems, there are two issues one is avoiding left recursion this 
		// * is covered adequately here: https://www.eclipse.org/Xtext/documentation/307_special_languages.html#expressions 
		// * The second issue is precedence, this is also covered in the link above, however, implementing it in the 
		// * way suggested above will not scale to the creation of ones own infix functions, instead the initial implementation
		// * will require brackets for precedence. After that a system will be implemented where each infix operator will 
		// * be given a precedence value with higher values being higher precedence. It looks like this can be done by
		// * changing the parser using the MyDSLRuntimeModule to build the abstract syntax tree based on the value of the 
		// * operators.
		// * Before the precedence code is written into a parser override, all the expressions are in effect right bracketed,
		// * as you may expect from a language that is read from left to right.
		// * 
		// * TODO: Programmatically check that the function is an infix function.
		// */ Infix Expression:
		//	Element ({Infix.left=current} (funcName=[FunctionName] | opName=InbuiltInfix) right=Element)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Element ({Infix.left=current} (funcName=[FunctionName] | opName=InbuiltInfix) right=Element)*
		public Group getGroup() { return cGroup; }
		
		//Element
		public RuleCall getElementParserRuleCall_0() { return cElementParserRuleCall_0; }
		
		//({Infix.left=current} (funcName=[FunctionName] | opName=InbuiltInfix) right=Element)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Infix.left=current}
		public Action getInfixLeftAction_1_0() { return cInfixLeftAction_1_0; }
		
		//funcName=[FunctionName] | opName=InbuiltInfix
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }
		
		//funcName=[FunctionName]
		public Assignment getFuncNameAssignment_1_1_0() { return cFuncNameAssignment_1_1_0; }
		
		//[FunctionName]
		public CrossReference getFuncNameFunctionNameCrossReference_1_1_0_0() { return cFuncNameFunctionNameCrossReference_1_1_0_0; }
		
		//ID
		public RuleCall getFuncNameFunctionNameIDTerminalRuleCall_1_1_0_0_1() { return cFuncNameFunctionNameIDTerminalRuleCall_1_1_0_0_1; }
		
		//opName=InbuiltInfix
		public Assignment getOpNameAssignment_1_1_1() { return cOpNameAssignment_1_1_1; }
		
		//InbuiltInfix
		public RuleCall getOpNameInbuiltInfixParserRuleCall_1_1_1_0() { return cOpNameInbuiltInfixParserRuleCall_1_1_1_0; }
		
		//right=Element
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Element
		public RuleCall getRightElementParserRuleCall_1_2_0() { return cRightElementParserRuleCall_1_2_0; }
	}
	public class ElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.Element");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBracketParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPrefixParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cFunctionCallParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		///* currently it will not build because the quantifier is causing recursion I think. 
		// * I think that we need a quantifier free expression to solve the problem Similar to the way
		// * precedence is handled here: https://typefox.io/parsing-expressions-with-xtext
		// */ Element Expression:
		//	Bracket | Prefix | FunctionCall;
		@Override public ParserRule getRule() { return rule; }
		
		//Bracket | Prefix | FunctionCall
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Bracket
		public RuleCall getBracketParserRuleCall_0() { return cBracketParserRuleCall_0; }
		
		//Prefix
		public RuleCall getPrefixParserRuleCall_1() { return cPrefixParserRuleCall_1; }
		
		//FunctionCall
		public RuleCall getFunctionCallParserRuleCall_2() { return cFunctionCallParserRuleCall_2; }
	}
	public class BracketElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.Bracket");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cChildAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cChildRootExpressionParserRuleCall_1_0 = (RuleCall)cChildAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Bracket:
		//	'(' child=RootExpression ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' child=RootExpression ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//child=RootExpression
		public Assignment getChildAssignment_1() { return cChildAssignment_1; }
		
		//RootExpression
		public RuleCall getChildRootExpressionParserRuleCall_1_0() { return cChildRootExpressionParserRuleCall_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class FunctionCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.FunctionCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeInstAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeInstExpressionVariableCrossReference_0_0 = (CrossReference)cTypeInstAssignment_0.eContents().get(0);
		private final RuleCall cTypeInstExpressionVariableQualifiedNameParserRuleCall_0_0_1 = (RuleCall)cTypeInstExpressionVariableCrossReference_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cArgumentsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cArgumentsRootExpressionParserRuleCall_1_1_0 = (RuleCall)cArgumentsAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cCommaKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cArgumentsAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cArgumentsRootExpressionParserRuleCall_1_2_1_0 = (RuleCall)cArgumentsAssignment_1_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		///* This produces an interesting issue in parsing the program because it is necessary to distinguish between the following three
		// * scenarios: 
		// * A function call f(arguments)
		// * A infix function with a bracketed argument on the right 10 f (arguments)
		// * A function used without any arguments f add g 
		// * 
		// * To solve this functions can either be Prefix, Infix, or called with bracketed arguments. You cannot call a Infix function with bracketd 
		// * arguments. To do this you would need to write another function to make this call for you. In coq this is achieved when you declare a function
		// * you can add a operator name to the function, which is either infix or prefix, this again gives the two names for the function allowing 
		// * it to be called either as an operator or a functional call.
		// * 
		// * This expressions needs a lot of programmatic checking! Starting with the count of the arguments, followed by type checking the arguments.
		// */ FunctionCall:
		//	typeInst=[ExpressionVariable|QualifiedName] ('(' arguments+=RootExpression? (',' arguments+=RootExpression)* ')')?;
		@Override public ParserRule getRule() { return rule; }
		
		//typeInst=[ExpressionVariable|QualifiedName] ('(' arguments+=RootExpression? (',' arguments+=RootExpression)* ')')?
		public Group getGroup() { return cGroup; }
		
		//typeInst=[ExpressionVariable|QualifiedName]
		public Assignment getTypeInstAssignment_0() { return cTypeInstAssignment_0; }
		
		//[ExpressionVariable|QualifiedName]
		public CrossReference getTypeInstExpressionVariableCrossReference_0_0() { return cTypeInstExpressionVariableCrossReference_0_0; }
		
		//QualifiedName
		public RuleCall getTypeInstExpressionVariableQualifiedNameParserRuleCall_0_0_1() { return cTypeInstExpressionVariableQualifiedNameParserRuleCall_0_0_1; }
		
		//('(' arguments+=RootExpression? (',' arguments+=RootExpression)* ')')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//arguments+=RootExpression?
		public Assignment getArgumentsAssignment_1_1() { return cArgumentsAssignment_1_1; }
		
		//RootExpression
		public RuleCall getArgumentsRootExpressionParserRuleCall_1_1_0() { return cArgumentsRootExpressionParserRuleCall_1_1_0; }
		
		//(',' arguments+=RootExpression)*
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//','
		public Keyword getCommaKeyword_1_2_0() { return cCommaKeyword_1_2_0; }
		
		//arguments+=RootExpression
		public Assignment getArgumentsAssignment_1_2_1() { return cArgumentsAssignment_1_2_1; }
		
		//RootExpression
		public RuleCall getArgumentsRootExpressionParserRuleCall_1_2_1_0() { return cArgumentsRootExpressionParserRuleCall_1_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}
	public class ExpressionVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.ExpressionVariable");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFunctionNameParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypedVariableParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cClassDeclParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//ExpressionVariable:
		//	FunctionName | TypedVariable | ClassDecl;
		@Override public ParserRule getRule() { return rule; }
		
		//FunctionName | TypedVariable | ClassDecl
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//FunctionName
		public RuleCall getFunctionNameParserRuleCall_0() { return cFunctionNameParserRuleCall_0; }
		
		//TypedVariable
		public RuleCall getTypedVariableParserRuleCall_1() { return cTypedVariableParserRuleCall_1; }
		
		//ClassDecl
		public RuleCall getClassDeclParserRuleCall_2() { return cClassDeclParserRuleCall_2; }
	}
	public class InbuiltInfixElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.InbuiltInfix");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLeftRightDoubleArrowKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cRightwardsDoubleArrowKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cNotEqualToKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cLogicalAndKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cLogicalOrKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		
		//InbuiltInfix:
		//	'⇔' | '⇒' | '=' | '≠' | '∧' | '∨';
		@Override public ParserRule getRule() { return rule; }
		
		//'⇔' | '⇒' | '=' | '≠' | '∧' | '∨'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'⇔'
		public Keyword getLeftRightDoubleArrowKeyword_0() { return cLeftRightDoubleArrowKeyword_0; }
		
		//'⇒'
		public Keyword getRightwardsDoubleArrowKeyword_1() { return cRightwardsDoubleArrowKeyword_1; }
		
		//'='
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }
		
		//'≠'
		public Keyword getNotEqualToKeyword_3() { return cNotEqualToKeyword_3; }
		
		//'∧'
		public Keyword getLogicalAndKeyword_4() { return cLogicalAndKeyword_4; }
		
		//'∨'
		public Keyword getLogicalOrKeyword_5() { return cLogicalOrKeyword_5; }
	}
	public class InstanceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.Instance");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cInstanceKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cClassNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cClassNameClassDeclCrossReference_1_0 = (CrossReference)cClassNameAssignment_1.eContents().get(0);
		private final RuleCall cClassNameClassDeclQualifiedNameParserRuleCall_1_0_1 = (RuleCall)cClassNameClassDeclCrossReference_1_0.eContents().get(1);
		private final Assignment cContextAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cContextTypeDeclContextParserRuleCall_2_0 = (RuleCall)cContextAssignment_2.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cArgumentsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cArgumentsRootExpressionParserRuleCall_4_0 = (RuleCall)cArgumentsAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cCommaKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cArgumentsAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cArgumentsRootExpressionParserRuleCall_5_1_0 = (RuleCall)cArgumentsAssignment_5_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		///* I feel like I should need these, however, I'm not sure when they would be necessary. */ //InbuiltTypeInstance:
		////	'⊤' | '⊥'
		////;
		////
		////InbuiltTypeInstanceScan:
		////	name=InbuiltTypeInstance
		////;
		///* ------------------------------ Instance ---------------------------------------------*/ Instance:
		//	'Instance' className=[ClassDecl|QualifiedName] context=TypeDeclContext '(' arguments+=RootExpression? (','
		//	arguments+=RootExpression)* ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'Instance' className=[ClassDecl|QualifiedName] context=TypeDeclContext '(' arguments+=RootExpression? (','
		//arguments+=RootExpression)* ')'
		public Group getGroup() { return cGroup; }
		
		//'Instance'
		public Keyword getInstanceKeyword_0() { return cInstanceKeyword_0; }
		
		//className=[ClassDecl|QualifiedName]
		public Assignment getClassNameAssignment_1() { return cClassNameAssignment_1; }
		
		//[ClassDecl|QualifiedName]
		public CrossReference getClassNameClassDeclCrossReference_1_0() { return cClassNameClassDeclCrossReference_1_0; }
		
		//QualifiedName
		public RuleCall getClassNameClassDeclQualifiedNameParserRuleCall_1_0_1() { return cClassNameClassDeclQualifiedNameParserRuleCall_1_0_1; }
		
		//context=TypeDeclContext
		public Assignment getContextAssignment_2() { return cContextAssignment_2; }
		
		//TypeDeclContext
		public RuleCall getContextTypeDeclContextParserRuleCall_2_0() { return cContextTypeDeclContextParserRuleCall_2_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }
		
		//arguments+=RootExpression?
		public Assignment getArgumentsAssignment_4() { return cArgumentsAssignment_4; }
		
		//RootExpression
		public RuleCall getArgumentsRootExpressionParserRuleCall_4_0() { return cArgumentsRootExpressionParserRuleCall_4_0; }
		
		//(',' arguments+=RootExpression)*
		public Group getGroup_5() { return cGroup_5; }
		
		//','
		public Keyword getCommaKeyword_5_0() { return cCommaKeyword_5_0; }
		
		//arguments+=RootExpression
		public Assignment getArgumentsAssignment_5_1() { return cArgumentsAssignment_5_1; }
		
		//RootExpression
		public RuleCall getArgumentsRootExpressionParserRuleCall_5_1_0() { return cArgumentsRootExpressionParserRuleCall_5_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }
	}
	
	
	private final DomainModelElements pDomainModel;
	private final THM_NAMEElements pTHM_NAME;
	private final TopLevelElements pTopLevel;
	private final ClassDeclElements pClassDecl;
	private final InbuiltTypeElements pInbuiltType;
	private final TypeElements pType;
	private final GenNameElements pGenName;
	private final QualifiedNameElements pQualifiedName;
	private final QualifiedNameWithWildcardElements pQualifiedNameWithWildcard;
	private final ImportStatementElements pImportStatement;
	private final ClassElements pClass;
	private final PolymorphicTypeNameElements pPolymorphicTypeName;
	private final PolyContextElements pPolyContext;
	private final PolyContextTypesElements pPolyContextTypes;
	private final PolyTypeConstraintsElements pPolyTypeConstraints;
	private final SuperTypeListElements pSuperTypeList;
	private final ConstructedTypeElements pConstructedType;
	private final TypeConstructorElements pTypeConstructor;
	private final TypeDeclContextElements pTypeDeclContext;
	private final TypeStructureElements pTypeStructure;
	private final WhereElements pWhere;
	private final DatatypeElements pDatatype;
	private final DatatypeConstructorElements pDatatypeConstructor;
	private final ExtendElements pExtend;
	private final TypeBodyElementsElements pTypeBodyElements;
	private final FunctionDeclElements pFunctionDecl;
	private final FunctionNameElements pFunctionName;
	private final MatchStatementElements pMatchStatement;
	private final MatchCaseElements pMatchCase;
	private final TheoremBodyElements pTheoremBody;
	private final TheoremDeclElements pTheoremDecl;
	private final TypedVariableListElements pTypedVariableList;
	private final VariableTypingElements pVariableTyping;
	private final TypedVariableElements pTypedVariable;
	private final LambdaElements pLambda;
	private final QuantifierElements pQuantifier;
	private final RootExpressionElements pRootExpression;
	private final PrefixElements pPrefix;
	private final PrefixBuiltInElements pPrefixBuiltIn;
	private final InfixElements pInfix;
	private final ElementElements pElement;
	private final BracketElements pBracket;
	private final FunctionCallElements pFunctionCall;
	private final ExpressionVariableElements pExpressionVariable;
	private final InbuiltInfixElements pInbuiltInfix;
	private final InstanceElements pInstance;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public BSharpGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pDomainModel = new DomainModelElements();
		this.pTHM_NAME = new THM_NAMEElements();
		this.pTopLevel = new TopLevelElements();
		this.pClassDecl = new ClassDeclElements();
		this.pInbuiltType = new InbuiltTypeElements();
		this.pType = new TypeElements();
		this.pGenName = new GenNameElements();
		this.pQualifiedName = new QualifiedNameElements();
		this.pQualifiedNameWithWildcard = new QualifiedNameWithWildcardElements();
		this.pImportStatement = new ImportStatementElements();
		this.pClass = new ClassElements();
		this.pPolymorphicTypeName = new PolymorphicTypeNameElements();
		this.pPolyContext = new PolyContextElements();
		this.pPolyContextTypes = new PolyContextTypesElements();
		this.pPolyTypeConstraints = new PolyTypeConstraintsElements();
		this.pSuperTypeList = new SuperTypeListElements();
		this.pConstructedType = new ConstructedTypeElements();
		this.pTypeConstructor = new TypeConstructorElements();
		this.pTypeDeclContext = new TypeDeclContextElements();
		this.pTypeStructure = new TypeStructureElements();
		this.pWhere = new WhereElements();
		this.pDatatype = new DatatypeElements();
		this.pDatatypeConstructor = new DatatypeConstructorElements();
		this.pExtend = new ExtendElements();
		this.pTypeBodyElements = new TypeBodyElementsElements();
		this.pFunctionDecl = new FunctionDeclElements();
		this.pFunctionName = new FunctionNameElements();
		this.pMatchStatement = new MatchStatementElements();
		this.pMatchCase = new MatchCaseElements();
		this.pTheoremBody = new TheoremBodyElements();
		this.pTheoremDecl = new TheoremDeclElements();
		this.pTypedVariableList = new TypedVariableListElements();
		this.pVariableTyping = new VariableTypingElements();
		this.pTypedVariable = new TypedVariableElements();
		this.pLambda = new LambdaElements();
		this.pQuantifier = new QuantifierElements();
		this.pRootExpression = new RootExpressionElements();
		this.pPrefix = new PrefixElements();
		this.pPrefixBuiltIn = new PrefixBuiltInElements();
		this.pInfix = new InfixElements();
		this.pElement = new ElementElements();
		this.pBracket = new BracketElements();
		this.pFunctionCall = new FunctionCallElements();
		this.pExpressionVariable = new ExpressionVariableElements();
		this.pInbuiltInfix = new InbuiltInfixElements();
		this.pInstance = new InstanceElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("ac.soton.bsharp.BSharp".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//DomainModel:
	//	elements+=TopLevel*;
	public DomainModelElements getDomainModelAccess() {
		return pDomainModel;
	}
	
	public ParserRule getDomainModelRule() {
		return getDomainModelAccess().getRule();
	}
	
	//// Theorem names can include white space. Work out how to change this to any string without a ':'
	//THM_NAME:
	//	(INT | ID | WS)* ":";
	public THM_NAMEElements getTHM_NAMEAccess() {
		return pTHM_NAME;
	}
	
	public ParserRule getTHM_NAMERule() {
		return getTHM_NAMEAccess().getRule();
	}
	
	//TopLevel:
	//	ImportStatement | ClassDecl | Extend | Instance;
	public TopLevelElements getTopLevelAccess() {
		return pTopLevel;
	}
	
	public ParserRule getTopLevelRule() {
		return getTopLevelAccess().getRule();
	}
	
	//ClassDecl:
	//	Class | Datatype;
	public ClassDeclElements getClassDeclAccess() {
		return pClassDecl;
	}
	
	public ParserRule getClassDeclRule() {
		return getClassDeclAccess().getRule();
	}
	
	///* There are three Types which can be used as type variables, inbuilt types, types create
	// * with ClassDecl (type classes and Datatypes) and Polymorphic types. There are different
	// * occasions where each of these can be used.
	// */ /* Consider whether to add other inbuilt types such as Integers etc. Given the lack of 
	// * recursion in the inbuilt types it may be better to build them instead. We need Pred
	// * as it is going to have special rules to deal with the separation of expressions and 
	// * predicates in Event B. */ InbuiltType:
	//	name='Pred';
	public InbuiltTypeElements getInbuiltTypeAccess() {
		return pInbuiltType;
	}
	
	public ParserRule getInbuiltTypeRule() {
		return getInbuiltTypeAccess().getRule();
	}
	
	//Type:
	//	ClassDecl | InbuiltType;
	public TypeElements getTypeAccess() {
		return pType;
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}
	
	//GenName:
	//	PolymorphicTypeName | Type;
	public GenNameElements getGenNameAccess() {
		return pGenName;
	}
	
	public ParserRule getGenNameRule() {
		return getGenNameAccess().getRule();
	}
	
	///* -------------------------- Import Statements -------------------- */ /* I had hoped to use a python style import, however this seems to be fighting 
	// * the system, and would require a custom implementation of DefaultDeclarativeQualifiedNameProvider.
	// * To increase the development speed I am using the java style imports instead.
	// */ QualifiedName:
	//	ID ('.' ID)*;
	public QualifiedNameElements getQualifiedNameAccess() {
		return pQualifiedName;
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}
	
	//QualifiedNameWithWildcard:
	//	QualifiedName '.*'?;
	public QualifiedNameWithWildcardElements getQualifiedNameWithWildcardAccess() {
		return pQualifiedNameWithWildcard;
	}
	
	public ParserRule getQualifiedNameWithWildcardRule() {
		return getQualifiedNameWithWildcardAccess().getRule();
	}
	
	//ImportStatement:
	//	'Import'
	//	imports+=QualifiedNameWithWildcard+;
	public ImportStatementElements getImportStatementAccess() {
		return pImportStatement;
	}
	
	public ParserRule getImportStatementRule() {
		return getImportStatementAccess().getRule();
	}
	
	///* ------------------------ Class statements --------------------- */ Class BppClass:
	//	'Class' name=ID context=PolyContext? supertypes=SuperTypeList? varList=TypeStructure? where=Where? ';'?
	//	'{' bodyElements+=TypeBodyElements* '}';
	public ClassElements getClassAccess() {
		return pClass;
	}
	
	public ParserRule getClassRule() {
		return getClassAccess().getRule();
	}
	
	///*---------------- Polymorphic Context of -------------------------- */ PolymorphicTypeName:
	//	name=ID;
	public PolymorphicTypeNameElements getPolymorphicTypeNameAccess() {
		return pPolymorphicTypeName;
	}
	
	public ParserRule getPolymorphicTypeNameRule() {
		return getPolymorphicTypeNameAccess().getRule();
	}
	
	//PolyContext:
	//	'<' polyTypes+=PolyContextTypes+ '>';
	public PolyContextElements getPolyContextAccess() {
		return pPolyContext;
	}
	
	public ParserRule getPolyContextRule() {
		return getPolyContextAccess().getRule();
	}
	
	//PolyContextTypes:
	//	name=PolymorphicTypeName constraints+=PolyTypeConstraints*;
	public PolyContextTypesElements getPolyContextTypesAccess() {
		return pPolyContextTypes;
	}
	
	public ParserRule getPolyContextTypesRule() {
		return getPolyContextTypesAccess().getRule();
	}
	
	//PolyTypeConstraints:
	//	':' TypeName+=[ClassDecl|QualifiedName] (',' TypeName+=[ClassDecl|QualifiedName])*;
	public PolyTypeConstraintsElements getPolyTypeConstraintsAccess() {
		return pPolyTypeConstraints;
	}
	
	public ParserRule getPolyTypeConstraintsRule() {
		return getPolyTypeConstraintsAccess().getRule();
	}
	
	///* ------------------- SuperTypes ---------------------------------- */ /* Any constriction on the polymorphic context has to be done by declaring the polymorphic context
	// * on the new type. If necessary the polymorphic context can be used within type constructors. In the simple case 
	// * this will be inferred . Required thought on checking the base types of the super types. At some points these
	// * need to be identical declarations. It is also necessary to allow EventB style type constructors at this
	// * point. e.g., an associative operator is a subtype of a closed Event-B total function.
	// */ SuperTypeList:
	//	':' superType+=ConstructedType (',' superType+=ConstructedType)*;
	public SuperTypeListElements getSuperTypeListAccess() {
		return pSuperTypeList;
	}
	
	public ParserRule getSuperTypeListRule() {
		return getSuperTypeListAccess().getRule();
	}
	
	///* Along with the normal Event-B type operator, and new B++ types the  */ ConstructedType:
	//	type+=TypeConstructor (constructors+=('×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠')
	//	type+=ConstructedType)?;
	public ConstructedTypeElements getConstructedTypeAccess() {
		return pConstructedType;
	}
	
	public ParserRule getConstructedTypeRule() {
		return getConstructedTypeAccess().getRule();
	}
	
	///* Type constructor has validation rules to check that there is no context when there is a polymorphic name, 
	// * and type checking on the polymorphic context. There is also  scope rule to check the usage of polymorphic types.
	// * Probably need to add the predicate type to this.
	// */ TypeConstructor:
	//	TypeName=[GenName|QualifiedName] context+=TypeDeclContext?;
	public TypeConstructorElements getTypeConstructorAccess() {
		return pTypeConstructor;
	}
	
	public ParserRule getTypeConstructorRule() {
		return getTypeConstructorAccess().getRule();
	}
	
	//TypeDeclContext:
	//	'<' TypeName+=ConstructedType (',' TypeName+=ConstructedType)* '>';
	public TypeDeclContextElements getTypeDeclContextAccess() {
		return pTypeDeclContext;
	}
	
	public ParserRule getTypeDeclContextRule() {
		return getTypeDeclContextAccess().getRule();
	}
	
	///* -------------------- Type Structure ---------------------------------- */ TypeStructure:
	//	'(' variables=TypedVariableList ')';
	public TypeStructureElements getTypeStructureAccess() {
		return pTypeStructure;
	}
	
	public ParserRule getTypeStructureRule() {
		return getTypeStructureAccess().getRule();
	}
	
	///* -------------------- Where Statement -------------------------------- */ /* Type checking (which is not implemented yet) is used to type check that Expression returns a 
	// * predicate. Expression has not yet been written, but is far too general to be included in the where
	// * statement.
	// */ Where:
	//	'where' expessions+=Quantifier (';' expressions+=RootExpression)*;
	public WhereElements getWhereAccess() {
		return pWhere;
	}
	
	public ParserRule getWhereRule() {
		return getWhereAccess().getRule();
	}
	
	///* ---------------------- Datatype declarations -------------------------- */ Datatype:
	//	'Datatype' name=ID context=PolyContext? ('|' constructors+=DatatypeConstructor)+ '{' bodyElements+=TypeBodyElements*
	//	'}';
	public DatatypeElements getDatatypeAccess() {
		return pDatatype;
	}
	
	public ParserRule getDatatypeRule() {
		return getDatatypeAccess().getRule();
	}
	
	///* PolyContext is the same as PolyContext used by the class declaration above. */ DatatypeConstructor:
	//	name=ID ('(' decons=TypedVariableList ')')?;
	public DatatypeConstructorElements getDatatypeConstructorAccess() {
		return pDatatypeConstructor;
	}
	
	public ParserRule getDatatypeConstructorRule() {
		return getDatatypeConstructorAccess().getRule();
	}
	
	///* ------------------------ Extension statement ---------------------------- */ Extend:
	//	'Extend' name=[ClassDecl|QualifiedName] '(' extension=ID ')' '{' bodyElements+=TypeBodyElements* '}';
	public ExtendElements getExtendAccess() {
		return pExtend;
	}
	
	public ParserRule getExtendRule() {
		return getExtendAccess().getRule();
	}
	
	///* ------------------------ TypeBodyElements ------------------------------- */ TypeBodyElements:
	//	functions+=FunctionDecl | theorems+=TheoremBody;
	public TypeBodyElementsElements getTypeBodyElementsAccess() {
		return pTypeBodyElements;
	}
	
	public ParserRule getTypeBodyElementsRule() {
		return getTypeBodyElementsAccess().getRule();
	}
	
	///*------------------------- Functions --------------------------------- */ FunctionDecl:
	//	name=FunctionName context=PolyContext? '(' varList=TypedVariableList? ')' ':' returnType=TypeConstructor
	//	infix='INFIX'? precedence=INT? expr=RootExpression;
	public FunctionDeclElements getFunctionDeclAccess() {
		return pFunctionDecl;
	}
	
	public ParserRule getFunctionDeclRule() {
		return getFunctionDeclAccess().getRule();
	}
	
	//FunctionName:
	//	name=ID;
	public FunctionNameElements getFunctionNameAccess() {
		return pFunctionName;
	}
	
	public ParserRule getFunctionNameRule() {
		return getFunctionNameAccess().getRule();
	}
	
	//MatchStatement:
	//	'match' match=[DatatypeConstructor] '{'
	//	inductCase+=MatchCase inductCase+=MatchCase* '}';
	public MatchStatementElements getMatchStatementAccess() {
		return pMatchStatement;
	}
	
	public ParserRule getMatchStatementRule() {
		return getMatchStatementAccess().getRule();
	}
	
	//MatchCase:
	//	'|' deconName=[TypedVariable] ('(' variables+=TypedVariable (',' variables+=TypedVariable)* ')')? ':'
	//	expr=RootExpression;
	public MatchCaseElements getMatchCaseAccess() {
		return pMatchCase;
	}
	
	public ParserRule getMatchCaseRule() {
		return getMatchCaseAccess().getRule();
	}
	
	///* ----------------------------- Theorems -------------------------*/ TheoremBody:
	//	'Theorems' '{' theoremDecl+=TheoremDecl+ '}';
	public TheoremBodyElements getTheoremBodyAccess() {
		return pTheoremBody;
	}
	
	public ParserRule getTheoremBodyRule() {
		return getTheoremBodyAccess().getRule();
	}
	
	///* Type check that the expression is a predicate expression. From a lexing point
	// * of view the semicolon is necessary because the THM_NAME rule is not good enough.
	// */ TheoremDecl:
	//	name=THM_NAME expr=RootExpression ';';
	public TheoremDeclElements getTheoremDeclAccess() {
		return pTheoremDecl;
	}
	
	public ParserRule getTheoremDeclRule() {
		return getTheoremDeclAccess().getRule();
	}
	
	//TypedVariableList:
	//	variablesOfType+=VariableTyping (',' variablesOfType+=VariableTyping)*;
	public TypedVariableListElements getTypedVariableListAccess() {
		return pTypedVariableList;
	}
	
	public ParserRule getTypedVariableListRule() {
		return getTypedVariableListAccess().getRule();
	}
	
	//VariableTyping:
	//	typeVar+=TypedVariable (',' typeVar+=TypedVariable)* ':' type=ConstructedType;
	public VariableTypingElements getVariableTypingAccess() {
		return pVariableTyping;
	}
	
	public ParserRule getVariableTypingRule() {
		return getVariableTypingAccess().getRule();
	}
	
	//TypedVariable:
	//	name=ID;
	public TypedVariableElements getTypedVariableAccess() {
		return pTypedVariable;
	}
	
	public ParserRule getTypedVariableRule() {
		return getTypedVariableAccess().getRule();
	}
	
	///* --------------------------- Expressions -------------------------- */
	///* --------------------------- Lambda and Quantifier ---------------- */
	///* The structure of Lambda and Quantifier are so similar that they're going to share a class */ Lambda QuantLambda:
	//	qType='λ' context=PolyContext? varList=TypedVariableList '|' expr=RootExpression;
	public LambdaElements getLambdaAccess() {
		return pLambda;
	}
	
	public ParserRule getLambdaRule() {
		return getLambdaAccess().getRule();
	}
	
	//Quantifier QuantLambda:
	//	qType=('∀' | '∃') context=PolyContext? varList=TypedVariableList '·' expr=RootExpression;
	public QuantifierElements getQuantifierAccess() {
		return pQuantifier;
	}
	
	public ParserRule getQuantifierRule() {
		return getQuantifierAccess().getRule();
	}
	
	//RootExpression Expression:
	//	Lambda | Quantifier | Infix | MatchStatement;
	public RootExpressionElements getRootExpressionAccess() {
		return pRootExpression;
	}
	
	public ParserRule getRootExpressionRule() {
		return getRootExpressionAccess().getRule();
	}
	
	///* ---------------------- *Fix ------------------------------ */ Prefix:
	//	name=PrefixBuiltIn elem=Element;
	public PrefixElements getPrefixAccess() {
		return pPrefix;
	}
	
	public ParserRule getPrefixRule() {
		return getPrefixAccess().getRule();
	}
	
	//PrefixBuiltIn:
	//	'¬';
	public PrefixBuiltInElements getPrefixBuiltInAccess() {
		return pPrefixBuiltIn;
	}
	
	public ParserRule getPrefixBuiltInRule() {
		return getPrefixBuiltInAccess().getRule();
	}
	
	///* Infix operators cause problems, there are two issues one is avoiding left recursion this 
	// * is covered adequately here: https://www.eclipse.org/Xtext/documentation/307_special_languages.html#expressions 
	// * The second issue is precedence, this is also covered in the link above, however, implementing it in the 
	// * way suggested above will not scale to the creation of ones own infix functions, instead the initial implementation
	// * will require brackets for precedence. After that a system will be implemented where each infix operator will 
	// * be given a precedence value with higher values being higher precedence. It looks like this can be done by
	// * changing the parser using the MyDSLRuntimeModule to build the abstract syntax tree based on the value of the 
	// * operators.
	// * Before the precedence code is written into a parser override, all the expressions are in effect right bracketed,
	// * as you may expect from a language that is read from left to right.
	// * 
	// * TODO: Programmatically check that the function is an infix function.
	// */ Infix Expression:
	//	Element ({Infix.left=current} (funcName=[FunctionName] | opName=InbuiltInfix) right=Element)*;
	public InfixElements getInfixAccess() {
		return pInfix;
	}
	
	public ParserRule getInfixRule() {
		return getInfixAccess().getRule();
	}
	
	///* currently it will not build because the quantifier is causing recursion I think. 
	// * I think that we need a quantifier free expression to solve the problem Similar to the way
	// * precedence is handled here: https://typefox.io/parsing-expressions-with-xtext
	// */ Element Expression:
	//	Bracket | Prefix | FunctionCall;
	public ElementElements getElementAccess() {
		return pElement;
	}
	
	public ParserRule getElementRule() {
		return getElementAccess().getRule();
	}
	
	//Bracket:
	//	'(' child=RootExpression ')';
	public BracketElements getBracketAccess() {
		return pBracket;
	}
	
	public ParserRule getBracketRule() {
		return getBracketAccess().getRule();
	}
	
	///* This produces an interesting issue in parsing the program because it is necessary to distinguish between the following three
	// * scenarios: 
	// * A function call f(arguments)
	// * A infix function with a bracketed argument on the right 10 f (arguments)
	// * A function used without any arguments f add g 
	// * 
	// * To solve this functions can either be Prefix, Infix, or called with bracketed arguments. You cannot call a Infix function with bracketd 
	// * arguments. To do this you would need to write another function to make this call for you. In coq this is achieved when you declare a function
	// * you can add a operator name to the function, which is either infix or prefix, this again gives the two names for the function allowing 
	// * it to be called either as an operator or a functional call.
	// * 
	// * This expressions needs a lot of programmatic checking! Starting with the count of the arguments, followed by type checking the arguments.
	// */ FunctionCall:
	//	typeInst=[ExpressionVariable|QualifiedName] ('(' arguments+=RootExpression? (',' arguments+=RootExpression)* ')')?;
	public FunctionCallElements getFunctionCallAccess() {
		return pFunctionCall;
	}
	
	public ParserRule getFunctionCallRule() {
		return getFunctionCallAccess().getRule();
	}
	
	//ExpressionVariable:
	//	FunctionName | TypedVariable | ClassDecl;
	public ExpressionVariableElements getExpressionVariableAccess() {
		return pExpressionVariable;
	}
	
	public ParserRule getExpressionVariableRule() {
		return getExpressionVariableAccess().getRule();
	}
	
	//InbuiltInfix:
	//	'⇔' | '⇒' | '=' | '≠' | '∧' | '∨';
	public InbuiltInfixElements getInbuiltInfixAccess() {
		return pInbuiltInfix;
	}
	
	public ParserRule getInbuiltInfixRule() {
		return getInbuiltInfixAccess().getRule();
	}
	
	///* I feel like I should need these, however, I'm not sure when they would be necessary. */ //InbuiltTypeInstance:
	////	'⊤' | '⊥'
	////;
	////
	////InbuiltTypeInstanceScan:
	////	name=InbuiltTypeInstance
	////;
	///* ------------------------------ Instance ---------------------------------------------*/ Instance:
	//	'Instance' className=[ClassDecl|QualifiedName] context=TypeDeclContext '(' arguments+=RootExpression? (','
	//	arguments+=RootExpression)* ')';
	public InstanceElements getInstanceAccess() {
		return pInstance;
	}
	
	public ParserRule getInstanceRule() {
		return getInstanceAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
