/*
 * generated by Xtext 2.14.0
 */
package ac.soton.bsharp.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class BSharpGrammarAccess extends AbstractGrammarElementFinder {
	
	public class TopLevelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.TopLevel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPackageKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameQualifiedNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cTopLevelFileAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTopLevelFileTopLevelFileParserRuleCall_2_0 = (RuleCall)cTopLevelFileAssignment_2.eContents().get(0);
		
		//TopLevel:
		//	'package' name=QualifiedName
		//	topLevelFile=TopLevelFile;
		@Override public ParserRule getRule() { return rule; }
		
		//'package' name=QualifiedName topLevelFile=TopLevelFile
		public Group getGroup() { return cGroup; }
		
		//'package'
		public Keyword getPackageKeyword_0() { return cPackageKeyword_0; }
		
		//name=QualifiedName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_1_0() { return cNameQualifiedNameParserRuleCall_1_0; }
		
		//topLevelFile=TopLevelFile
		public Assignment getTopLevelFileAssignment_2() { return cTopLevelFileAssignment_2; }
		
		//TopLevelFile
		public RuleCall getTopLevelFileTopLevelFileParserRuleCall_2_0() { return cTopLevelFileTopLevelFileParserRuleCall_2_0; }
	}
	public class THM_NAMEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.THM_NAME");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_0_2 = (RuleCall)cAlternatives_0.eContents().get(2);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//// Theorem names can include white space. Work out how to change this to any string without a ':'
		//THM_NAME:
		//	(INT | ID | WS)* ":";
		@Override public ParserRule getRule() { return rule; }
		
		//(INT | ID | WS)* ":"
		public Group getGroup() { return cGroup; }
		
		//(INT | ID | WS)*
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0_0() { return cINTTerminalRuleCall_0_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0_1() { return cIDTerminalRuleCall_0_1; }
		
		//WS
		public RuleCall getWSTerminalRuleCall_0_2() { return cWSTerminalRuleCall_0_2; }
		
		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
	}
	public class TopLevelFileElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.TopLevelFile");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTopLevelFileAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNoImportElementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNoImportElementsBodyElementsParserRuleCall_1_0 = (RuleCall)cNoImportElementsAssignment_1.eContents().get(0);
		private final Assignment cTopLevelImportsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTopLevelImportsTopLevelImportParserRuleCall_2_0 = (RuleCall)cTopLevelImportsAssignment_2.eContents().get(0);
		
		///* TopLevelFile has a hidden name tag which is the file name, this gets the filename into the
		// * fully qualified domain names allowing multiple classes per file nicely. TopLevelImport allows
		// * the easy splitting of the file based on import locations. It also makes it easy to scope imports
		// * so only imports above the current location are scoped.
		// */ TopLevelFile:
		//	{TopLevelFile} noImportElements=BodyElements? topLevelImports+=TopLevelImport*;
		@Override public ParserRule getRule() { return rule; }
		
		//{TopLevelFile} noImportElements=BodyElements? topLevelImports+=TopLevelImport*
		public Group getGroup() { return cGroup; }
		
		//{TopLevelFile}
		public Action getTopLevelFileAction_0() { return cTopLevelFileAction_0; }
		
		//noImportElements=BodyElements?
		public Assignment getNoImportElementsAssignment_1() { return cNoImportElementsAssignment_1; }
		
		//BodyElements
		public RuleCall getNoImportElementsBodyElementsParserRuleCall_1_0() { return cNoImportElementsBodyElementsParserRuleCall_1_0; }
		
		//topLevelImports+=TopLevelImport*
		public Assignment getTopLevelImportsAssignment_2() { return cTopLevelImportsAssignment_2; }
		
		//TopLevelImport
		public RuleCall getTopLevelImportsTopLevelImportParserRuleCall_2_0() { return cTopLevelImportsTopLevelImportParserRuleCall_2_0; }
	}
	public class ClassDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.ClassDecl");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cClassParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDatatypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ClassDecl:
		//	Class | Datatype;
		@Override public ParserRule getRule() { return rule; }
		
		//Class | Datatype
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Class
		public RuleCall getClassParserRuleCall_0() { return cClassParserRuleCall_0; }
		
		//Datatype
		public RuleCall getDatatypeParserRuleCall_1() { return cDatatypeParserRuleCall_1; }
	}
	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.Type");
		private final RuleCall cClassDeclParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		///* There are three Types which can be used as type variables, inbuilt types, types create
		// * with ClassDecl (type classes and Datatypes) and Polymorphic types. There are different
		// * occasions where each of these can be used.
		// */ Type:
		//	ClassDecl;
		@Override public ParserRule getRule() { return rule; }
		
		//ClassDecl
		public RuleCall getClassDeclParserRuleCall() { return cClassDeclParserRuleCall; }
	}
	public class GenNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.GenName");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPolyTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cInstNameParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//GenName:
		//	PolyType | Type | InstName;
		@Override public ParserRule getRule() { return rule; }
		
		//PolyType | Type | InstName
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PolyType
		public RuleCall getPolyTypeParserRuleCall_0() { return cPolyTypeParserRuleCall_0; }
		
		//Type
		public RuleCall getTypeParserRuleCall_1() { return cTypeParserRuleCall_1; }
		
		//InstName
		public RuleCall getInstNameParserRuleCall_2() { return cInstNameParserRuleCall_2; }
	}
	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		///* -------------------------- Import Statements -------------------- */ /* I had hoped to use a python style import, however this seems to be fighting 
		// * the system, and would require a custom implementation of DefaultDeclarativeQualifiedNameProvider.
		// * To increase the development speed I am using the java style imports instead.
		// */ QualifiedName:
		//	ID ('.' ID)*;
		@Override public ParserRule getRule() { return rule; }
		
		//ID ('.' ID)*
		public Group getGroup() { return cGroup; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//('.' ID)*
		public Group getGroup_1() { return cGroup_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}
	public class QualifiedNameWithWildcardElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.QualifiedNameWithWildcard");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cQualifiedNameParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopAsteriskKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//QualifiedNameWithWildcard:
		//	QualifiedName '.*'?;
		@Override public ParserRule getRule() { return rule; }
		
		//QualifiedName '.*'?
		public Group getGroup() { return cGroup; }
		
		//QualifiedName
		public RuleCall getQualifiedNameParserRuleCall_0() { return cQualifiedNameParserRuleCall_0; }
		
		//'.*'?
		public Keyword getFullStopAsteriskKeyword_1() { return cFullStopAsteriskKeyword_1; }
	}
	public class TopLevelImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.TopLevelImport");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cGlobalImportsAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final RuleCall cGlobalImportsGlobalImportParserRuleCall_0_0_0 = (RuleCall)cGlobalImportsAssignment_0_0.eContents().get(0);
		private final Assignment cLocalImportsAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final RuleCall cLocalImportsLocalImportParserRuleCall_0_1_0 = (RuleCall)cLocalImportsAssignment_0_1.eContents().get(0);
		private final Assignment cBodyElementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBodyElementsBodyElementsParserRuleCall_1_0 = (RuleCall)cBodyElementsAssignment_1.eContents().get(0);
		
		//TopLevelImport:
		//	(globalImports+=GlobalImport | localImports+=LocalImport)+ bodyElements=BodyElements;
		@Override public ParserRule getRule() { return rule; }
		
		//(globalImports+=GlobalImport | localImports+=LocalImport)+ bodyElements=BodyElements
		public Group getGroup() { return cGroup; }
		
		//(globalImports+=GlobalImport | localImports+=LocalImport)+
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//globalImports+=GlobalImport
		public Assignment getGlobalImportsAssignment_0_0() { return cGlobalImportsAssignment_0_0; }
		
		//GlobalImport
		public RuleCall getGlobalImportsGlobalImportParserRuleCall_0_0_0() { return cGlobalImportsGlobalImportParserRuleCall_0_0_0; }
		
		//localImports+=LocalImport
		public Assignment getLocalImportsAssignment_0_1() { return cLocalImportsAssignment_0_1; }
		
		//LocalImport
		public RuleCall getLocalImportsLocalImportParserRuleCall_0_1_0() { return cLocalImportsLocalImportParserRuleCall_0_1_0; }
		
		//bodyElements=BodyElements
		public Assignment getBodyElementsAssignment_1() { return cBodyElementsAssignment_1; }
		
		//BodyElements
		public RuleCall getBodyElementsBodyElementsParserRuleCall_1_0() { return cBodyElementsBodyElementsParserRuleCall_1_0; }
	}
	public class BodyElementsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.BodyElements");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cClassesAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cClassesClassDeclParserRuleCall_0_0 = (RuleCall)cClassesAssignment_0.eContents().get(0);
		private final Assignment cExtendsAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cExtendsExtendParserRuleCall_1_0 = (RuleCall)cExtendsAssignment_1.eContents().get(0);
		
		//BodyElements:
		//	(classes+=ClassDecl | extends+=Extend)+;
		@Override public ParserRule getRule() { return rule; }
		
		//(classes+=ClassDecl | extends+=Extend)+
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//classes+=ClassDecl
		public Assignment getClassesAssignment_0() { return cClassesAssignment_0; }
		
		//ClassDecl
		public RuleCall getClassesClassDeclParserRuleCall_0_0() { return cClassesClassDeclParserRuleCall_0_0; }
		
		//extends+=Extend
		public Assignment getExtendsAssignment_1() { return cExtendsAssignment_1; }
		
		//Extend
		public RuleCall getExtendsExtendParserRuleCall_1_0() { return cExtendsExtendParserRuleCall_1_0; }
	}
	public class GlobalImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.GlobalImport");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFromKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cProjectAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cProjectQualifiedNameParserRuleCall_1_0 = (RuleCall)cProjectAssignment_1.eContents().get(0);
		private final Keyword cImportKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cFileImportsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cFileImportsFileImportParserRuleCall_3_0 = (RuleCall)cFileImportsAssignment_3.eContents().get(0);
		
		//GlobalImport:
		//	'From' project=QualifiedName 'Import' fileImports+=FileImport+;
		@Override public ParserRule getRule() { return rule; }
		
		//'From' project=QualifiedName 'Import' fileImports+=FileImport+
		public Group getGroup() { return cGroup; }
		
		//'From'
		public Keyword getFromKeyword_0() { return cFromKeyword_0; }
		
		//project=QualifiedName
		public Assignment getProjectAssignment_1() { return cProjectAssignment_1; }
		
		//QualifiedName
		public RuleCall getProjectQualifiedNameParserRuleCall_1_0() { return cProjectQualifiedNameParserRuleCall_1_0; }
		
		//'Import'
		public Keyword getImportKeyword_2() { return cImportKeyword_2; }
		
		//fileImports+=FileImport+
		public Assignment getFileImportsAssignment_3() { return cFileImportsAssignment_3; }
		
		//FileImport
		public RuleCall getFileImportsFileImportParserRuleCall_3_0() { return cFileImportsFileImportParserRuleCall_3_0; }
	}
	public class FileImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.FileImport");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFileReferenceAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cFileReferenceTopLevelFileCrossReference_0_0 = (CrossReference)cFileReferenceAssignment_0.eContents().get(0);
		private final RuleCall cFileReferenceTopLevelFileIDTerminalRuleCall_0_0_1 = (RuleCall)cFileReferenceTopLevelFileCrossReference_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cAsteriskKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Assignment cTypeAssignment_1_1_1 = (Assignment)cAlternatives_1_1.eContents().get(1);
		private final RuleCall cTypeIDTerminalRuleCall_1_1_1_0 = (RuleCall)cTypeAssignment_1_1_1.eContents().get(0);
		
		///* Imports other files from the current project. The optional type ID allows the importing
		// * of a specific type from the file. */ FileImport:
		//	fileReference=[TopLevelFile] ('.' ('*' | type=ID))?;
		@Override public ParserRule getRule() { return rule; }
		
		//fileReference=[TopLevelFile] ('.' ('*' | type=ID))?
		public Group getGroup() { return cGroup; }
		
		//fileReference=[TopLevelFile]
		public Assignment getFileReferenceAssignment_0() { return cFileReferenceAssignment_0; }
		
		//[TopLevelFile]
		public CrossReference getFileReferenceTopLevelFileCrossReference_0_0() { return cFileReferenceTopLevelFileCrossReference_0_0; }
		
		//ID
		public RuleCall getFileReferenceTopLevelFileIDTerminalRuleCall_0_0_1() { return cFileReferenceTopLevelFileIDTerminalRuleCall_0_0_1; }
		
		//('.' ('*' | type=ID))?
		public Group getGroup_1() { return cGroup_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }
		
		//'*' | type=ID
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }
		
		//'*'
		public Keyword getAsteriskKeyword_1_1_0() { return cAsteriskKeyword_1_1_0; }
		
		//type=ID
		public Assignment getTypeAssignment_1_1_1() { return cTypeAssignment_1_1_1; }
		
		//ID
		public RuleCall getTypeIDTerminalRuleCall_1_1_1_0() { return cTypeIDTerminalRuleCall_1_1_1_0; }
	}
	public class LocalImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.LocalImport");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFileImportsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFileImportsFileImportParserRuleCall_1_0 = (RuleCall)cFileImportsAssignment_1.eContents().get(0);
		
		//LocalImport:
		//	'Import' fileImports+=FileImport+;
		@Override public ParserRule getRule() { return rule; }
		
		//'Import' fileImports+=FileImport+
		public Group getGroup() { return cGroup; }
		
		//'Import'
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }
		
		//fileImports+=FileImport+
		public Assignment getFileImportsAssignment_1() { return cFileImportsAssignment_1; }
		
		//FileImport
		public RuleCall getFileImportsFileImportParserRuleCall_1_0() { return cFileImportsFileImportParserRuleCall_1_0; }
	}
	public class ClassElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.Class");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cClassKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cContextAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cContextPolyContextParserRuleCall_2_0 = (RuleCall)cContextAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cLeftSquareBracketKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cInstNameAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cInstNameInstNameParserRuleCall_3_1_0 = (RuleCall)cInstNameAssignment_3_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		private final Assignment cSupertypesAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cSupertypesSuperTypeListParserRuleCall_4_0 = (RuleCall)cSupertypesAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cLeftParenthesisKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cVarListAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cVarListTypedVariableListParserRuleCall_5_1_0 = (RuleCall)cVarListAssignment_5_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5_2 = (Keyword)cGroup_5.eContents().get(2);
		private final Assignment cWhereAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cWhereWhereParserRuleCall_6_0 = (RuleCall)cWhereAssignment_6.eContents().get(0);
		private final Keyword cSemicolonKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cBlockAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cBlockBSharpBlockParserRuleCall_8_0 = (RuleCall)cBlockAssignment_8.eContents().get(0);
		
		///* ------------------------ Class statements --------------------- */ Class BSClass:
		//	'Class' name=ID context=PolyContext? ('[' instName=InstName ']') supertypes=SuperTypeList? ('('
		//	varList=TypedVariableList ')')? where=Where? ';'?
		//	block=BSharpBlock;
		@Override public ParserRule getRule() { return rule; }
		
		//'Class' name=ID context=PolyContext? ('[' instName=InstName ']') supertypes=SuperTypeList? ('('
		//varList=TypedVariableList ')')? where=Where? ';'? block=BSharpBlock
		public Group getGroup() { return cGroup; }
		
		//'Class'
		public Keyword getClassKeyword_0() { return cClassKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//context=PolyContext?
		public Assignment getContextAssignment_2() { return cContextAssignment_2; }
		
		//PolyContext
		public RuleCall getContextPolyContextParserRuleCall_2_0() { return cContextPolyContextParserRuleCall_2_0; }
		
		//'[' instName=InstName ']'
		public Group getGroup_3() { return cGroup_3; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_3_0() { return cLeftSquareBracketKeyword_3_0; }
		
		//instName=InstName
		public Assignment getInstNameAssignment_3_1() { return cInstNameAssignment_3_1; }
		
		//InstName
		public RuleCall getInstNameInstNameParserRuleCall_3_1_0() { return cInstNameInstNameParserRuleCall_3_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_3_2() { return cRightSquareBracketKeyword_3_2; }
		
		//supertypes=SuperTypeList?
		public Assignment getSupertypesAssignment_4() { return cSupertypesAssignment_4; }
		
		//SuperTypeList
		public RuleCall getSupertypesSuperTypeListParserRuleCall_4_0() { return cSupertypesSuperTypeListParserRuleCall_4_0; }
		
		//('(' varList=TypedVariableList ')')?
		public Group getGroup_5() { return cGroup_5; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_5_0() { return cLeftParenthesisKeyword_5_0; }
		
		//varList=TypedVariableList
		public Assignment getVarListAssignment_5_1() { return cVarListAssignment_5_1; }
		
		//TypedVariableList
		public RuleCall getVarListTypedVariableListParserRuleCall_5_1_0() { return cVarListTypedVariableListParserRuleCall_5_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5_2() { return cRightParenthesisKeyword_5_2; }
		
		//where=Where?
		public Assignment getWhereAssignment_6() { return cWhereAssignment_6; }
		
		//Where
		public RuleCall getWhereWhereParserRuleCall_6_0() { return cWhereWhereParserRuleCall_6_0; }
		
		//';'?
		public Keyword getSemicolonKeyword_7() { return cSemicolonKeyword_7; }
		
		//block=BSharpBlock
		public Assignment getBlockAssignment_8() { return cBlockAssignment_8; }
		
		//BSharpBlock
		public RuleCall getBlockBSharpBlockParserRuleCall_8_0() { return cBlockBSharpBlockParserRuleCall_8_0; }
	}
	public class InstNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.InstName");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//InstName:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class PolyContextElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.PolyContext");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPolyTypesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPolyTypesPolyTypeParserRuleCall_1_0 = (RuleCall)cPolyTypesAssignment_1.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		///*---------------- Polymorphic Context of -------------------------- */ PolyContext:
		//	'<' polyTypes+=PolyType+ '>';
		@Override public ParserRule getRule() { return rule; }
		
		//'<' polyTypes+=PolyType+ '>'
		public Group getGroup() { return cGroup; }
		
		//'<'
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }
		
		//polyTypes+=PolyType+
		public Assignment getPolyTypesAssignment_1() { return cPolyTypesAssignment_1; }
		
		//PolyType
		public RuleCall getPolyTypesPolyTypeParserRuleCall_1_0() { return cPolyTypesPolyTypeParserRuleCall_1_0; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_2() { return cGreaterThanSignKeyword_2; }
	}
	public class PolyTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.PolyType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cColonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cSuperTypesAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final CrossReference cSuperTypesClassDeclCrossReference_1_1_0 = (CrossReference)cSuperTypesAssignment_1_1.eContents().get(0);
		private final RuleCall cSuperTypesClassDeclQualifiedNameParserRuleCall_1_1_0_1 = (RuleCall)cSuperTypesClassDeclCrossReference_1_1_0.eContents().get(1);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cCommaKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cSuperTypesAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final CrossReference cSuperTypesClassDeclCrossReference_1_2_1_0 = (CrossReference)cSuperTypesAssignment_1_2_1.eContents().get(0);
		private final RuleCall cSuperTypesClassDeclQualifiedNameParserRuleCall_1_2_1_0_1 = (RuleCall)cSuperTypesClassDeclCrossReference_1_2_1_0.eContents().get(1);
		
		//PolyType:
		//	name=ID (':' superTypes+=[ClassDecl|QualifiedName] (',' superTypes+=[ClassDecl|QualifiedName])*)?;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID (':' superTypes+=[ClassDecl|QualifiedName] (',' superTypes+=[ClassDecl|QualifiedName])*)?
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//(':' superTypes+=[ClassDecl|QualifiedName] (',' superTypes+=[ClassDecl|QualifiedName])*)?
		public Group getGroup_1() { return cGroup_1; }
		
		//':'
		public Keyword getColonKeyword_1_0() { return cColonKeyword_1_0; }
		
		//superTypes+=[ClassDecl|QualifiedName]
		public Assignment getSuperTypesAssignment_1_1() { return cSuperTypesAssignment_1_1; }
		
		//[ClassDecl|QualifiedName]
		public CrossReference getSuperTypesClassDeclCrossReference_1_1_0() { return cSuperTypesClassDeclCrossReference_1_1_0; }
		
		//QualifiedName
		public RuleCall getSuperTypesClassDeclQualifiedNameParserRuleCall_1_1_0_1() { return cSuperTypesClassDeclQualifiedNameParserRuleCall_1_1_0_1; }
		
		//(',' superTypes+=[ClassDecl|QualifiedName])*
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//','
		public Keyword getCommaKeyword_1_2_0() { return cCommaKeyword_1_2_0; }
		
		//superTypes+=[ClassDecl|QualifiedName]
		public Assignment getSuperTypesAssignment_1_2_1() { return cSuperTypesAssignment_1_2_1; }
		
		//[ClassDecl|QualifiedName]
		public CrossReference getSuperTypesClassDeclCrossReference_1_2_1_0() { return cSuperTypesClassDeclCrossReference_1_2_1_0; }
		
		//QualifiedName
		public RuleCall getSuperTypesClassDeclQualifiedNameParserRuleCall_1_2_1_0_1() { return cSuperTypesClassDeclQualifiedNameParserRuleCall_1_2_1_0_1; }
	}
	public class SuperTypeListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.SuperTypeList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSuperTypesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSuperTypesConstructedTypeParserRuleCall_1_0 = (RuleCall)cSuperTypesAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cSuperTypesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cSuperTypesConstructedTypeParserRuleCall_2_1_0 = (RuleCall)cSuperTypesAssignment_2_1.eContents().get(0);
		
		///* ------------------- SuperTypes ---------------------------------- */ /* Any constriction on the polymorphic context has to be done by declaring the polymorphic context
		// * on the new type. If necessary the polymorphic context can be used within type constructors. In the simple case 
		// * this will be inferred . Required thought on checking the base types of the super types. At some points these
		// * need to be identical declarations. It is also necessary to allow EventB style type constructors at this
		// * point. e.g., an associative operator is a subtype of a closed Event-B total function.
		// */ SuperTypeList:
		//	':' superTypes+=ConstructedType (',' superTypes+=ConstructedType)*;
		@Override public ParserRule getRule() { return rule; }
		
		//':' superTypes+=ConstructedType (',' superTypes+=ConstructedType)*
		public Group getGroup() { return cGroup; }
		
		//':'
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }
		
		//superTypes+=ConstructedType
		public Assignment getSuperTypesAssignment_1() { return cSuperTypesAssignment_1; }
		
		//ConstructedType
		public RuleCall getSuperTypesConstructedTypeParserRuleCall_1_0() { return cSuperTypesConstructedTypeParserRuleCall_1_0; }
		
		//(',' superTypes+=ConstructedType)*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//superTypes+=ConstructedType
		public Assignment getSuperTypesAssignment_2_1() { return cSuperTypesAssignment_2_1; }
		
		//ConstructedType
		public RuleCall getSuperTypesConstructedTypeParserRuleCall_2_1_0() { return cSuperTypesConstructedTypeParserRuleCall_2_1_0; }
	}
	public class TypeBuilderElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.TypeBuilder");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cConstructedTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypeConstructorParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cTypePowerSetParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cTypeConstrBracketParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//TypeBuilder:
		//	ConstructedType | TypeConstructor | TypePowerSet | TypeConstrBracket;
		@Override public ParserRule getRule() { return rule; }
		
		//ConstructedType | TypeConstructor | TypePowerSet | TypeConstrBracket
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ConstructedType
		public RuleCall getConstructedTypeParserRuleCall_0() { return cConstructedTypeParserRuleCall_0; }
		
		//TypeConstructor
		public RuleCall getTypeConstructorParserRuleCall_1() { return cTypeConstructorParserRuleCall_1; }
		
		//TypePowerSet
		public RuleCall getTypePowerSetParserRuleCall_2() { return cTypePowerSetParserRuleCall_2; }
		
		//TypeConstrBracket
		public RuleCall getTypeConstrBracketParserRuleCall_3() { return cTypeConstrBracketParserRuleCall_3; }
	}
	public class BuiltinTypeInfixOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.BuiltinTypeInfixOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cMultiplicationSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cRightwardsArrowKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cPrivateUseAreaE102Keyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cPrivateUseAreaE100Keyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cLeftRightArrowKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cRightwardsTwoHeadedArrowWithTailKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cRightwardsArrowWithVerticalStrokeKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cRightwardsArrowWithTailKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cRightwardsTwoHeadedArrowKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		
		//BuiltinTypeInfixOp:
		//	'×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠';
		@Override public ParserRule getRule() { return rule; }
		
		//'×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'×'
		public Keyword getMultiplicationSignKeyword_0() { return cMultiplicationSignKeyword_0; }
		
		//'→'
		public Keyword getRightwardsArrowKeyword_1() { return cRightwardsArrowKeyword_1; }
		
		//''
		public Keyword getPrivateUseAreaE102Keyword_2() { return cPrivateUseAreaE102Keyword_2; }
		
		//''
		public Keyword getPrivateUseAreaE100Keyword_3() { return cPrivateUseAreaE100Keyword_3; }
		
		//'↔'
		public Keyword getLeftRightArrowKeyword_4() { return cLeftRightArrowKeyword_4; }
		
		//'⤖'
		public Keyword getRightwardsTwoHeadedArrowWithTailKeyword_5() { return cRightwardsTwoHeadedArrowWithTailKeyword_5; }
		
		//'⇸'
		public Keyword getRightwardsArrowWithVerticalStrokeKeyword_6() { return cRightwardsArrowWithVerticalStrokeKeyword_6; }
		
		//'↣'
		public Keyword getRightwardsArrowWithTailKeyword_7() { return cRightwardsArrowWithTailKeyword_7; }
		
		//'⤀'
		public Keyword getRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_8() { return cRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_8; }
		
		//'↠'
		public Keyword getRightwardsTwoHeadedArrowKeyword_9() { return cRightwardsTwoHeadedArrowKeyword_9; }
	}
	public class ConstructedTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.ConstructedType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBuilderElemParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cConstructedTypeLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cConstructorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cConstructorBuiltinTypeInfixOpParserRuleCall_1_1_0 = (RuleCall)cConstructorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightBuilderElemParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		///* Along with the normal Event-B type operator, and new B++ types the  */ ConstructedType TypeBuilder:
		//	BuilderElem ({ConstructedType.left=current} constructor=BuiltinTypeInfixOp right=BuilderElem)*;
		@Override public ParserRule getRule() { return rule; }
		
		//BuilderElem ({ConstructedType.left=current} constructor=BuiltinTypeInfixOp right=BuilderElem)*
		public Group getGroup() { return cGroup; }
		
		//BuilderElem
		public RuleCall getBuilderElemParserRuleCall_0() { return cBuilderElemParserRuleCall_0; }
		
		//({ConstructedType.left=current} constructor=BuiltinTypeInfixOp right=BuilderElem)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{ConstructedType.left=current}
		public Action getConstructedTypeLeftAction_1_0() { return cConstructedTypeLeftAction_1_0; }
		
		//constructor=BuiltinTypeInfixOp
		public Assignment getConstructorAssignment_1_1() { return cConstructorAssignment_1_1; }
		
		//BuiltinTypeInfixOp
		public RuleCall getConstructorBuiltinTypeInfixOpParserRuleCall_1_1_0() { return cConstructorBuiltinTypeInfixOpParserRuleCall_1_1_0; }
		
		//right=BuilderElem
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//BuilderElem
		public RuleCall getRightBuilderElemParserRuleCall_1_2_0() { return cRightBuilderElemParserRuleCall_1_2_0; }
	}
	public class BuilderElemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.BuilderElem");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTypeConstructorParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypeConstrBracketParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cTypePowerSetParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//BuilderElem TypeBuilder:
		//	TypeConstructor | TypeConstrBracket | TypePowerSet;
		@Override public ParserRule getRule() { return rule; }
		
		//TypeConstructor | TypeConstrBracket | TypePowerSet
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//TypeConstructor
		public RuleCall getTypeConstructorParserRuleCall_0() { return cTypeConstructorParserRuleCall_0; }
		
		//TypeConstrBracket
		public RuleCall getTypeConstrBracketParserRuleCall_1() { return cTypeConstrBracketParserRuleCall_1; }
		
		//TypePowerSet
		public RuleCall getTypePowerSetParserRuleCall_2() { return cTypePowerSetParserRuleCall_2; }
	}
	public class TypeConstructorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.TypeConstructor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeNameGenNameCrossReference_0_0 = (CrossReference)cTypeNameAssignment_0.eContents().get(0);
		private final RuleCall cTypeNameGenNameQualifiedNameParserRuleCall_0_0_1 = (RuleCall)cTypeNameGenNameCrossReference_0_0.eContents().get(1);
		private final Assignment cContextAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cContextTypeDeclContextParserRuleCall_1_0 = (RuleCall)cContextAssignment_1.eContents().get(0);
		
		///* Type constructor has validation rules to check that there is no context when there is a polymorphic name, 
		// * and type checking on the polymorphic context. There is also  scope rule to check the usage of polymorphic types.
		// * Probably need to add the predicate type to this.
		// */ TypeConstructor:
		//	typeName=[GenName|QualifiedName] context=TypeDeclContext?;
		@Override public ParserRule getRule() { return rule; }
		
		//typeName=[GenName|QualifiedName] context=TypeDeclContext?
		public Group getGroup() { return cGroup; }
		
		//typeName=[GenName|QualifiedName]
		public Assignment getTypeNameAssignment_0() { return cTypeNameAssignment_0; }
		
		//[GenName|QualifiedName]
		public CrossReference getTypeNameGenNameCrossReference_0_0() { return cTypeNameGenNameCrossReference_0_0; }
		
		//QualifiedName
		public RuleCall getTypeNameGenNameQualifiedNameParserRuleCall_0_0_1() { return cTypeNameGenNameQualifiedNameParserRuleCall_0_0_1; }
		
		//context=TypeDeclContext?
		public Assignment getContextAssignment_1() { return cContextAssignment_1; }
		
		//TypeDeclContext
		public RuleCall getContextTypeDeclContextParserRuleCall_1_0() { return cContextTypeDeclContextParserRuleCall_1_0; }
	}
	public class TypePowerSetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.TypePowerSet");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDoubleStruckCapitalPKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cChildAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cChildConstructedTypeParserRuleCall_2_0 = (RuleCall)cChildAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//TypePowerSet:
		//	'ℙ' '(' child=ConstructedType ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'ℙ' '(' child=ConstructedType ')'
		public Group getGroup() { return cGroup; }
		
		//'ℙ'
		public Keyword getDoubleStruckCapitalPKeyword_0() { return cDoubleStruckCapitalPKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//child=ConstructedType
		public Assignment getChildAssignment_2() { return cChildAssignment_2; }
		
		//ConstructedType
		public RuleCall getChildConstructedTypeParserRuleCall_2_0() { return cChildConstructedTypeParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class TypeConstrBracketElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.TypeConstrBracket");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cChildAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cChildConstructedTypeParserRuleCall_1_0 = (RuleCall)cChildAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//TypeConstrBracket:
		//	'(' child=ConstructedType ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' child=ConstructedType ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//child=ConstructedType
		public Assignment getChildAssignment_1() { return cChildAssignment_1; }
		
		//ConstructedType
		public RuleCall getChildConstructedTypeParserRuleCall_1_0() { return cChildConstructedTypeParserRuleCall_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class TypeDeclContextElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.TypeDeclContext");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeNameConstructedTypeParserRuleCall_1_0 = (RuleCall)cTypeNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cTypeNameAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cTypeNameConstructedTypeParserRuleCall_2_1_0 = (RuleCall)cTypeNameAssignment_2_1.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		///* This is used in two different situations, and may well compile the same for both so don't delete
		// * unless the compilation of the two places is different (even then it is more pleasant to not have
		// * two identical syntax declarations in this file).
		// */ TypeDeclContext:
		//	'<' typeName+=ConstructedType (',' typeName+=ConstructedType)* '>';
		@Override public ParserRule getRule() { return rule; }
		
		//'<' typeName+=ConstructedType (',' typeName+=ConstructedType)* '>'
		public Group getGroup() { return cGroup; }
		
		//'<'
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }
		
		//typeName+=ConstructedType
		public Assignment getTypeNameAssignment_1() { return cTypeNameAssignment_1; }
		
		//ConstructedType
		public RuleCall getTypeNameConstructedTypeParserRuleCall_1_0() { return cTypeNameConstructedTypeParserRuleCall_1_0; }
		
		//(',' typeName+=ConstructedType)*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//typeName+=ConstructedType
		public Assignment getTypeNameAssignment_2_1() { return cTypeNameAssignment_2_1; }
		
		//ConstructedType
		public RuleCall getTypeNameConstructedTypeParserRuleCall_2_1_0() { return cTypeNameConstructedTypeParserRuleCall_2_1_0; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_3() { return cGreaterThanSignKeyword_3; }
	}
	public class WhereElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.Where");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhereKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionsRootExpressionParserRuleCall_1_0 = (RuleCall)cExpressionsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cSemicolonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cExpressionsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cExpressionsRootExpressionParserRuleCall_2_1_0 = (RuleCall)cExpressionsAssignment_2_1.eContents().get(0);
		
		///* -------------------- Where Statement -------------------------------- */ /* Type checking (which is not implemented yet) is used to type check that Expression returns a 
		// * predicate. Expression has not yet been written, but is far too general to be included in the where
		// * statement.
		// */ Where:
		//	'where' expressions+=RootExpression (';' expressions+=RootExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//'where' expressions+=RootExpression (';' expressions+=RootExpression)*
		public Group getGroup() { return cGroup; }
		
		//'where'
		public Keyword getWhereKeyword_0() { return cWhereKeyword_0; }
		
		//expressions+=RootExpression
		public Assignment getExpressionsAssignment_1() { return cExpressionsAssignment_1; }
		
		//RootExpression
		public RuleCall getExpressionsRootExpressionParserRuleCall_1_0() { return cExpressionsRootExpressionParserRuleCall_1_0; }
		
		//(';' expressions+=RootExpression)*
		public Group getGroup_2() { return cGroup_2; }
		
		//';'
		public Keyword getSemicolonKeyword_2_0() { return cSemicolonKeyword_2_0; }
		
		//expressions+=RootExpression
		public Assignment getExpressionsAssignment_2_1() { return cExpressionsAssignment_2_1; }
		
		//RootExpression
		public RuleCall getExpressionsRootExpressionParserRuleCall_2_1_0() { return cExpressionsRootExpressionParserRuleCall_2_1_0; }
	}
	public class DatatypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.Datatype");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDatatypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cContextAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cContextPolyContextParserRuleCall_2_0 = (RuleCall)cContextAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cVerticalLineKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cConstructorsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cConstructorsDatatypeConstructorParserRuleCall_3_1_0 = (RuleCall)cConstructorsAssignment_3_1.eContents().get(0);
		private final Assignment cBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBlockBSharpBlockParserRuleCall_4_0 = (RuleCall)cBlockAssignment_4.eContents().get(0);
		
		///* ---------------------- Datatype declarations -------------------------- */ Datatype:
		//	'Datatype' name=ID context=PolyContext? ('|' constructors+=DatatypeConstructor)+ block=BSharpBlock;
		@Override public ParserRule getRule() { return rule; }
		
		//'Datatype' name=ID context=PolyContext? ('|' constructors+=DatatypeConstructor)+ block=BSharpBlock
		public Group getGroup() { return cGroup; }
		
		//'Datatype'
		public Keyword getDatatypeKeyword_0() { return cDatatypeKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//context=PolyContext?
		public Assignment getContextAssignment_2() { return cContextAssignment_2; }
		
		//PolyContext
		public RuleCall getContextPolyContextParserRuleCall_2_0() { return cContextPolyContextParserRuleCall_2_0; }
		
		//('|' constructors+=DatatypeConstructor)+
		public Group getGroup_3() { return cGroup_3; }
		
		//'|'
		public Keyword getVerticalLineKeyword_3_0() { return cVerticalLineKeyword_3_0; }
		
		//constructors+=DatatypeConstructor
		public Assignment getConstructorsAssignment_3_1() { return cConstructorsAssignment_3_1; }
		
		//DatatypeConstructor
		public RuleCall getConstructorsDatatypeConstructorParserRuleCall_3_1_0() { return cConstructorsDatatypeConstructorParserRuleCall_3_1_0; }
		
		//block=BSharpBlock
		public Assignment getBlockAssignment_4() { return cBlockAssignment_4; }
		
		//BSharpBlock
		public RuleCall getBlockBSharpBlockParserRuleCall_4_0() { return cBlockBSharpBlockParserRuleCall_4_0; }
	}
	public class DatatypeConstructorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.DatatypeConstructor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cDeconsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cDeconsTypedVariableListParserRuleCall_1_1_0 = (RuleCall)cDeconsAssignment_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		///* PolyContext is the same as PolyContext used by the class declaration above. */ DatatypeConstructor:
		//	name=ID ('(' decons=TypedVariableList ')')?;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID ('(' decons=TypedVariableList ')')?
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//('(' decons=TypedVariableList ')')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//decons=TypedVariableList
		public Assignment getDeconsAssignment_1_1() { return cDeconsAssignment_1_1; }
		
		//TypedVariableList
		public RuleCall getDeconsTypedVariableListParserRuleCall_1_1_0() { return cDeconsTypedVariableListParserRuleCall_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}
	public class ExtendElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.Extend");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExtendKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExtendedClassAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cExtendedClassClassDeclCrossReference_1_0 = (CrossReference)cExtendedClassAssignment_1.eContents().get(0);
		private final RuleCall cExtendedClassClassDeclQualifiedNameParserRuleCall_1_0_1 = (RuleCall)cExtendedClassClassDeclCrossReference_1_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cBlockAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cBlockBSharpBlockParserRuleCall_5_0 = (RuleCall)cBlockAssignment_5.eContents().get(0);
		
		///* ------------------------ Extension statement ---------------------------- */ Extend:
		//	'Extend' extendedClass=[ClassDecl|QualifiedName] '(' name=ID ')' block=BSharpBlock;
		@Override public ParserRule getRule() { return rule; }
		
		//'Extend' extendedClass=[ClassDecl|QualifiedName] '(' name=ID ')' block=BSharpBlock
		public Group getGroup() { return cGroup; }
		
		//'Extend'
		public Keyword getExtendKeyword_0() { return cExtendKeyword_0; }
		
		//extendedClass=[ClassDecl|QualifiedName]
		public Assignment getExtendedClassAssignment_1() { return cExtendedClassAssignment_1; }
		
		//[ClassDecl|QualifiedName]
		public CrossReference getExtendedClassClassDeclCrossReference_1_0() { return cExtendedClassClassDeclCrossReference_1_0; }
		
		//QualifiedName
		public RuleCall getExtendedClassClassDeclQualifiedNameParserRuleCall_1_0_1() { return cExtendedClassClassDeclQualifiedNameParserRuleCall_1_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//name=ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
		
		//block=BSharpBlock
		public Assignment getBlockAssignment_5() { return cBlockAssignment_5; }
		
		//BSharpBlock
		public RuleCall getBlockBSharpBlockParserRuleCall_5_0() { return cBlockBSharpBlockParserRuleCall_5_0; }
	}
	public class BSharpBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.BSharpBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBSharpBlockAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cFunctionsAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cFunctionsFunctionDeclParserRuleCall_2_0_0 = (RuleCall)cFunctionsAssignment_2_0.eContents().get(0);
		private final Assignment cTheoremsAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cTheoremsTheoremBodyParserRuleCall_2_1_0 = (RuleCall)cTheoremsAssignment_2_1.eContents().get(0);
		private final Assignment cTheoremsAssignment_2_2 = (Assignment)cAlternatives_2.eContents().get(2);
		private final RuleCall cTheoremsInstanceParserRuleCall_2_2_0 = (RuleCall)cTheoremsAssignment_2_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		///* ------------------------ TypeBodyElements ------------------------------- */ /* The ordering of theorem bodies and instances is imported so they need to go into
		// * a joint list to maintain the order.
		// */ BSharpBlock:
		//	{BSharpBlock}
		//	'{' (functions+=FunctionDecl | theorems+=TheoremBody | theorems+=Instance)* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//{BSharpBlock} '{' (functions+=FunctionDecl | theorems+=TheoremBody | theorems+=Instance)* '}'
		public Group getGroup() { return cGroup; }
		
		//{BSharpBlock}
		public Action getBSharpBlockAction_0() { return cBSharpBlockAction_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//(functions+=FunctionDecl | theorems+=TheoremBody | theorems+=Instance)*
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//functions+=FunctionDecl
		public Assignment getFunctionsAssignment_2_0() { return cFunctionsAssignment_2_0; }
		
		//FunctionDecl
		public RuleCall getFunctionsFunctionDeclParserRuleCall_2_0_0() { return cFunctionsFunctionDeclParserRuleCall_2_0_0; }
		
		//theorems+=TheoremBody
		public Assignment getTheoremsAssignment_2_1() { return cTheoremsAssignment_2_1; }
		
		//TheoremBody
		public RuleCall getTheoremsTheoremBodyParserRuleCall_2_1_0() { return cTheoremsTheoremBodyParserRuleCall_2_1_0; }
		
		//theorems+=Instance
		public Assignment getTheoremsAssignment_2_2() { return cTheoremsAssignment_2_2; }
		
		//Instance
		public RuleCall getTheoremsInstanceParserRuleCall_2_2_0() { return cTheoremsInstanceParserRuleCall_2_2_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class FunctionDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.FunctionDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cContextAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cContextPolyContextParserRuleCall_1_0 = (RuleCall)cContextAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cVarListAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVarListTypedVariableListParserRuleCall_3_0 = (RuleCall)cVarListAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cColonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cReturnTypeAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cReturnTypeTypeConstructorParserRuleCall_6_0 = (RuleCall)cReturnTypeAssignment_6.eContents().get(0);
		private final Assignment cInfixAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final Keyword cInfixINFIXKeyword_7_0 = (Keyword)cInfixAssignment_7.eContents().get(0);
		private final Assignment cPrecedenceAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cPrecedenceINTTerminalRuleCall_8_0 = (RuleCall)cPrecedenceAssignment_8.eContents().get(0);
		private final Assignment cExprAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cExprRootExpressionParserRuleCall_9_0 = (RuleCall)cExprAssignment_9.eContents().get(0);
		
		///*------------------------- Functions --------------------------------- */ FunctionDecl:
		//	name=ID context=PolyContext? '(' varList=TypedVariableList? ')' ':' returnType=TypeConstructor infix='INFIX'?
		//	precedence=INT? expr=RootExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID context=PolyContext? '(' varList=TypedVariableList? ')' ':' returnType=TypeConstructor infix='INFIX'?
		//precedence=INT? expr=RootExpression
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//context=PolyContext?
		public Assignment getContextAssignment_1() { return cContextAssignment_1; }
		
		//PolyContext
		public RuleCall getContextPolyContextParserRuleCall_1_0() { return cContextPolyContextParserRuleCall_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//varList=TypedVariableList?
		public Assignment getVarListAssignment_3() { return cVarListAssignment_3; }
		
		//TypedVariableList
		public RuleCall getVarListTypedVariableListParserRuleCall_3_0() { return cVarListTypedVariableListParserRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
		
		//':'
		public Keyword getColonKeyword_5() { return cColonKeyword_5; }
		
		//returnType=TypeConstructor
		public Assignment getReturnTypeAssignment_6() { return cReturnTypeAssignment_6; }
		
		//TypeConstructor
		public RuleCall getReturnTypeTypeConstructorParserRuleCall_6_0() { return cReturnTypeTypeConstructorParserRuleCall_6_0; }
		
		//infix='INFIX'?
		public Assignment getInfixAssignment_7() { return cInfixAssignment_7; }
		
		//'INFIX'
		public Keyword getInfixINFIXKeyword_7_0() { return cInfixINFIXKeyword_7_0; }
		
		//precedence=INT?
		public Assignment getPrecedenceAssignment_8() { return cPrecedenceAssignment_8; }
		
		//INT
		public RuleCall getPrecedenceINTTerminalRuleCall_8_0() { return cPrecedenceINTTerminalRuleCall_8_0; }
		
		//expr=RootExpression
		public Assignment getExprAssignment_9() { return cExprAssignment_9; }
		
		//RootExpression
		public RuleCall getExprRootExpressionParserRuleCall_9_0() { return cExprRootExpressionParserRuleCall_9_0; }
	}
	public class MatchStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.MatchStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMatchKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cMatchAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cMatchRootExpressionParserRuleCall_1_0 = (RuleCall)cMatchAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cInductCaseAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cInductCaseMatchCaseParserRuleCall_3_0 = (RuleCall)cInductCaseAssignment_3.eContents().get(0);
		private final Assignment cInductCaseAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cInductCaseMatchCaseParserRuleCall_4_0 = (RuleCall)cInductCaseAssignment_4.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//MatchStatement:
		//	'match' match=RootExpression '{'
		//	inductCase+=MatchCase inductCase+=MatchCase* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'match' match=RootExpression '{' inductCase+=MatchCase inductCase+=MatchCase* '}'
		public Group getGroup() { return cGroup; }
		
		//'match'
		public Keyword getMatchKeyword_0() { return cMatchKeyword_0; }
		
		//match=RootExpression
		public Assignment getMatchAssignment_1() { return cMatchAssignment_1; }
		
		//RootExpression
		public RuleCall getMatchRootExpressionParserRuleCall_1_0() { return cMatchRootExpressionParserRuleCall_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//inductCase+=MatchCase
		public Assignment getInductCaseAssignment_3() { return cInductCaseAssignment_3; }
		
		//MatchCase
		public RuleCall getInductCaseMatchCaseParserRuleCall_3_0() { return cInductCaseMatchCaseParserRuleCall_3_0; }
		
		//inductCase+=MatchCase*
		public Assignment getInductCaseAssignment_4() { return cInductCaseAssignment_4; }
		
		//MatchCase
		public RuleCall getInductCaseMatchCaseParserRuleCall_4_0() { return cInductCaseMatchCaseParserRuleCall_4_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}
	public class MatchCaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.MatchCase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVerticalLineKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDeconNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cDeconNameDatatypeConstructorCrossReference_1_0 = (CrossReference)cDeconNameAssignment_1.eContents().get(0);
		private final RuleCall cDeconNameDatatypeConstructorIDTerminalRuleCall_1_0_1 = (RuleCall)cDeconNameDatatypeConstructorCrossReference_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cVariablesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cVariablesTypedVariableParserRuleCall_2_1_0 = (RuleCall)cVariablesAssignment_2_1.eContents().get(0);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final Keyword cCommaKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cVariablesAssignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final RuleCall cVariablesTypedVariableParserRuleCall_2_2_1_0 = (RuleCall)cVariablesAssignment_2_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cExprAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cExprRootExpressionParserRuleCall_4_0 = (RuleCall)cExprAssignment_4.eContents().get(0);
		
		//MatchCase:
		//	'|' deconName=[DatatypeConstructor] ('(' variables+=TypedVariable (',' variables+=TypedVariable)* ')')? ':'
		//	expr=RootExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//'|' deconName=[DatatypeConstructor] ('(' variables+=TypedVariable (',' variables+=TypedVariable)* ')')? ':'
		//expr=RootExpression
		public Group getGroup() { return cGroup; }
		
		//'|'
		public Keyword getVerticalLineKeyword_0() { return cVerticalLineKeyword_0; }
		
		//deconName=[DatatypeConstructor]
		public Assignment getDeconNameAssignment_1() { return cDeconNameAssignment_1; }
		
		//[DatatypeConstructor]
		public CrossReference getDeconNameDatatypeConstructorCrossReference_1_0() { return cDeconNameDatatypeConstructorCrossReference_1_0; }
		
		//ID
		public RuleCall getDeconNameDatatypeConstructorIDTerminalRuleCall_1_0_1() { return cDeconNameDatatypeConstructorIDTerminalRuleCall_1_0_1; }
		
		//('(' variables+=TypedVariable (',' variables+=TypedVariable)* ')')?
		public Group getGroup_2() { return cGroup_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }
		
		//variables+=TypedVariable
		public Assignment getVariablesAssignment_2_1() { return cVariablesAssignment_2_1; }
		
		//TypedVariable
		public RuleCall getVariablesTypedVariableParserRuleCall_2_1_0() { return cVariablesTypedVariableParserRuleCall_2_1_0; }
		
		//(',' variables+=TypedVariable)*
		public Group getGroup_2_2() { return cGroup_2_2; }
		
		//','
		public Keyword getCommaKeyword_2_2_0() { return cCommaKeyword_2_2_0; }
		
		//variables+=TypedVariable
		public Assignment getVariablesAssignment_2_2_1() { return cVariablesAssignment_2_2_1; }
		
		//TypedVariable
		public RuleCall getVariablesTypedVariableParserRuleCall_2_2_1_0() { return cVariablesTypedVariableParserRuleCall_2_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_3() { return cRightParenthesisKeyword_2_3; }
		
		//':'
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }
		
		//expr=RootExpression
		public Assignment getExprAssignment_4() { return cExprAssignment_4; }
		
		//RootExpression
		public RuleCall getExprRootExpressionParserRuleCall_4_0() { return cExprRootExpressionParserRuleCall_4_0; }
	}
	public class TheoremBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.TheoremBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTheoremsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTheoremDeclAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTheoremDeclTheoremDeclParserRuleCall_2_0 = (RuleCall)cTheoremDeclAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		///* ----------------------------- Theorems -------------------------*/ TheoremBody:
		//	'Theorems' '{' theoremDecl+=TheoremDecl+ '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'Theorems' '{' theoremDecl+=TheoremDecl+ '}'
		public Group getGroup() { return cGroup; }
		
		//'Theorems'
		public Keyword getTheoremsKeyword_0() { return cTheoremsKeyword_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//theoremDecl+=TheoremDecl+
		public Assignment getTheoremDeclAssignment_2() { return cTheoremDeclAssignment_2; }
		
		//TheoremDecl
		public RuleCall getTheoremDeclTheoremDeclParserRuleCall_2_0() { return cTheoremDeclTheoremDeclParserRuleCall_2_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class TheoremDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.TheoremDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameTHM_NAMEParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprRootExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		///* Type check that the expression is a predicate expression. From a lexing point
		// * of view the semicolon is necessary because the THM_NAME rule is not good enough.
		// */ TheoremDecl:
		//	name=THM_NAME expr=RootExpression ';';
		@Override public ParserRule getRule() { return rule; }
		
		//name=THM_NAME expr=RootExpression ';'
		public Group getGroup() { return cGroup; }
		
		//name=THM_NAME
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//THM_NAME
		public RuleCall getNameTHM_NAMEParserRuleCall_0_0() { return cNameTHM_NAMEParserRuleCall_0_0; }
		
		//expr=RootExpression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }
		
		//RootExpression
		public RuleCall getExprRootExpressionParserRuleCall_1_0() { return cExprRootExpressionParserRuleCall_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}
	public class TypedVariableListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.TypedVariableList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVariablesOfTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVariablesOfTypeVariableTypingParserRuleCall_0_0 = (RuleCall)cVariablesOfTypeAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cVariablesOfTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cVariablesOfTypeVariableTypingParserRuleCall_1_1_0 = (RuleCall)cVariablesOfTypeAssignment_1_1.eContents().get(0);
		
		//TypedVariableList:
		//	variablesOfType+=VariableTyping (',' variablesOfType+=VariableTyping)*;
		@Override public ParserRule getRule() { return rule; }
		
		//variablesOfType+=VariableTyping (',' variablesOfType+=VariableTyping)*
		public Group getGroup() { return cGroup; }
		
		//variablesOfType+=VariableTyping
		public Assignment getVariablesOfTypeAssignment_0() { return cVariablesOfTypeAssignment_0; }
		
		//VariableTyping
		public RuleCall getVariablesOfTypeVariableTypingParserRuleCall_0_0() { return cVariablesOfTypeVariableTypingParserRuleCall_0_0; }
		
		//(',' variablesOfType+=VariableTyping)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//variablesOfType+=VariableTyping
		public Assignment getVariablesOfTypeAssignment_1_1() { return cVariablesOfTypeAssignment_1_1; }
		
		//VariableTyping
		public RuleCall getVariablesOfTypeVariableTypingParserRuleCall_1_1_0() { return cVariablesOfTypeVariableTypingParserRuleCall_1_1_0; }
	}
	public class VariableTypingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.VariableTyping");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeVarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeVarTypedVariableParserRuleCall_0_0 = (RuleCall)cTypeVarAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTypeVarAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypeVarTypedVariableParserRuleCall_1_1_0 = (RuleCall)cTypeVarAssignment_1_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeConstructedTypeParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		
		//VariableTyping:
		//	typeVar+=TypedVariable (',' typeVar+=TypedVariable)* ':' type=ConstructedType;
		@Override public ParserRule getRule() { return rule; }
		
		//typeVar+=TypedVariable (',' typeVar+=TypedVariable)* ':' type=ConstructedType
		public Group getGroup() { return cGroup; }
		
		//typeVar+=TypedVariable
		public Assignment getTypeVarAssignment_0() { return cTypeVarAssignment_0; }
		
		//TypedVariable
		public RuleCall getTypeVarTypedVariableParserRuleCall_0_0() { return cTypeVarTypedVariableParserRuleCall_0_0; }
		
		//(',' typeVar+=TypedVariable)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//typeVar+=TypedVariable
		public Assignment getTypeVarAssignment_1_1() { return cTypeVarAssignment_1_1; }
		
		//TypedVariable
		public RuleCall getTypeVarTypedVariableParserRuleCall_1_1_0() { return cTypeVarTypedVariableParserRuleCall_1_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//type=ConstructedType
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }
		
		//ConstructedType
		public RuleCall getTypeConstructedTypeParserRuleCall_3_0() { return cTypeConstructedTypeParserRuleCall_3_0; }
	}
	public class TypedVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.TypedVariable");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		///* I think this is here for reference purposes, e.g., otherwise it's quite difficult
		// * to cross reference individual type names. */ TypedVariable:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class LambdaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.Lambda");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cQTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cQTypeGreekSmallLetterLamdaKeyword_0_0 = (Keyword)cQTypeAssignment_0.eContents().get(0);
		private final Assignment cContextAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cContextPolyContextParserRuleCall_1_0 = (RuleCall)cContextAssignment_1.eContents().get(0);
		private final Assignment cVarListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVarListTypedVariableListParserRuleCall_2_0 = (RuleCall)cVarListAssignment_2.eContents().get(0);
		private final Keyword cVerticalLineKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cExprAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cExprRootExpressionParserRuleCall_4_0 = (RuleCall)cExprAssignment_4.eContents().get(0);
		
		///* --------------------------- Expressions -------------------------- */
		///* --------------------------- Lambda and Quantifier ---------------- */
		///* The structure of Lambda and Quantifier are so similar that they're going to share a class */ Lambda QuantLambda:
		//	qType='λ' context=PolyContext? varList=TypedVariableList '|' expr=RootExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//qType='λ' context=PolyContext? varList=TypedVariableList '|' expr=RootExpression
		public Group getGroup() { return cGroup; }
		
		//qType='λ'
		public Assignment getQTypeAssignment_0() { return cQTypeAssignment_0; }
		
		//'λ'
		public Keyword getQTypeGreekSmallLetterLamdaKeyword_0_0() { return cQTypeGreekSmallLetterLamdaKeyword_0_0; }
		
		//context=PolyContext?
		public Assignment getContextAssignment_1() { return cContextAssignment_1; }
		
		//PolyContext
		public RuleCall getContextPolyContextParserRuleCall_1_0() { return cContextPolyContextParserRuleCall_1_0; }
		
		//varList=TypedVariableList
		public Assignment getVarListAssignment_2() { return cVarListAssignment_2; }
		
		//TypedVariableList
		public RuleCall getVarListTypedVariableListParserRuleCall_2_0() { return cVarListTypedVariableListParserRuleCall_2_0; }
		
		//'|'
		public Keyword getVerticalLineKeyword_3() { return cVerticalLineKeyword_3; }
		
		//expr=RootExpression
		public Assignment getExprAssignment_4() { return cExprAssignment_4; }
		
		//RootExpression
		public RuleCall getExprRootExpressionParserRuleCall_4_0() { return cExprRootExpressionParserRuleCall_4_0; }
	}
	public class QuantifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.Quantifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cQTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cQTypeAlternatives_0_0 = (Alternatives)cQTypeAssignment_0.eContents().get(0);
		private final Keyword cQTypeForAllKeyword_0_0_0 = (Keyword)cQTypeAlternatives_0_0.eContents().get(0);
		private final Keyword cQTypeThereExistsKeyword_0_0_1 = (Keyword)cQTypeAlternatives_0_0.eContents().get(1);
		private final Assignment cContextAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cContextPolyContextParserRuleCall_1_0 = (RuleCall)cContextAssignment_1.eContents().get(0);
		private final Assignment cVarListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVarListTypedVariableListParserRuleCall_2_0 = (RuleCall)cVarListAssignment_2.eContents().get(0);
		private final Keyword cMiddleDotKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cExprAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cExprRootExpressionParserRuleCall_4_0 = (RuleCall)cExprAssignment_4.eContents().get(0);
		
		//Quantifier QuantLambda:
		//	qType=('∀' | '∃') context=PolyContext? varList=TypedVariableList '·' expr=RootExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//qType=('∀' | '∃') context=PolyContext? varList=TypedVariableList '·' expr=RootExpression
		public Group getGroup() { return cGroup; }
		
		//qType=('∀' | '∃')
		public Assignment getQTypeAssignment_0() { return cQTypeAssignment_0; }
		
		//('∀' | '∃')
		public Alternatives getQTypeAlternatives_0_0() { return cQTypeAlternatives_0_0; }
		
		//'∀'
		public Keyword getQTypeForAllKeyword_0_0_0() { return cQTypeForAllKeyword_0_0_0; }
		
		//'∃'
		public Keyword getQTypeThereExistsKeyword_0_0_1() { return cQTypeThereExistsKeyword_0_0_1; }
		
		//context=PolyContext?
		public Assignment getContextAssignment_1() { return cContextAssignment_1; }
		
		//PolyContext
		public RuleCall getContextPolyContextParserRuleCall_1_0() { return cContextPolyContextParserRuleCall_1_0; }
		
		//varList=TypedVariableList
		public Assignment getVarListAssignment_2() { return cVarListAssignment_2; }
		
		//TypedVariableList
		public RuleCall getVarListTypedVariableListParserRuleCall_2_0() { return cVarListTypedVariableListParserRuleCall_2_0; }
		
		//'·'
		public Keyword getMiddleDotKeyword_3() { return cMiddleDotKeyword_3; }
		
		//expr=RootExpression
		public Assignment getExprAssignment_4() { return cExprAssignment_4; }
		
		//RootExpression
		public RuleCall getExprRootExpressionParserRuleCall_4_0() { return cExprRootExpressionParserRuleCall_4_0; }
	}
	public class RootExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.RootExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLambdaParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cQuantifierParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cInfixParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cMatchStatementParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//RootExpression Expression:
		//	Lambda | Quantifier | Infix | MatchStatement;
		@Override public ParserRule getRule() { return rule; }
		
		//Lambda | Quantifier | Infix | MatchStatement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Lambda
		public RuleCall getLambdaParserRuleCall_0() { return cLambdaParserRuleCall_0; }
		
		//Quantifier
		public RuleCall getQuantifierParserRuleCall_1() { return cQuantifierParserRuleCall_1; }
		
		//Infix
		public RuleCall getInfixParserRuleCall_2() { return cInfixParserRuleCall_2; }
		
		//MatchStatement
		public RuleCall getMatchStatementParserRuleCall_3() { return cMatchStatementParserRuleCall_3; }
	}
	public class PrefixElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.Prefix");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNamePrefixBuiltInParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cElemAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cElemElementParserRuleCall_1_0 = (RuleCall)cElemAssignment_1.eContents().get(0);
		
		///* ---------------------- *Fix ------------------------------ */ Prefix:
		//	name=PrefixBuiltIn elem=Element;
		@Override public ParserRule getRule() { return rule; }
		
		//name=PrefixBuiltIn elem=Element
		public Group getGroup() { return cGroup; }
		
		//name=PrefixBuiltIn
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//PrefixBuiltIn
		public RuleCall getNamePrefixBuiltInParserRuleCall_0_0() { return cNamePrefixBuiltInParserRuleCall_0_0; }
		
		//elem=Element
		public Assignment getElemAssignment_1() { return cElemAssignment_1; }
		
		//Element
		public RuleCall getElemElementParserRuleCall_1_0() { return cElemElementParserRuleCall_1_0; }
	}
	public class PrefixBuiltInElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.PrefixBuiltIn");
		private final Keyword cNotSignKeyword = (Keyword)rule.eContents().get(1);
		
		//PrefixBuiltIn:
		//	'¬';
		@Override public ParserRule getRule() { return rule; }
		
		//'¬'
		public Keyword getNotSignKeyword() { return cNotSignKeyword; }
	}
	public class InfixElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.Infix");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cElementParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cInfixLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Assignment cFuncNameAssignment_1_1_0 = (Assignment)cAlternatives_1_1.eContents().get(0);
		private final CrossReference cFuncNameFunctionDeclCrossReference_1_1_0_0 = (CrossReference)cFuncNameAssignment_1_1_0.eContents().get(0);
		private final RuleCall cFuncNameFunctionDeclIDTerminalRuleCall_1_1_0_0_1 = (RuleCall)cFuncNameFunctionDeclCrossReference_1_1_0_0.eContents().get(1);
		private final Assignment cOpNameAssignment_1_1_1 = (Assignment)cAlternatives_1_1.eContents().get(1);
		private final RuleCall cOpNameInbuiltInfixParserRuleCall_1_1_1_0 = (RuleCall)cOpNameAssignment_1_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightElementParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		///* Infix operators cause problems, there are two issues one is avoiding left recursion this 
		// * is covered adequately here: https://www.eclipse.org/Xtext/documentation/307_special_languages.html#expressions 
		// * The second issue is precedence, this is also covered in the link above, however, implementing it in the 
		// * way suggested above will not scale to the creation of ones own infix functions, instead the initial implementation
		// * will require brackets for precedence. After that a system will be implemented where each infix operator will 
		// * be given a precedence value with higher values being higher precedence. It looks like this can be done by
		// * changing the parser using the MyDSLRuntimeModule to build the abstract syntax tree based on the value of the 
		// * operators.
		// * Before the precedence code is written into a parser override, all the expressions are in effect right bracketed,
		// * as you may expect from a language that is read from left to right.
		// * 
		// * TODO: Programmatically check that the function is an infix function.
		// */ Infix Expression:
		//	Element ({Infix.left=current} (funcName=[FunctionDecl] | opName=InbuiltInfix) right=Element)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Element ({Infix.left=current} (funcName=[FunctionDecl] | opName=InbuiltInfix) right=Element)*
		public Group getGroup() { return cGroup; }
		
		//Element
		public RuleCall getElementParserRuleCall_0() { return cElementParserRuleCall_0; }
		
		//({Infix.left=current} (funcName=[FunctionDecl] | opName=InbuiltInfix) right=Element)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Infix.left=current}
		public Action getInfixLeftAction_1_0() { return cInfixLeftAction_1_0; }
		
		//funcName=[FunctionDecl] | opName=InbuiltInfix
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }
		
		//funcName=[FunctionDecl]
		public Assignment getFuncNameAssignment_1_1_0() { return cFuncNameAssignment_1_1_0; }
		
		//[FunctionDecl]
		public CrossReference getFuncNameFunctionDeclCrossReference_1_1_0_0() { return cFuncNameFunctionDeclCrossReference_1_1_0_0; }
		
		//ID
		public RuleCall getFuncNameFunctionDeclIDTerminalRuleCall_1_1_0_0_1() { return cFuncNameFunctionDeclIDTerminalRuleCall_1_1_0_0_1; }
		
		//opName=InbuiltInfix
		public Assignment getOpNameAssignment_1_1_1() { return cOpNameAssignment_1_1_1; }
		
		//InbuiltInfix
		public RuleCall getOpNameInbuiltInfixParserRuleCall_1_1_1_0() { return cOpNameInbuiltInfixParserRuleCall_1_1_1_0; }
		
		//right=Element
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Element
		public RuleCall getRightElementParserRuleCall_1_2_0() { return cRightElementParserRuleCall_1_2_0; }
	}
	public class ElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.Element");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBracketParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPrefixParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cFunctionCallParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		///* currently it will not build because the quantifier is causing recursion I think. 
		// * I think that we need a quantifier free expression to solve the problem Similar to the way
		// * precedence is handled here: https://typefox.io/parsing-expressions-with-xtext
		// */ Element Expression:
		//	Bracket | Prefix | FunctionCall;
		@Override public ParserRule getRule() { return rule; }
		
		//Bracket | Prefix | FunctionCall
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Bracket
		public RuleCall getBracketParserRuleCall_0() { return cBracketParserRuleCall_0; }
		
		//Prefix
		public RuleCall getPrefixParserRuleCall_1() { return cPrefixParserRuleCall_1; }
		
		//FunctionCall
		public RuleCall getFunctionCallParserRuleCall_2() { return cFunctionCallParserRuleCall_2; }
	}
	public class BracketElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.Bracket");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cChildAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cChildRootExpressionParserRuleCall_1_0 = (RuleCall)cChildAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Bracket:
		//	'(' child=RootExpression ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' child=RootExpression ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//child=RootExpression
		public Assignment getChildAssignment_1() { return cChildAssignment_1; }
		
		//RootExpression
		public RuleCall getChildRootExpressionParserRuleCall_1_0() { return cChildRootExpressionParserRuleCall_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class FunctionCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.FunctionCall");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cWrappedAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cWrappedWrappedInfixParserRuleCall_0_0 = (RuleCall)cWrappedAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Assignment cTypeInstAssignment_1_0_0 = (Assignment)cAlternatives_1_0.eContents().get(0);
		private final CrossReference cTypeInstExpressionVariableCrossReference_1_0_0_0 = (CrossReference)cTypeInstAssignment_1_0_0.eContents().get(0);
		private final RuleCall cTypeInstExpressionVariableIDTerminalRuleCall_1_0_0_0_1 = (RuleCall)cTypeInstExpressionVariableCrossReference_1_0_0_0.eContents().get(1);
		private final Assignment cClassVarDeclAssignment_1_0_1 = (Assignment)cAlternatives_1_0.eContents().get(1);
		private final RuleCall cClassVarDeclClassVarDeclParserRuleCall_1_0_1_0 = (RuleCall)cClassVarDeclAssignment_1_0_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Assignment cContextAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final RuleCall cContextTypeDeclContextParserRuleCall_1_1_0_0 = (RuleCall)cContextAssignment_1_1_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Assignment cArgumentsAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cArgumentsRootExpressionParserRuleCall_1_1_2_0 = (RuleCall)cArgumentsAssignment_1_1_2.eContents().get(0);
		private final Group cGroup_1_1_3 = (Group)cGroup_1_1.eContents().get(3);
		private final Keyword cCommaKeyword_1_1_3_0 = (Keyword)cGroup_1_1_3.eContents().get(0);
		private final Assignment cArgumentsAssignment_1_1_3_1 = (Assignment)cGroup_1_1_3.eContents().get(1);
		private final RuleCall cArgumentsRootExpressionParserRuleCall_1_1_3_1_0 = (RuleCall)cArgumentsAssignment_1_1_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_1_4 = (Keyword)cGroup_1_1.eContents().get(4);
		
		///* This produces an interesting issue in parsing the program because it is necessary to distinguish between the following three
		// * scenarios: 
		// * A function call f(arguments)
		// * A infix function with a bracketed argument on the right 10 f (arguments)
		// * A function used without any arguments f add g 
		// * 
		// * To solve this functions can either be Prefix, Infix, or called with bracketed arguments. You cannot call a Infix function with bracketd 
		// * arguments. To do this you would need to write another function to make this call for you. In coq this is achieved when you declare a function
		// * you can add a operator name to the function, which is either infix or prefix, this again gives the two names for the function allowing 
		// * it to be called either as an operator or a functional call.
		// * 
		// * This expressions needs a lot of programmatic checking! Starting with the count of the arguments, followed by type checking the arguments.
		// */ FunctionCall:
		//	wrapped=WrappedInfix | (typeInst=[ExpressionVariable] | classVarDecl=ClassVarDecl) (context=TypeDeclContext? '('
		//	arguments+=RootExpression? (',' arguments+=RootExpression)* ')')?;
		@Override public ParserRule getRule() { return rule; }
		
		//wrapped=WrappedInfix | (typeInst=[ExpressionVariable] | classVarDecl=ClassVarDecl) (context=TypeDeclContext? '('
		//arguments+=RootExpression? (',' arguments+=RootExpression)* ')')?
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//wrapped=WrappedInfix
		public Assignment getWrappedAssignment_0() { return cWrappedAssignment_0; }
		
		//WrappedInfix
		public RuleCall getWrappedWrappedInfixParserRuleCall_0_0() { return cWrappedWrappedInfixParserRuleCall_0_0; }
		
		//(typeInst=[ExpressionVariable] | classVarDecl=ClassVarDecl) (context=TypeDeclContext? '(' arguments+=RootExpression?
		//(',' arguments+=RootExpression)* ')')?
		public Group getGroup_1() { return cGroup_1; }
		
		//typeInst=[ExpressionVariable] | classVarDecl=ClassVarDecl
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//typeInst=[ExpressionVariable]
		public Assignment getTypeInstAssignment_1_0_0() { return cTypeInstAssignment_1_0_0; }
		
		//[ExpressionVariable]
		public CrossReference getTypeInstExpressionVariableCrossReference_1_0_0_0() { return cTypeInstExpressionVariableCrossReference_1_0_0_0; }
		
		//ID
		public RuleCall getTypeInstExpressionVariableIDTerminalRuleCall_1_0_0_0_1() { return cTypeInstExpressionVariableIDTerminalRuleCall_1_0_0_0_1; }
		
		//classVarDecl=ClassVarDecl
		public Assignment getClassVarDeclAssignment_1_0_1() { return cClassVarDeclAssignment_1_0_1; }
		
		//ClassVarDecl
		public RuleCall getClassVarDeclClassVarDeclParserRuleCall_1_0_1_0() { return cClassVarDeclClassVarDeclParserRuleCall_1_0_1_0; }
		
		//(context=TypeDeclContext? '(' arguments+=RootExpression? (',' arguments+=RootExpression)* ')')?
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//context=TypeDeclContext?
		public Assignment getContextAssignment_1_1_0() { return cContextAssignment_1_1_0; }
		
		//TypeDeclContext
		public RuleCall getContextTypeDeclContextParserRuleCall_1_1_0_0() { return cContextTypeDeclContextParserRuleCall_1_1_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_1_1() { return cLeftParenthesisKeyword_1_1_1; }
		
		//arguments+=RootExpression?
		public Assignment getArgumentsAssignment_1_1_2() { return cArgumentsAssignment_1_1_2; }
		
		//RootExpression
		public RuleCall getArgumentsRootExpressionParserRuleCall_1_1_2_0() { return cArgumentsRootExpressionParserRuleCall_1_1_2_0; }
		
		//(',' arguments+=RootExpression)*
		public Group getGroup_1_1_3() { return cGroup_1_1_3; }
		
		//','
		public Keyword getCommaKeyword_1_1_3_0() { return cCommaKeyword_1_1_3_0; }
		
		//arguments+=RootExpression
		public Assignment getArgumentsAssignment_1_1_3_1() { return cArgumentsAssignment_1_1_3_1; }
		
		//RootExpression
		public RuleCall getArgumentsRootExpressionParserRuleCall_1_1_3_1_0() { return cArgumentsRootExpressionParserRuleCall_1_1_3_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_1_4() { return cRightParenthesisKeyword_1_1_4; }
	}
	public class ClassVarDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.ClassVarDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOwnerTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cOwnerTypeGenNameCrossReference_0_0 = (CrossReference)cOwnerTypeAssignment_0.eContents().get(0);
		private final RuleCall cOwnerTypeGenNameIDTerminalRuleCall_0_0_1 = (RuleCall)cOwnerTypeGenNameCrossReference_0_0.eContents().get(1);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeInstAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cTypeInstExpressionVariableCrossReference_2_0 = (CrossReference)cTypeInstAssignment_2.eContents().get(0);
		private final RuleCall cTypeInstExpressionVariableIDTerminalRuleCall_2_0_1 = (RuleCall)cTypeInstExpressionVariableCrossReference_2_0.eContents().get(1);
		
		///* This is used to get variables from a class I think that it may be only applicable for
		// * concrete and polynomial types, but I'm not entirely sure. */ ClassVarDecl:
		//	ownerType=[GenName] '.' typeInst=[ExpressionVariable];
		@Override public ParserRule getRule() { return rule; }
		
		//ownerType=[GenName] '.' typeInst=[ExpressionVariable]
		public Group getGroup() { return cGroup; }
		
		//ownerType=[GenName]
		public Assignment getOwnerTypeAssignment_0() { return cOwnerTypeAssignment_0; }
		
		//[GenName]
		public CrossReference getOwnerTypeGenNameCrossReference_0_0() { return cOwnerTypeGenNameCrossReference_0_0; }
		
		//ID
		public RuleCall getOwnerTypeGenNameIDTerminalRuleCall_0_0_1() { return cOwnerTypeGenNameIDTerminalRuleCall_0_0_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }
		
		//typeInst=[ExpressionVariable]
		public Assignment getTypeInstAssignment_2() { return cTypeInstAssignment_2; }
		
		//[ExpressionVariable]
		public CrossReference getTypeInstExpressionVariableCrossReference_2_0() { return cTypeInstExpressionVariableCrossReference_2_0; }
		
		//ID
		public RuleCall getTypeInstExpressionVariableIDTerminalRuleCall_2_0_1() { return cTypeInstExpressionVariableIDTerminalRuleCall_2_0_1; }
	}
	public class ExpressionVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.ExpressionVariable");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFunctionDeclParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypedVariableParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cInstNameParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cDatatypeConstructorParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//ExpressionVariable:
		//	FunctionDecl | TypedVariable | InstName | DatatypeConstructor;
		@Override public ParserRule getRule() { return rule; }
		
		//FunctionDecl | TypedVariable | InstName | DatatypeConstructor
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//FunctionDecl
		public RuleCall getFunctionDeclParserRuleCall_0() { return cFunctionDeclParserRuleCall_0; }
		
		//TypedVariable
		public RuleCall getTypedVariableParserRuleCall_1() { return cTypedVariableParserRuleCall_1; }
		
		//InstName
		public RuleCall getInstNameParserRuleCall_2() { return cInstNameParserRuleCall_2; }
		
		//DatatypeConstructor
		public RuleCall getDatatypeConstructorParserRuleCall_3() { return cDatatypeConstructorParserRuleCall_3; }
	}
	public class InbuiltInfixElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.InbuiltInfix");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLeftRightDoubleArrowKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cRightwardsDoubleArrowKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cNotEqualToKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cLogicalAndKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cLogicalOrKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		
		///* Currently all of the Inbuilt infix operators declared here are predicate operators, the code 
		// * therefore assumes this is the case. If a new inbuilt operator is included that isn't a predicate
		// * operator the code in InfixImpl needs to be changed to check for this. */ InbuiltInfix:
		//	'⇔' | '⇒' | '=' | '≠' | '∧' | '∨';
		@Override public ParserRule getRule() { return rule; }
		
		//'⇔' | '⇒' | '=' | '≠' | '∧' | '∨'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'⇔'
		public Keyword getLeftRightDoubleArrowKeyword_0() { return cLeftRightDoubleArrowKeyword_0; }
		
		//'⇒'
		public Keyword getRightwardsDoubleArrowKeyword_1() { return cRightwardsDoubleArrowKeyword_1; }
		
		//'='
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }
		
		//'≠'
		public Keyword getNotEqualToKeyword_3() { return cNotEqualToKeyword_3; }
		
		//'∧'
		public Keyword getLogicalAndKeyword_4() { return cLogicalAndKeyword_4; }
		
		//'∨'
		public Keyword getLogicalOrKeyword_5() { return cLogicalOrKeyword_5; }
	}
	public class WrappedInfixElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.WrappedInfix");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cInbuiltAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cInbuiltInbuiltInfixParserRuleCall_1_0_0 = (RuleCall)cInbuiltAssignment_1_0.eContents().get(0);
		private final Assignment cFuncNameAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final CrossReference cFuncNameExpressionVariableCrossReference_1_1_0 = (CrossReference)cFuncNameAssignment_1_1.eContents().get(0);
		private final RuleCall cFuncNameExpressionVariableIDTerminalRuleCall_1_1_0_1 = (RuleCall)cFuncNameExpressionVariableCrossReference_1_1_0.eContents().get(1);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		///* Todo scope/validate this. */ WrappedInfix:
		//	'[' (inbuilt=InbuiltInfix | funcName=[ExpressionVariable]) ']';
		@Override public ParserRule getRule() { return rule; }
		
		//'[' (inbuilt=InbuiltInfix | funcName=[ExpressionVariable]) ']'
		public Group getGroup() { return cGroup; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//inbuilt=InbuiltInfix | funcName=[ExpressionVariable]
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//inbuilt=InbuiltInfix
		public Assignment getInbuiltAssignment_1_0() { return cInbuiltAssignment_1_0; }
		
		//InbuiltInfix
		public RuleCall getInbuiltInbuiltInfixParserRuleCall_1_0_0() { return cInbuiltInbuiltInfixParserRuleCall_1_0_0; }
		
		//funcName=[ExpressionVariable]
		public Assignment getFuncNameAssignment_1_1() { return cFuncNameAssignment_1_1; }
		
		//[ExpressionVariable]
		public CrossReference getFuncNameExpressionVariableCrossReference_1_1_0() { return cFuncNameExpressionVariableCrossReference_1_1_0; }
		
		//ID
		public RuleCall getFuncNameExpressionVariableIDTerminalRuleCall_1_1_0_1() { return cFuncNameExpressionVariableIDTerminalRuleCall_1_1_0_1; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}
	public class InstanceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.Instance");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cInstanceKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cClassNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cClassNameBSClassCrossReference_1_0 = (CrossReference)cClassNameAssignment_1.eContents().get(0);
		private final RuleCall cClassNameBSClassQualifiedNameParserRuleCall_1_0_1 = (RuleCall)cClassNameBSClassCrossReference_1_0.eContents().get(1);
		private final Assignment cContextAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cContextTypeDeclContextParserRuleCall_2_0 = (RuleCall)cContextAssignment_2.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cArgumentsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cArgumentsRootExpressionParserRuleCall_4_0 = (RuleCall)cArgumentsAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cCommaKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cArgumentsAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cArgumentsRootExpressionParserRuleCall_5_1_0 = (RuleCall)cArgumentsAssignment_5_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cNameAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cNameIDTerminalRuleCall_7_0 = (RuleCall)cNameAssignment_7.eContents().get(0);
		
		///* ------------------------------ Instance ---------------------------------------------*/ Instance:
		//	'Instance' className=[BSClass|QualifiedName] context=TypeDeclContext '(' arguments+=RootExpression? (','
		//	arguments+=RootExpression)* ')' name=ID?;
		@Override public ParserRule getRule() { return rule; }
		
		//'Instance' className=[BSClass|QualifiedName] context=TypeDeclContext '(' arguments+=RootExpression? (','
		//arguments+=RootExpression)* ')' name=ID?
		public Group getGroup() { return cGroup; }
		
		//'Instance'
		public Keyword getInstanceKeyword_0() { return cInstanceKeyword_0; }
		
		//className=[BSClass|QualifiedName]
		public Assignment getClassNameAssignment_1() { return cClassNameAssignment_1; }
		
		//[BSClass|QualifiedName]
		public CrossReference getClassNameBSClassCrossReference_1_0() { return cClassNameBSClassCrossReference_1_0; }
		
		//QualifiedName
		public RuleCall getClassNameBSClassQualifiedNameParserRuleCall_1_0_1() { return cClassNameBSClassQualifiedNameParserRuleCall_1_0_1; }
		
		//context=TypeDeclContext
		public Assignment getContextAssignment_2() { return cContextAssignment_2; }
		
		//TypeDeclContext
		public RuleCall getContextTypeDeclContextParserRuleCall_2_0() { return cContextTypeDeclContextParserRuleCall_2_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }
		
		//arguments+=RootExpression?
		public Assignment getArgumentsAssignment_4() { return cArgumentsAssignment_4; }
		
		//RootExpression
		public RuleCall getArgumentsRootExpressionParserRuleCall_4_0() { return cArgumentsRootExpressionParserRuleCall_4_0; }
		
		//(',' arguments+=RootExpression)*
		public Group getGroup_5() { return cGroup_5; }
		
		//','
		public Keyword getCommaKeyword_5_0() { return cCommaKeyword_5_0; }
		
		//arguments+=RootExpression
		public Assignment getArgumentsAssignment_5_1() { return cArgumentsAssignment_5_1; }
		
		//RootExpression
		public RuleCall getArgumentsRootExpressionParserRuleCall_5_1_0() { return cArgumentsRootExpressionParserRuleCall_5_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }
		
		//name=ID?
		public Assignment getNameAssignment_7() { return cNameAssignment_7; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_7_0() { return cNameIDTerminalRuleCall_7_0; }
	}
	
	
	private final TopLevelElements pTopLevel;
	private final TerminalRule tID;
	private final THM_NAMEElements pTHM_NAME;
	private final TopLevelFileElements pTopLevelFile;
	private final ClassDeclElements pClassDecl;
	private final TypeElements pType;
	private final GenNameElements pGenName;
	private final QualifiedNameElements pQualifiedName;
	private final QualifiedNameWithWildcardElements pQualifiedNameWithWildcard;
	private final TopLevelImportElements pTopLevelImport;
	private final BodyElementsElements pBodyElements;
	private final GlobalImportElements pGlobalImport;
	private final FileImportElements pFileImport;
	private final LocalImportElements pLocalImport;
	private final ClassElements pClass;
	private final InstNameElements pInstName;
	private final PolyContextElements pPolyContext;
	private final PolyTypeElements pPolyType;
	private final SuperTypeListElements pSuperTypeList;
	private final TypeBuilderElements pTypeBuilder;
	private final BuiltinTypeInfixOpElements pBuiltinTypeInfixOp;
	private final ConstructedTypeElements pConstructedType;
	private final BuilderElemElements pBuilderElem;
	private final TypeConstructorElements pTypeConstructor;
	private final TypePowerSetElements pTypePowerSet;
	private final TypeConstrBracketElements pTypeConstrBracket;
	private final TypeDeclContextElements pTypeDeclContext;
	private final WhereElements pWhere;
	private final DatatypeElements pDatatype;
	private final DatatypeConstructorElements pDatatypeConstructor;
	private final ExtendElements pExtend;
	private final BSharpBlockElements pBSharpBlock;
	private final FunctionDeclElements pFunctionDecl;
	private final MatchStatementElements pMatchStatement;
	private final MatchCaseElements pMatchCase;
	private final TheoremBodyElements pTheoremBody;
	private final TheoremDeclElements pTheoremDecl;
	private final TypedVariableListElements pTypedVariableList;
	private final VariableTypingElements pVariableTyping;
	private final TypedVariableElements pTypedVariable;
	private final LambdaElements pLambda;
	private final QuantifierElements pQuantifier;
	private final RootExpressionElements pRootExpression;
	private final PrefixElements pPrefix;
	private final PrefixBuiltInElements pPrefixBuiltIn;
	private final InfixElements pInfix;
	private final ElementElements pElement;
	private final BracketElements pBracket;
	private final FunctionCallElements pFunctionCall;
	private final ClassVarDeclElements pClassVarDecl;
	private final ExpressionVariableElements pExpressionVariable;
	private final InbuiltInfixElements pInbuiltInfix;
	private final WrappedInfixElements pWrappedInfix;
	private final InstanceElements pInstance;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public BSharpGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pTopLevel = new TopLevelElements();
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.bsharp.BSharp.ID");
		this.pTHM_NAME = new THM_NAMEElements();
		this.pTopLevelFile = new TopLevelFileElements();
		this.pClassDecl = new ClassDeclElements();
		this.pType = new TypeElements();
		this.pGenName = new GenNameElements();
		this.pQualifiedName = new QualifiedNameElements();
		this.pQualifiedNameWithWildcard = new QualifiedNameWithWildcardElements();
		this.pTopLevelImport = new TopLevelImportElements();
		this.pBodyElements = new BodyElementsElements();
		this.pGlobalImport = new GlobalImportElements();
		this.pFileImport = new FileImportElements();
		this.pLocalImport = new LocalImportElements();
		this.pClass = new ClassElements();
		this.pInstName = new InstNameElements();
		this.pPolyContext = new PolyContextElements();
		this.pPolyType = new PolyTypeElements();
		this.pSuperTypeList = new SuperTypeListElements();
		this.pTypeBuilder = new TypeBuilderElements();
		this.pBuiltinTypeInfixOp = new BuiltinTypeInfixOpElements();
		this.pConstructedType = new ConstructedTypeElements();
		this.pBuilderElem = new BuilderElemElements();
		this.pTypeConstructor = new TypeConstructorElements();
		this.pTypePowerSet = new TypePowerSetElements();
		this.pTypeConstrBracket = new TypeConstrBracketElements();
		this.pTypeDeclContext = new TypeDeclContextElements();
		this.pWhere = new WhereElements();
		this.pDatatype = new DatatypeElements();
		this.pDatatypeConstructor = new DatatypeConstructorElements();
		this.pExtend = new ExtendElements();
		this.pBSharpBlock = new BSharpBlockElements();
		this.pFunctionDecl = new FunctionDeclElements();
		this.pMatchStatement = new MatchStatementElements();
		this.pMatchCase = new MatchCaseElements();
		this.pTheoremBody = new TheoremBodyElements();
		this.pTheoremDecl = new TheoremDeclElements();
		this.pTypedVariableList = new TypedVariableListElements();
		this.pVariableTyping = new VariableTypingElements();
		this.pTypedVariable = new TypedVariableElements();
		this.pLambda = new LambdaElements();
		this.pQuantifier = new QuantifierElements();
		this.pRootExpression = new RootExpressionElements();
		this.pPrefix = new PrefixElements();
		this.pPrefixBuiltIn = new PrefixBuiltInElements();
		this.pInfix = new InfixElements();
		this.pElement = new ElementElements();
		this.pBracket = new BracketElements();
		this.pFunctionCall = new FunctionCallElements();
		this.pClassVarDecl = new ClassVarDeclElements();
		this.pExpressionVariable = new ExpressionVariableElements();
		this.pInbuiltInfix = new InbuiltInfixElements();
		this.pWrappedInfix = new WrappedInfixElements();
		this.pInstance = new InstanceElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("ac.soton.bsharp.BSharp".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//TopLevel:
	//	'package' name=QualifiedName
	//	topLevelFile=TopLevelFile;
	public TopLevelElements getTopLevelAccess() {
		return pTopLevel;
	}
	
	public ParserRule getTopLevelRule() {
		return getTopLevelAccess().getRule();
	}
	
	//@Override
	//terminal ID:
	//	('a'..'z' | 'A'..'Z' | '_' | 'i'..'ￜ') ('a'..'z' | 'A'..'Z' | '_' | 'i'..'ￜ' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return tID;
	}
	
	//// Theorem names can include white space. Work out how to change this to any string without a ':'
	//THM_NAME:
	//	(INT | ID | WS)* ":";
	public THM_NAMEElements getTHM_NAMEAccess() {
		return pTHM_NAME;
	}
	
	public ParserRule getTHM_NAMERule() {
		return getTHM_NAMEAccess().getRule();
	}
	
	///* TopLevelFile has a hidden name tag which is the file name, this gets the filename into the
	// * fully qualified domain names allowing multiple classes per file nicely. TopLevelImport allows
	// * the easy splitting of the file based on import locations. It also makes it easy to scope imports
	// * so only imports above the current location are scoped.
	// */ TopLevelFile:
	//	{TopLevelFile} noImportElements=BodyElements? topLevelImports+=TopLevelImport*;
	public TopLevelFileElements getTopLevelFileAccess() {
		return pTopLevelFile;
	}
	
	public ParserRule getTopLevelFileRule() {
		return getTopLevelFileAccess().getRule();
	}
	
	//ClassDecl:
	//	Class | Datatype;
	public ClassDeclElements getClassDeclAccess() {
		return pClassDecl;
	}
	
	public ParserRule getClassDeclRule() {
		return getClassDeclAccess().getRule();
	}
	
	///* There are three Types which can be used as type variables, inbuilt types, types create
	// * with ClassDecl (type classes and Datatypes) and Polymorphic types. There are different
	// * occasions where each of these can be used.
	// */ Type:
	//	ClassDecl;
	public TypeElements getTypeAccess() {
		return pType;
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}
	
	//GenName:
	//	PolyType | Type | InstName;
	public GenNameElements getGenNameAccess() {
		return pGenName;
	}
	
	public ParserRule getGenNameRule() {
		return getGenNameAccess().getRule();
	}
	
	///* -------------------------- Import Statements -------------------- */ /* I had hoped to use a python style import, however this seems to be fighting 
	// * the system, and would require a custom implementation of DefaultDeclarativeQualifiedNameProvider.
	// * To increase the development speed I am using the java style imports instead.
	// */ QualifiedName:
	//	ID ('.' ID)*;
	public QualifiedNameElements getQualifiedNameAccess() {
		return pQualifiedName;
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}
	
	//QualifiedNameWithWildcard:
	//	QualifiedName '.*'?;
	public QualifiedNameWithWildcardElements getQualifiedNameWithWildcardAccess() {
		return pQualifiedNameWithWildcard;
	}
	
	public ParserRule getQualifiedNameWithWildcardRule() {
		return getQualifiedNameWithWildcardAccess().getRule();
	}
	
	//TopLevelImport:
	//	(globalImports+=GlobalImport | localImports+=LocalImport)+ bodyElements=BodyElements;
	public TopLevelImportElements getTopLevelImportAccess() {
		return pTopLevelImport;
	}
	
	public ParserRule getTopLevelImportRule() {
		return getTopLevelImportAccess().getRule();
	}
	
	//BodyElements:
	//	(classes+=ClassDecl | extends+=Extend)+;
	public BodyElementsElements getBodyElementsAccess() {
		return pBodyElements;
	}
	
	public ParserRule getBodyElementsRule() {
		return getBodyElementsAccess().getRule();
	}
	
	//GlobalImport:
	//	'From' project=QualifiedName 'Import' fileImports+=FileImport+;
	public GlobalImportElements getGlobalImportAccess() {
		return pGlobalImport;
	}
	
	public ParserRule getGlobalImportRule() {
		return getGlobalImportAccess().getRule();
	}
	
	///* Imports other files from the current project. The optional type ID allows the importing
	// * of a specific type from the file. */ FileImport:
	//	fileReference=[TopLevelFile] ('.' ('*' | type=ID))?;
	public FileImportElements getFileImportAccess() {
		return pFileImport;
	}
	
	public ParserRule getFileImportRule() {
		return getFileImportAccess().getRule();
	}
	
	//LocalImport:
	//	'Import' fileImports+=FileImport+;
	public LocalImportElements getLocalImportAccess() {
		return pLocalImport;
	}
	
	public ParserRule getLocalImportRule() {
		return getLocalImportAccess().getRule();
	}
	
	///* ------------------------ Class statements --------------------- */ Class BSClass:
	//	'Class' name=ID context=PolyContext? ('[' instName=InstName ']') supertypes=SuperTypeList? ('('
	//	varList=TypedVariableList ')')? where=Where? ';'?
	//	block=BSharpBlock;
	public ClassElements getClassAccess() {
		return pClass;
	}
	
	public ParserRule getClassRule() {
		return getClassAccess().getRule();
	}
	
	//InstName:
	//	name=ID;
	public InstNameElements getInstNameAccess() {
		return pInstName;
	}
	
	public ParserRule getInstNameRule() {
		return getInstNameAccess().getRule();
	}
	
	///*---------------- Polymorphic Context of -------------------------- */ PolyContext:
	//	'<' polyTypes+=PolyType+ '>';
	public PolyContextElements getPolyContextAccess() {
		return pPolyContext;
	}
	
	public ParserRule getPolyContextRule() {
		return getPolyContextAccess().getRule();
	}
	
	//PolyType:
	//	name=ID (':' superTypes+=[ClassDecl|QualifiedName] (',' superTypes+=[ClassDecl|QualifiedName])*)?;
	public PolyTypeElements getPolyTypeAccess() {
		return pPolyType;
	}
	
	public ParserRule getPolyTypeRule() {
		return getPolyTypeAccess().getRule();
	}
	
	///* ------------------- SuperTypes ---------------------------------- */ /* Any constriction on the polymorphic context has to be done by declaring the polymorphic context
	// * on the new type. If necessary the polymorphic context can be used within type constructors. In the simple case 
	// * this will be inferred . Required thought on checking the base types of the super types. At some points these
	// * need to be identical declarations. It is also necessary to allow EventB style type constructors at this
	// * point. e.g., an associative operator is a subtype of a closed Event-B total function.
	// */ SuperTypeList:
	//	':' superTypes+=ConstructedType (',' superTypes+=ConstructedType)*;
	public SuperTypeListElements getSuperTypeListAccess() {
		return pSuperTypeList;
	}
	
	public ParserRule getSuperTypeListRule() {
		return getSuperTypeListAccess().getRule();
	}
	
	//TypeBuilder:
	//	ConstructedType | TypeConstructor | TypePowerSet | TypeConstrBracket;
	public TypeBuilderElements getTypeBuilderAccess() {
		return pTypeBuilder;
	}
	
	public ParserRule getTypeBuilderRule() {
		return getTypeBuilderAccess().getRule();
	}
	
	//BuiltinTypeInfixOp:
	//	'×' | '→' | '' | '' | '↔' | '⤖' | '⇸' | '↣' | '⤀' | '↠';
	public BuiltinTypeInfixOpElements getBuiltinTypeInfixOpAccess() {
		return pBuiltinTypeInfixOp;
	}
	
	public ParserRule getBuiltinTypeInfixOpRule() {
		return getBuiltinTypeInfixOpAccess().getRule();
	}
	
	///* Along with the normal Event-B type operator, and new B++ types the  */ ConstructedType TypeBuilder:
	//	BuilderElem ({ConstructedType.left=current} constructor=BuiltinTypeInfixOp right=BuilderElem)*;
	public ConstructedTypeElements getConstructedTypeAccess() {
		return pConstructedType;
	}
	
	public ParserRule getConstructedTypeRule() {
		return getConstructedTypeAccess().getRule();
	}
	
	//BuilderElem TypeBuilder:
	//	TypeConstructor | TypeConstrBracket | TypePowerSet;
	public BuilderElemElements getBuilderElemAccess() {
		return pBuilderElem;
	}
	
	public ParserRule getBuilderElemRule() {
		return getBuilderElemAccess().getRule();
	}
	
	///* Type constructor has validation rules to check that there is no context when there is a polymorphic name, 
	// * and type checking on the polymorphic context. There is also  scope rule to check the usage of polymorphic types.
	// * Probably need to add the predicate type to this.
	// */ TypeConstructor:
	//	typeName=[GenName|QualifiedName] context=TypeDeclContext?;
	public TypeConstructorElements getTypeConstructorAccess() {
		return pTypeConstructor;
	}
	
	public ParserRule getTypeConstructorRule() {
		return getTypeConstructorAccess().getRule();
	}
	
	//TypePowerSet:
	//	'ℙ' '(' child=ConstructedType ')';
	public TypePowerSetElements getTypePowerSetAccess() {
		return pTypePowerSet;
	}
	
	public ParserRule getTypePowerSetRule() {
		return getTypePowerSetAccess().getRule();
	}
	
	//TypeConstrBracket:
	//	'(' child=ConstructedType ')';
	public TypeConstrBracketElements getTypeConstrBracketAccess() {
		return pTypeConstrBracket;
	}
	
	public ParserRule getTypeConstrBracketRule() {
		return getTypeConstrBracketAccess().getRule();
	}
	
	///* This is used in two different situations, and may well compile the same for both so don't delete
	// * unless the compilation of the two places is different (even then it is more pleasant to not have
	// * two identical syntax declarations in this file).
	// */ TypeDeclContext:
	//	'<' typeName+=ConstructedType (',' typeName+=ConstructedType)* '>';
	public TypeDeclContextElements getTypeDeclContextAccess() {
		return pTypeDeclContext;
	}
	
	public ParserRule getTypeDeclContextRule() {
		return getTypeDeclContextAccess().getRule();
	}
	
	///* -------------------- Where Statement -------------------------------- */ /* Type checking (which is not implemented yet) is used to type check that Expression returns a 
	// * predicate. Expression has not yet been written, but is far too general to be included in the where
	// * statement.
	// */ Where:
	//	'where' expressions+=RootExpression (';' expressions+=RootExpression)*;
	public WhereElements getWhereAccess() {
		return pWhere;
	}
	
	public ParserRule getWhereRule() {
		return getWhereAccess().getRule();
	}
	
	///* ---------------------- Datatype declarations -------------------------- */ Datatype:
	//	'Datatype' name=ID context=PolyContext? ('|' constructors+=DatatypeConstructor)+ block=BSharpBlock;
	public DatatypeElements getDatatypeAccess() {
		return pDatatype;
	}
	
	public ParserRule getDatatypeRule() {
		return getDatatypeAccess().getRule();
	}
	
	///* PolyContext is the same as PolyContext used by the class declaration above. */ DatatypeConstructor:
	//	name=ID ('(' decons=TypedVariableList ')')?;
	public DatatypeConstructorElements getDatatypeConstructorAccess() {
		return pDatatypeConstructor;
	}
	
	public ParserRule getDatatypeConstructorRule() {
		return getDatatypeConstructorAccess().getRule();
	}
	
	///* ------------------------ Extension statement ---------------------------- */ Extend:
	//	'Extend' extendedClass=[ClassDecl|QualifiedName] '(' name=ID ')' block=BSharpBlock;
	public ExtendElements getExtendAccess() {
		return pExtend;
	}
	
	public ParserRule getExtendRule() {
		return getExtendAccess().getRule();
	}
	
	///* ------------------------ TypeBodyElements ------------------------------- */ /* The ordering of theorem bodies and instances is imported so they need to go into
	// * a joint list to maintain the order.
	// */ BSharpBlock:
	//	{BSharpBlock}
	//	'{' (functions+=FunctionDecl | theorems+=TheoremBody | theorems+=Instance)* '}';
	public BSharpBlockElements getBSharpBlockAccess() {
		return pBSharpBlock;
	}
	
	public ParserRule getBSharpBlockRule() {
		return getBSharpBlockAccess().getRule();
	}
	
	///*------------------------- Functions --------------------------------- */ FunctionDecl:
	//	name=ID context=PolyContext? '(' varList=TypedVariableList? ')' ':' returnType=TypeConstructor infix='INFIX'?
	//	precedence=INT? expr=RootExpression;
	public FunctionDeclElements getFunctionDeclAccess() {
		return pFunctionDecl;
	}
	
	public ParserRule getFunctionDeclRule() {
		return getFunctionDeclAccess().getRule();
	}
	
	//MatchStatement:
	//	'match' match=RootExpression '{'
	//	inductCase+=MatchCase inductCase+=MatchCase* '}';
	public MatchStatementElements getMatchStatementAccess() {
		return pMatchStatement;
	}
	
	public ParserRule getMatchStatementRule() {
		return getMatchStatementAccess().getRule();
	}
	
	//MatchCase:
	//	'|' deconName=[DatatypeConstructor] ('(' variables+=TypedVariable (',' variables+=TypedVariable)* ')')? ':'
	//	expr=RootExpression;
	public MatchCaseElements getMatchCaseAccess() {
		return pMatchCase;
	}
	
	public ParserRule getMatchCaseRule() {
		return getMatchCaseAccess().getRule();
	}
	
	///* ----------------------------- Theorems -------------------------*/ TheoremBody:
	//	'Theorems' '{' theoremDecl+=TheoremDecl+ '}';
	public TheoremBodyElements getTheoremBodyAccess() {
		return pTheoremBody;
	}
	
	public ParserRule getTheoremBodyRule() {
		return getTheoremBodyAccess().getRule();
	}
	
	///* Type check that the expression is a predicate expression. From a lexing point
	// * of view the semicolon is necessary because the THM_NAME rule is not good enough.
	// */ TheoremDecl:
	//	name=THM_NAME expr=RootExpression ';';
	public TheoremDeclElements getTheoremDeclAccess() {
		return pTheoremDecl;
	}
	
	public ParserRule getTheoremDeclRule() {
		return getTheoremDeclAccess().getRule();
	}
	
	//TypedVariableList:
	//	variablesOfType+=VariableTyping (',' variablesOfType+=VariableTyping)*;
	public TypedVariableListElements getTypedVariableListAccess() {
		return pTypedVariableList;
	}
	
	public ParserRule getTypedVariableListRule() {
		return getTypedVariableListAccess().getRule();
	}
	
	//VariableTyping:
	//	typeVar+=TypedVariable (',' typeVar+=TypedVariable)* ':' type=ConstructedType;
	public VariableTypingElements getVariableTypingAccess() {
		return pVariableTyping;
	}
	
	public ParserRule getVariableTypingRule() {
		return getVariableTypingAccess().getRule();
	}
	
	///* I think this is here for reference purposes, e.g., otherwise it's quite difficult
	// * to cross reference individual type names. */ TypedVariable:
	//	name=ID;
	public TypedVariableElements getTypedVariableAccess() {
		return pTypedVariable;
	}
	
	public ParserRule getTypedVariableRule() {
		return getTypedVariableAccess().getRule();
	}
	
	///* --------------------------- Expressions -------------------------- */
	///* --------------------------- Lambda and Quantifier ---------------- */
	///* The structure of Lambda and Quantifier are so similar that they're going to share a class */ Lambda QuantLambda:
	//	qType='λ' context=PolyContext? varList=TypedVariableList '|' expr=RootExpression;
	public LambdaElements getLambdaAccess() {
		return pLambda;
	}
	
	public ParserRule getLambdaRule() {
		return getLambdaAccess().getRule();
	}
	
	//Quantifier QuantLambda:
	//	qType=('∀' | '∃') context=PolyContext? varList=TypedVariableList '·' expr=RootExpression;
	public QuantifierElements getQuantifierAccess() {
		return pQuantifier;
	}
	
	public ParserRule getQuantifierRule() {
		return getQuantifierAccess().getRule();
	}
	
	//RootExpression Expression:
	//	Lambda | Quantifier | Infix | MatchStatement;
	public RootExpressionElements getRootExpressionAccess() {
		return pRootExpression;
	}
	
	public ParserRule getRootExpressionRule() {
		return getRootExpressionAccess().getRule();
	}
	
	///* ---------------------- *Fix ------------------------------ */ Prefix:
	//	name=PrefixBuiltIn elem=Element;
	public PrefixElements getPrefixAccess() {
		return pPrefix;
	}
	
	public ParserRule getPrefixRule() {
		return getPrefixAccess().getRule();
	}
	
	//PrefixBuiltIn:
	//	'¬';
	public PrefixBuiltInElements getPrefixBuiltInAccess() {
		return pPrefixBuiltIn;
	}
	
	public ParserRule getPrefixBuiltInRule() {
		return getPrefixBuiltInAccess().getRule();
	}
	
	///* Infix operators cause problems, there are two issues one is avoiding left recursion this 
	// * is covered adequately here: https://www.eclipse.org/Xtext/documentation/307_special_languages.html#expressions 
	// * The second issue is precedence, this is also covered in the link above, however, implementing it in the 
	// * way suggested above will not scale to the creation of ones own infix functions, instead the initial implementation
	// * will require brackets for precedence. After that a system will be implemented where each infix operator will 
	// * be given a precedence value with higher values being higher precedence. It looks like this can be done by
	// * changing the parser using the MyDSLRuntimeModule to build the abstract syntax tree based on the value of the 
	// * operators.
	// * Before the precedence code is written into a parser override, all the expressions are in effect right bracketed,
	// * as you may expect from a language that is read from left to right.
	// * 
	// * TODO: Programmatically check that the function is an infix function.
	// */ Infix Expression:
	//	Element ({Infix.left=current} (funcName=[FunctionDecl] | opName=InbuiltInfix) right=Element)*;
	public InfixElements getInfixAccess() {
		return pInfix;
	}
	
	public ParserRule getInfixRule() {
		return getInfixAccess().getRule();
	}
	
	///* currently it will not build because the quantifier is causing recursion I think. 
	// * I think that we need a quantifier free expression to solve the problem Similar to the way
	// * precedence is handled here: https://typefox.io/parsing-expressions-with-xtext
	// */ Element Expression:
	//	Bracket | Prefix | FunctionCall;
	public ElementElements getElementAccess() {
		return pElement;
	}
	
	public ParserRule getElementRule() {
		return getElementAccess().getRule();
	}
	
	//Bracket:
	//	'(' child=RootExpression ')';
	public BracketElements getBracketAccess() {
		return pBracket;
	}
	
	public ParserRule getBracketRule() {
		return getBracketAccess().getRule();
	}
	
	///* This produces an interesting issue in parsing the program because it is necessary to distinguish between the following three
	// * scenarios: 
	// * A function call f(arguments)
	// * A infix function with a bracketed argument on the right 10 f (arguments)
	// * A function used without any arguments f add g 
	// * 
	// * To solve this functions can either be Prefix, Infix, or called with bracketed arguments. You cannot call a Infix function with bracketd 
	// * arguments. To do this you would need to write another function to make this call for you. In coq this is achieved when you declare a function
	// * you can add a operator name to the function, which is either infix or prefix, this again gives the two names for the function allowing 
	// * it to be called either as an operator or a functional call.
	// * 
	// * This expressions needs a lot of programmatic checking! Starting with the count of the arguments, followed by type checking the arguments.
	// */ FunctionCall:
	//	wrapped=WrappedInfix | (typeInst=[ExpressionVariable] | classVarDecl=ClassVarDecl) (context=TypeDeclContext? '('
	//	arguments+=RootExpression? (',' arguments+=RootExpression)* ')')?;
	public FunctionCallElements getFunctionCallAccess() {
		return pFunctionCall;
	}
	
	public ParserRule getFunctionCallRule() {
		return getFunctionCallAccess().getRule();
	}
	
	///* This is used to get variables from a class I think that it may be only applicable for
	// * concrete and polynomial types, but I'm not entirely sure. */ ClassVarDecl:
	//	ownerType=[GenName] '.' typeInst=[ExpressionVariable];
	public ClassVarDeclElements getClassVarDeclAccess() {
		return pClassVarDecl;
	}
	
	public ParserRule getClassVarDeclRule() {
		return getClassVarDeclAccess().getRule();
	}
	
	//ExpressionVariable:
	//	FunctionDecl | TypedVariable | InstName | DatatypeConstructor;
	public ExpressionVariableElements getExpressionVariableAccess() {
		return pExpressionVariable;
	}
	
	public ParserRule getExpressionVariableRule() {
		return getExpressionVariableAccess().getRule();
	}
	
	///* Currently all of the Inbuilt infix operators declared here are predicate operators, the code 
	// * therefore assumes this is the case. If a new inbuilt operator is included that isn't a predicate
	// * operator the code in InfixImpl needs to be changed to check for this. */ InbuiltInfix:
	//	'⇔' | '⇒' | '=' | '≠' | '∧' | '∨';
	public InbuiltInfixElements getInbuiltInfixAccess() {
		return pInbuiltInfix;
	}
	
	public ParserRule getInbuiltInfixRule() {
		return getInbuiltInfixAccess().getRule();
	}
	
	///* Todo scope/validate this. */ WrappedInfix:
	//	'[' (inbuilt=InbuiltInfix | funcName=[ExpressionVariable]) ']';
	public WrappedInfixElements getWrappedInfixAccess() {
		return pWrappedInfix;
	}
	
	public ParserRule getWrappedInfixRule() {
		return getWrappedInfixAccess().getRule();
	}
	
	///* ------------------------------ Instance ---------------------------------------------*/ Instance:
	//	'Instance' className=[BSClass|QualifiedName] context=TypeDeclContext '(' arguments+=RootExpression? (','
	//	arguments+=RootExpression)* ')' name=ID?;
	public InstanceElements getInstanceAccess() {
		return pInstance;
	}
	
	public ParserRule getInstanceRule() {
		return getInstanceAccess().getRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
