/*
 * generated by Xtext 2.14.0
 */
package ac.soton.bsharp.serializer;

import ac.soton.bsharp.bSharp.BSharpPackage;
import ac.soton.bsharp.bSharp.BppClass;
import ac.soton.bsharp.bSharp.Bracket;
import ac.soton.bsharp.bSharp.ConstructedType;
import ac.soton.bsharp.bSharp.Datatype;
import ac.soton.bsharp.bSharp.DatatypeConstructor;
import ac.soton.bsharp.bSharp.DomainModel;
import ac.soton.bsharp.bSharp.Extend;
import ac.soton.bsharp.bSharp.FunctionCall;
import ac.soton.bsharp.bSharp.FunctionDecl;
import ac.soton.bsharp.bSharp.FunctionName;
import ac.soton.bsharp.bSharp.ImportStatement;
import ac.soton.bsharp.bSharp.Infix;
import ac.soton.bsharp.bSharp.Instance;
import ac.soton.bsharp.bSharp.MatchCase;
import ac.soton.bsharp.bSharp.MatchStatement;
import ac.soton.bsharp.bSharp.PolyContext;
import ac.soton.bsharp.bSharp.PolyContextTypes;
import ac.soton.bsharp.bSharp.PolyTypeConstraints;
import ac.soton.bsharp.bSharp.PolymorphicTypeName;
import ac.soton.bsharp.bSharp.Prefix;
import ac.soton.bsharp.bSharp.QuantLambda;
import ac.soton.bsharp.bSharp.SuperTypeList;
import ac.soton.bsharp.bSharp.TheoremBody;
import ac.soton.bsharp.bSharp.TheoremDecl;
import ac.soton.bsharp.bSharp.TopLevel;
import ac.soton.bsharp.bSharp.TypeBodyElements;
import ac.soton.bsharp.bSharp.TypeConstructor;
import ac.soton.bsharp.bSharp.TypeDeclContext;
import ac.soton.bsharp.bSharp.TypeStructure;
import ac.soton.bsharp.bSharp.TypedVariable;
import ac.soton.bsharp.bSharp.TypedVariableList;
import ac.soton.bsharp.bSharp.VariableTyping;
import ac.soton.bsharp.bSharp.Where;
import ac.soton.bsharp.services.BSharpGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class BSharpSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private BSharpGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == BSharpPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case BSharpPackage.BPP_CLASS:
				sequence_Class(context, (BppClass) semanticObject); 
				return; 
			case BSharpPackage.BRACKET:
				sequence_Bracket(context, (Bracket) semanticObject); 
				return; 
			case BSharpPackage.CONSTRUCTED_TYPE:
				sequence_ConstructedType(context, (ConstructedType) semanticObject); 
				return; 
			case BSharpPackage.DATATYPE:
				sequence_Datatype(context, (Datatype) semanticObject); 
				return; 
			case BSharpPackage.DATATYPE_CONSTRUCTOR:
				sequence_DatatypeConstructor(context, (DatatypeConstructor) semanticObject); 
				return; 
			case BSharpPackage.DOMAIN_MODEL:
				sequence_DomainModel(context, (DomainModel) semanticObject); 
				return; 
			case BSharpPackage.EXTEND:
				sequence_Extend(context, (Extend) semanticObject); 
				return; 
			case BSharpPackage.FUNCTION_CALL:
				sequence_FunctionCall(context, (FunctionCall) semanticObject); 
				return; 
			case BSharpPackage.FUNCTION_DECL:
				sequence_FunctionDecl(context, (FunctionDecl) semanticObject); 
				return; 
			case BSharpPackage.FUNCTION_NAME:
				sequence_FunctionName(context, (FunctionName) semanticObject); 
				return; 
			case BSharpPackage.IMPORT_STATEMENT:
				sequence_ImportStatement(context, (ImportStatement) semanticObject); 
				return; 
			case BSharpPackage.INFIX:
				sequence_Infix(context, (Infix) semanticObject); 
				return; 
			case BSharpPackage.INSTANCE:
				sequence_Instance(context, (Instance) semanticObject); 
				return; 
			case BSharpPackage.MATCH_CASE:
				sequence_MatchCase(context, (MatchCase) semanticObject); 
				return; 
			case BSharpPackage.MATCH_STATEMENT:
				sequence_MatchStatement(context, (MatchStatement) semanticObject); 
				return; 
			case BSharpPackage.POLY_CONTEXT:
				sequence_PolyContext(context, (PolyContext) semanticObject); 
				return; 
			case BSharpPackage.POLY_CONTEXT_TYPES:
				sequence_PolyContextTypes(context, (PolyContextTypes) semanticObject); 
				return; 
			case BSharpPackage.POLY_TYPE_CONSTRAINTS:
				sequence_PolyTypeConstraints(context, (PolyTypeConstraints) semanticObject); 
				return; 
			case BSharpPackage.POLYMORPHIC_TYPE_NAME:
				sequence_PolymorphicTypeName(context, (PolymorphicTypeName) semanticObject); 
				return; 
			case BSharpPackage.PREFIX:
				sequence_Prefix(context, (Prefix) semanticObject); 
				return; 
			case BSharpPackage.QUANT_LAMBDA:
				if (rule == grammarAccess.getLambdaRule()) {
					sequence_Lambda(context, (QuantLambda) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRootExpressionRule()) {
					sequence_Lambda_Quantifier(context, (QuantLambda) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getQuantifierRule()) {
					sequence_Quantifier(context, (QuantLambda) semanticObject); 
					return; 
				}
				else break;
			case BSharpPackage.SUPER_TYPE_LIST:
				sequence_SuperTypeList(context, (SuperTypeList) semanticObject); 
				return; 
			case BSharpPackage.THEOREM_BODY:
				sequence_TheoremBody(context, (TheoremBody) semanticObject); 
				return; 
			case BSharpPackage.THEOREM_DECL:
				sequence_TheoremDecl(context, (TheoremDecl) semanticObject); 
				return; 
			case BSharpPackage.TOP_LEVEL:
				sequence_TopLevel(context, (TopLevel) semanticObject); 
				return; 
			case BSharpPackage.TYPE_BODY_ELEMENTS:
				sequence_TypeBodyElements(context, (TypeBodyElements) semanticObject); 
				return; 
			case BSharpPackage.TYPE_CONSTRUCTOR:
				sequence_TypeConstructor(context, (TypeConstructor) semanticObject); 
				return; 
			case BSharpPackage.TYPE_DECL_CONTEXT:
				sequence_TypeDeclContext(context, (TypeDeclContext) semanticObject); 
				return; 
			case BSharpPackage.TYPE_STRUCTURE:
				sequence_TypeStructure(context, (TypeStructure) semanticObject); 
				return; 
			case BSharpPackage.TYPED_VARIABLE:
				sequence_TypedVariable(context, (TypedVariable) semanticObject); 
				return; 
			case BSharpPackage.TYPED_VARIABLE_LIST:
				sequence_TypedVariableList(context, (TypedVariableList) semanticObject); 
				return; 
			case BSharpPackage.VARIABLE_TYPING:
				sequence_VariableTyping(context, (VariableTyping) semanticObject); 
				return; 
			case BSharpPackage.WHERE:
				sequence_Where(context, (Where) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     RootExpression returns Bracket
	 *     Infix returns Bracket
	 *     Infix.Infix_1_0 returns Bracket
	 *     Element returns Bracket
	 *     Bracket returns Bracket
	 *
	 * Constraint:
	 *     child=RootExpression
	 */
	protected void sequence_Bracket(ISerializationContext context, Bracket semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BSharpPackage.Literals.BRACKET__CHILD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BSharpPackage.Literals.BRACKET__CHILD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBracketAccess().getChildRootExpressionParserRuleCall_1_0(), semanticObject.getChild());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassDecl returns BppClass
	 *     Type returns BppClass
	 *     GenName returns BppClass
	 *     Class returns BppClass
	 *     ExpressionVariable returns BppClass
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         context=PolyContext? 
	 *         supertypes=SuperTypeList? 
	 *         varList=TypeStructure? 
	 *         where=Where? 
	 *         bodyElements+=TypeBodyElements*
	 *     )
	 */
	protected void sequence_Class(ISerializationContext context, BppClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstructedType returns ConstructedType
	 *
	 * Constraint:
	 *     (
	 *         type+=TypeConstructor 
	 *         (
	 *             (
	 *                 constructors+='×' | 
	 *                 constructors+='→' | 
	 *                 constructors+='' | 
	 *                 constructors+='' | 
	 *                 constructors+='↔' | 
	 *                 constructors+='⤖' | 
	 *                 constructors+='⇸' | 
	 *                 constructors+='↣' | 
	 *                 constructors+='⤀' | 
	 *                 constructors+='↠'
	 *             ) 
	 *             type+=ConstructedType
	 *         )?
	 *     )
	 */
	protected void sequence_ConstructedType(ISerializationContext context, ConstructedType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DatatypeConstructor returns DatatypeConstructor
	 *
	 * Constraint:
	 *     (name=ID decons=TypedVariableList?)
	 */
	protected void sequence_DatatypeConstructor(ISerializationContext context, DatatypeConstructor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassDecl returns Datatype
	 *     Type returns Datatype
	 *     GenName returns Datatype
	 *     Datatype returns Datatype
	 *     ExpressionVariable returns Datatype
	 *
	 * Constraint:
	 *     (name=ID context=PolyContext? constructors+=DatatypeConstructor+ bodyElements+=TypeBodyElements*)
	 */
	protected void sequence_Datatype(ISerializationContext context, Datatype semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DomainModel returns DomainModel
	 *
	 * Constraint:
	 *     elements+=TopLevel+
	 */
	protected void sequence_DomainModel(ISerializationContext context, DomainModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Extend returns Extend
	 *
	 * Constraint:
	 *     (extendedClass=[ClassDecl|QualifiedName] name=ID bodyElements+=TypeBodyElements*)
	 */
	protected void sequence_Extend(ISerializationContext context, Extend semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RootExpression returns FunctionCall
	 *     Infix returns FunctionCall
	 *     Infix.Infix_1_0 returns FunctionCall
	 *     Element returns FunctionCall
	 *     FunctionCall returns FunctionCall
	 *
	 * Constraint:
	 *     (typeInst=[ExpressionVariable|QualifiedName] arguments+=RootExpression? arguments+=RootExpression*)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, FunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDecl returns FunctionDecl
	 *
	 * Constraint:
	 *     (
	 *         name=FunctionName 
	 *         context=PolyContext? 
	 *         varList=TypedVariableList? 
	 *         returnType=TypeConstructor 
	 *         infix='INFIX'? 
	 *         precedence=INT? 
	 *         expr=RootExpression
	 *     )
	 */
	protected void sequence_FunctionDecl(ISerializationContext context, FunctionDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionName returns FunctionName
	 *     ExpressionVariable returns FunctionName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_FunctionName(ISerializationContext context, FunctionName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BSharpPackage.Literals.NAMED_OBJECT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BSharpPackage.Literals.NAMED_OBJECT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ImportStatement returns ImportStatement
	 *
	 * Constraint:
	 *     imports+=QualifiedNameWithWildcard+
	 */
	protected void sequence_ImportStatement(ISerializationContext context, ImportStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RootExpression returns Infix
	 *     Infix returns Infix
	 *     Infix.Infix_1_0 returns Infix
	 *
	 * Constraint:
	 *     (left=Infix_Infix_1_0 (funcName=[FunctionName|ID] | opName=InbuiltInfix) right=Element)
	 */
	protected void sequence_Infix(ISerializationContext context, Infix semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instance returns Instance
	 *
	 * Constraint:
	 *     (className=[ClassDecl|QualifiedName] context=TypeDeclContext arguments+=RootExpression? arguments+=RootExpression*)
	 */
	protected void sequence_Instance(ISerializationContext context, Instance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Lambda returns QuantLambda
	 *
	 * Constraint:
	 *     (qType='λ' context=PolyContext? varList=TypedVariableList expr=RootExpression)
	 */
	protected void sequence_Lambda(ISerializationContext context, QuantLambda semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RootExpression returns QuantLambda
	 *
	 * Constraint:
	 *     (
	 *         (qType='λ' context=PolyContext? varList=TypedVariableList expr=RootExpression) | 
	 *         ((qType='∀' | qType='∃') context=PolyContext? varList=TypedVariableList expr=RootExpression)
	 *     )
	 */
	protected void sequence_Lambda_Quantifier(ISerializationContext context, QuantLambda semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MatchCase returns MatchCase
	 *
	 * Constraint:
	 *     (deconName=[TypedVariable|ID] (variables+=TypedVariable variables+=TypedVariable*)? expr=RootExpression)
	 */
	protected void sequence_MatchCase(ISerializationContext context, MatchCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MatchStatement returns MatchStatement
	 *     RootExpression returns MatchStatement
	 *
	 * Constraint:
	 *     (match=[DatatypeConstructor|ID] inductCase+=MatchCase inductCase+=MatchCase*)
	 */
	protected void sequence_MatchStatement(ISerializationContext context, MatchStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PolyContextTypes returns PolyContextTypes
	 *
	 * Constraint:
	 *     (name=PolymorphicTypeName constraints+=PolyTypeConstraints*)
	 */
	protected void sequence_PolyContextTypes(ISerializationContext context, PolyContextTypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PolyContext returns PolyContext
	 *
	 * Constraint:
	 *     polyTypes+=PolyContextTypes+
	 */
	protected void sequence_PolyContext(ISerializationContext context, PolyContext semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PolyTypeConstraints returns PolyTypeConstraints
	 *
	 * Constraint:
	 *     (TypeName+=[ClassDecl|QualifiedName] TypeName+=[ClassDecl|QualifiedName]*)
	 */
	protected void sequence_PolyTypeConstraints(ISerializationContext context, PolyTypeConstraints semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GenName returns PolymorphicTypeName
	 *     PolymorphicTypeName returns PolymorphicTypeName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_PolymorphicTypeName(ISerializationContext context, PolymorphicTypeName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BSharpPackage.Literals.NAMED_OBJECT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BSharpPackage.Literals.NAMED_OBJECT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPolymorphicTypeNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RootExpression returns Prefix
	 *     Prefix returns Prefix
	 *     Infix returns Prefix
	 *     Infix.Infix_1_0 returns Prefix
	 *     Element returns Prefix
	 *
	 * Constraint:
	 *     (name=PrefixBuiltIn elem=Element)
	 */
	protected void sequence_Prefix(ISerializationContext context, Prefix semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BSharpPackage.Literals.PREFIX__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BSharpPackage.Literals.PREFIX__NAME));
			if (transientValues.isValueTransient(semanticObject, BSharpPackage.Literals.PREFIX__ELEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BSharpPackage.Literals.PREFIX__ELEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrefixAccess().getNamePrefixBuiltInParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPrefixAccess().getElemElementParserRuleCall_1_0(), semanticObject.getElem());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Quantifier returns QuantLambda
	 *
	 * Constraint:
	 *     ((qType='∀' | qType='∃') context=PolyContext? varList=TypedVariableList expr=RootExpression)
	 */
	protected void sequence_Quantifier(ISerializationContext context, QuantLambda semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SuperTypeList returns SuperTypeList
	 *
	 * Constraint:
	 *     (superType+=ConstructedType superType+=ConstructedType*)
	 */
	protected void sequence_SuperTypeList(ISerializationContext context, SuperTypeList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TheoremBody returns TheoremBody
	 *
	 * Constraint:
	 *     theoremDecl+=TheoremDecl+
	 */
	protected void sequence_TheoremBody(ISerializationContext context, TheoremBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TheoremDecl returns TheoremDecl
	 *
	 * Constraint:
	 *     (name=THM_NAME expr=RootExpression)
	 */
	protected void sequence_TheoremDecl(ISerializationContext context, TheoremDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BSharpPackage.Literals.THEOREM_DECL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BSharpPackage.Literals.THEOREM_DECL__NAME));
			if (transientValues.isValueTransient(semanticObject, BSharpPackage.Literals.THEOREM_DECL__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BSharpPackage.Literals.THEOREM_DECL__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTheoremDeclAccess().getNameTHM_NAMEParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTheoremDeclAccess().getExprRootExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TopLevel returns TopLevel
	 *
	 * Constraint:
	 *     (name=ID? imports+=ImportStatement* classes+=Class*)
	 */
	protected void sequence_TopLevel(ISerializationContext context, TopLevel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeBodyElements returns TypeBodyElements
	 *
	 * Constraint:
	 *     (functions+=FunctionDecl | theorems+=TheoremBody)
	 */
	protected void sequence_TypeBodyElements(ISerializationContext context, TypeBodyElements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeConstructor returns TypeConstructor
	 *
	 * Constraint:
	 *     (TypeName=[GenName|QualifiedName] context+=TypeDeclContext?)
	 */
	protected void sequence_TypeConstructor(ISerializationContext context, TypeConstructor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDeclContext returns TypeDeclContext
	 *
	 * Constraint:
	 *     (TypeName+=ConstructedType TypeName+=ConstructedType*)
	 */
	protected void sequence_TypeDeclContext(ISerializationContext context, TypeDeclContext semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeStructure returns TypeStructure
	 *
	 * Constraint:
	 *     variables=TypedVariableList
	 */
	protected void sequence_TypeStructure(ISerializationContext context, TypeStructure semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BSharpPackage.Literals.TYPE_STRUCTURE__VARIABLES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BSharpPackage.Literals.TYPE_STRUCTURE__VARIABLES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeStructureAccess().getVariablesTypedVariableListParserRuleCall_1_0(), semanticObject.getVariables());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypedVariableList returns TypedVariableList
	 *
	 * Constraint:
	 *     (variablesOfType+=VariableTyping variablesOfType+=VariableTyping*)
	 */
	protected void sequence_TypedVariableList(ISerializationContext context, TypedVariableList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypedVariable returns TypedVariable
	 *     ExpressionVariable returns TypedVariable
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_TypedVariable(ISerializationContext context, TypedVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BSharpPackage.Literals.NAMED_OBJECT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BSharpPackage.Literals.NAMED_OBJECT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypedVariableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VariableTyping returns VariableTyping
	 *
	 * Constraint:
	 *     (typeVar+=TypedVariable typeVar+=TypedVariable* type=ConstructedType)
	 */
	protected void sequence_VariableTyping(ISerializationContext context, VariableTyping semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Where returns Where
	 *
	 * Constraint:
	 *     (expessions+=Quantifier expressions+=RootExpression*)
	 */
	protected void sequence_Where(ISerializationContext context, Where semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
