/**
 * generated by Xtext 2.13.0
 */
package ac.soton.bsharp.generator;

import ac.soton.bsharp.bSharp.ClassDecl;
import ac.soton.bsharp.bSharp.Extend;
import ac.soton.bsharp.bSharp.ImportStatement;
import ac.soton.bsharp.bSharp.TopLevel;
import ac.soton.bsharp.bSharp.TopLevelFile;
import ac.soton.bsharp.util.TheoryUtils;
import ch.ethz.eventb.utils.EventBUtils;
import com.google.common.collect.Iterables;
import java.util.ArrayList;
import java.util.Collection;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eventb.core.IEventBProject;
import org.eventb.theory.core.ITheoryRoot;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class BSharpGenerator extends AbstractGenerator {
  protected IProgressMonitor nullMonitor = new NullProgressMonitor();
  
  private String projName;
  
  private IEventBProject proj;
  
  private String fileName;
  
  private ITheoryRoot currentThy;
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    try {
      EObject _get = resource.getContents().get(0);
      final TopLevel topLevel = ((TopLevel) _get);
      String _name = topLevel.getName();
      String _plus = (_name + "-gen");
      this.projName = _plus;
      this.proj = EventBUtils.getEventBProject(this.projName);
      boolean _exists = this.proj.getRodinProject().exists();
      boolean _not = (!_exists);
      if (_not) {
        InputOutput.<String>print("start");
        this.proj = EventBUtils.createEventBProject(this.projName, this.nullMonitor);
        InputOutput.<String>print("end");
      }
      final TopLevelFile topLevelFile = topLevel.getTopLevelFile();
      this.fileName = topLevelFile.getName();
      this.currentThy = TheoryUtils.createTheory(this.proj.getRodinProject(), this.fileName, null);
      ArrayList<String> toImport = new ArrayList<String>();
      ArrayList<String> prevImports = new ArrayList<String>();
      boolean importing = true;
      boolean firstImport = true;
      ITheoryRoot lastThy = this.currentThy;
      EList<EObject> _eContents = topLevelFile.eContents();
      for (final EObject eObject : _eContents) {
        if ((eObject instanceof ImportStatement)) {
          importing = true;
          this.addToToImports(toImport, ((ImportStatement) eObject).getImports(), prevImports);
        } else {
          if (importing) {
          }
          if ((eObject instanceof ClassDecl)) {
            this.generate_ClassDecl(((ClassDecl) eObject), toImport, fsa, context);
            Iterables.<String>addAll(prevImports, toImport);
            ArrayList<String> _arrayList = new ArrayList<String>();
            toImport = _arrayList;
          } else {
            if ((eObject instanceof Extend)) {
              this.generate_Extend(((Extend) eObject), toImport, fsa, context);
              Iterables.<String>addAll(prevImports, toImport);
              ArrayList<String> _arrayList_1 = new ArrayList<String>();
              toImport = _arrayList_1;
            }
          }
        }
      }
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  /**
   * Importing in the theory plug-in we don't want to import the same file more than once so
   * we make sure we only import each file once. This doesn't check across files yet.
   */
  public void addToToImports(final ArrayList<String> toImport, final Collection<String> newImports, final ArrayList<String> allImports) {
    for (final String string : newImports) {
      if (((!allImports.contains(string)) && (!toImport.contains(string)))) {
        toImport.add(string);
      }
    }
  }
  
  public Object generate_ClassDecl(final ClassDecl classDecl, final ArrayList<String> imports, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    return null;
  }
  
  public Object generate_Extend(final Extend extend, final ArrayList<String> imports, final IFileSystemAccess2 fsa, final IGeneratorContext ctx) {
    return null;
  }
  
  public Object resolveImports(final ArrayList<String> imports, final ITheoryRoot currentThy) {
    return null;
  }
}
