/*
 * generated by Xtext 2.12.0
 */
package ac.soton.bsharp.scoping

import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.scoping.impl.ImportedNamespaceAwareLocalScopeProvider
import java.util.List
import org.eclipse.xtext.scoping.impl.ImportNormalizer
import com.google.common.collect.Lists
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.naming.IQualifiedNameProvider
import javax.inject.Inject
import ac.soton.bsharp.bSharp.TopLevel
import ac.soton.bsharp.bSharp.TopLevelImport
import org.eclipse.xtext.EcoreUtil2
import java.util.ArrayList
import ac.soton.bsharp.bSharp.FileImport
import ac.soton.bsharp.bSharp.Extend
import ac.soton.bsharp.bSharp.ClassDecl
import ac.soton.bsharp.bSharp.BSClass
import ac.soton.bsharp.bSharp.TopLevelInstance
import ac.soton.bsharp.util.EcoreUtilJ
import ac.soton.bsharp.bSharp.LocalImport
import ac.soton.bsharp.bSharp.GlobalImport
import ac.soton.bsharp.bSharp.BSharpBlock

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class BSharpImportedNamespaceAwareLocalScopeProvider extends ImportedNamespaceAwareLocalScopeProvider {
	@Inject extension IQualifiedNameProvider
	
	override internalGetImportedNamespaceResolvers(EObject context, boolean ignoreCase) {
		/* I need to override this method because getImportedNamespace returns a single object 
		 * and I need to return a list.
		 */
		 
		var List<ImportNormalizer> importedNamespaceResolvers = Lists.newArrayList()
		
		if (context instanceof BSharpBlock) {
			val topLevelInst = context.eContainer
			var List<String> importStrings
			if (topLevelInst instanceof Extend) {
				importStrings = extendStringsForClass((topLevelInst as Extend).extendedClass, context)
			} else {
				importStrings = extendStringsForClass((topLevelInst as ClassDecl), context)
			}
			
			for (importString : importStrings) {
				val resolver = createImportedNamespaceResolver(importString, ignoreCase)
				
				if (resolver !== null)
					importedNamespaceResolvers += resolver
			}
		} else if (context instanceof TopLevelImport) {
			/* Add the package to the fully qualified domain names */
			importedFiles = new ArrayList()
			var topLevelImport = context as TopLevelImport
			val topLevel = EcoreUtil2.getContainerOfType(topLevelImport, TopLevel)
			val packageName = topLevel.fullyQualifiedName
			
			/* Note that we know that the iterator contains at least one element as we only
			 * enter here it there is a TopLevelImport.
			 */
			val importBlocks = topLevel.topLevelFile.topLevelImports
			val iterator = importBlocks.iterator
			var TopLevelImport current
			
			do {
				current = iterator.next
				addImportsForTopLevelImport(current, importedNamespaceResolvers, packageName, ignoreCase)
			} while (current != context)
			
		}

		return importedNamespaceResolvers
	}
	
	def addImportsForTopLevelImport(TopLevelImport topLevel, List<ImportNormalizer> importedNamespaceResolvers,
		QualifiedName packageName, Boolean ignoreCase) {
			val localImports = topLevel.localImports
			val globalImports = topLevel.globalImports

			if (localImports !== null) {
				for (localImport : localImports) {
					for (import : localImport.fileImports) {
						importFileImportForPackage(packageName.toString, import, importedNamespaceResolvers, ignoreCase)
					}
				}
			}
		
			if (globalImports !== null) {
				for (globalImport : globalImports) {
					val projName = globalImport.project
					
					/* I don't currently handle globalproj.* as I'd need to work out
					 * how to iterate over all the files in the global proj.
					 */
					for (fileImport : globalImport.fileImports) {
						importFileImportForPackage(projName, fileImport, importedNamespaceResolvers, ignoreCase)
					}
				}
			}
	}
	
	def extendStringsForClass(ClassDecl classDecl, EObject context) {
		generateAllFileImportStrings(context)
		var ArrayList<String> importStrings = new ArrayList
		extendStringsForClassInternal(classDecl, importStrings)
		fileImportStrings = null
		return importStrings
	}
	
	def void extendStringsForClassInternal(ClassDecl classDecl, ArrayList<String> result) {
		
		for (fileString : fileImportStrings) {
			if (fileString.endsWith(".*")) {
				val len = fileString.length
				var resString = fileString.substring(0, len - 1)
				resString += classDecl.name + ".Extend.*"
				result += resString
			}
		}
		
		if (classDecl instanceof BSClass) {
			val supertypeList = (classDecl as BSClass).supertypes
			val supertypes = supertypeList.superTypes
			
			for (supertype : supertypes) {
				var ClassDecl superT = supertype.typeClass
				if (superT === null)
					superT = supertype.getDatatype()
				
				if (superT !== null)
					extendStringsForClassInternal(superT, result)
			}
		}
	}
	
	var ArrayList<String> fileImportStrings;
	
	def void generateAllFileImportStrings(EObject currentObj) {
		fileImportStrings = new ArrayList()
		
		val topLevel = EcoreUtil2.getContainerOfType(currentObj, TopLevel)
		val packageName = topLevel.fullyQualifiedName
		val List<LocalImport> localImports = EcoreUtilJ.eFilterUpToIncludingCurrentWith(currentObj, [obj | obj instanceof LocalImport]) as List<LocalImport>
		val List<GlobalImport> globalImports = EcoreUtilJ.eFilterUpToIncludingCurrentWith(currentObj, [obj | obj instanceof GlobalImport]) as List<GlobalImport>
		
		if (localImports !== null) {
			for (localImport : localImports) {
				for (import : localImport.fileImports) {
					fileImportStrings += stringForPackageFileImport(packageName.toString, import)
				}
			}
		}
		
		if (globalImports !== null) {
			for (globalImport : globalImports) {
				val projName = globalImport.project
				
				for (fileImport : globalImport.fileImports) {
					fileImportStrings += stringForPackageFileImport(projName, fileImport)
				}
			}
		}
	}
	
	def String stringForPackageFileImport(String pack, FileImport fileImport) {
		var importFileName = fileImport.fileName
		var importString = pack + "." + importFileName + "."
		
		if (fileImport.type !== null) {
			importString += fileImport.type
		} else {
			importString += "*"
		}
		
		return importString
	}
	
	def importFileImportForPackage(
		String pack,
		FileImport fileImport,
		List<ImportNormalizer> importedNamespaceResolvers,
		Boolean ignoreCase) {
			
		addFileImport(pack, fileImport.fileName, importedNamespaceResolvers, ignoreCase)

		var importfileName = fileImport.fileName
		addFileImport(pack, importfileName, importedNamespaceResolvers, ignoreCase)
		var importString = pack + '.' + importfileName + '.'
		if (fileImport.type !== null) {
			importString += fileImport.type
		} else {
			importString += '*'
		}

		val resolver = createImportedNamespaceResolver(importString, ignoreCase)

		if (resolver !== null)
			importedNamespaceResolvers += resolver
	}
	
	protected static var ArrayList<String> importedFiles = null
	
	def addFileImport(String pack, String fileName, List<ImportNormalizer> importedNamespaceResolvers, 
		Boolean ignoreCase
	) {
		val importName = pack + "." + fileName
		if (importedFiles.contains(importName)) {
			return
		}
		
		importedFiles += importName
		
		val resolver = createImportedNamespaceResolver(importName, ignoreCase)
		if (resolver !== null) {
			importedNamespaceResolvers += resolver
		}
	}
	
	override getImplicitImports(boolean ignoreCase) {
		newArrayList(new ImportNormalizer(QualifiedName.create("ac", "soton", "bsharp", "main"), true, ignoreCase))
	}
}
