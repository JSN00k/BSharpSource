/*
 * generated by Xtext 2.12.0
 */
package ac.soton.bsharp.scoping

import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.Scopes
import ac.soton.bsharp.bSharp.PolymorphicTypeName
import org.eclipse.xtext.EcoreUtil2
import ac.soton.bsharp.bSharp.TypeName
import ac.soton.bsharp.bSharp.GenName
import ac.soton.bsharp.bSharp.BSharpPackage
import java.util.ArrayList
import ac.soton.bsharp.bSharp.ClassDecl
import ac.soton.bsharp.bSharp.FunctionName
import org.eclipse.xtext.scoping.IScope
import ac.soton.bsharp.bSharp.Extend
import ac.soton.bsharp.bSharp.TypeConstructor
import ac.soton.bsharp.bSharp.Datatype
import java.util.Collection
import ac.soton.bsharp.EcoreUtilJ
import ac.soton.bsharp.bSharp.MatchCase
import ac.soton.bsharp.bSharp.MatchStatement
import ac.soton.bsharp.bSharp.IVariableProvider
import ac.soton.bsharp.bSharp.IPolyTypeProvider
import org.eclipse.xtext.scoping.impl.ImportedNamespaceAwareLocalScopeProvider
import org.eclipse.emf.ecore.EStructuralFeature

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class BSharpImportedNamespaceAwareLocalScopeProvider extends ImportedNamespaceAwareLocalScopeProvider {
	
	//override getImportedNameSpace
	
	override getLocalElementsScope(IScope parent, EObject context, EReference reference) {		
		/* This doesn't work, I believe that the issue is that  */
		if (context instanceof TypeConstructor && reference.getEReferenceType() == BSharpPackage.Literals.GEN_NAME) {
			/* Get scope for the class, and use it to check for polymorphic variable. Care needs to 
			 * be taken here  as this is not complete, and will need to be added to when declaring 
			 * functions and methods. */
			var classDecl = EcoreUtil2.getContainerOfType(context, ClassDecl)
			if (classDecl === null) {
				val extend = EcoreUtil2.getContainerOfType(context, Extend)
				if (extend !== null) {
					classDecl = extend.name.eContainer as ClassDecl
				}
			}
			
			if (classDecl !== null) {
				val finalClassDecl = classDecl
				val allElems = new ArrayList<GenName>()
				if (classDecl.context !== null) {
					allElems.addAll(EcoreUtil2.getAllContentsOfType(classDecl.context, PolymorphicTypeName))
				 }

				/* TODO: Turn this into a look up that includes imports */
				val rootElement = EcoreUtil2.getRootContainer(context)
				/* Predictably The Class elements returned from the statement above are in the
				 * order in which they appear in the file. I can therefore simply remove any elements
				 * from the returned list that appear after the current ndx.
				 */
				 
				 if (classDecl instanceof Datatype) {
				   allElems.addAll(EcoreUtilJ.eFilterUpToIncludingWith(rootElement, [object | object==finalClassDecl],
					[object | object instanceof TypeName]) as Collection<TypeName>)
				} else {
					allElems.addAll(EcoreUtilJ.eFilterUpToWith(rootElement, [object | object==finalClassDecl],
					[object | object instanceof TypeName]) as Collection<TypeName>)
				}

				val scope = Scopes.scopeFor(allElems, parent)
				
				return scope
			}
		} else if (reference.getEReferenceType == BSharpPackage.Literals.TYPE_NAME) {
			/* Only allow type names above the current typename
			 * TODO: Need to include global imports.
			 */
			 
			 val rootObj = EcoreUtil2.getRootContainer(context)
			 var typeNames = EcoreUtilJ.eFilterUpToIncludingWith(rootObj, [object | object == context], [object | object instanceof TypeName])
			 return Scopes.scopeFor(typeNames, parent)
		} else if (reference.getEReferenceType == BSharpPackage.Literals.EXPRESSION_VARIABLE) {
			/* Here's the definition:
			 * ExpressionVariable:
			 *	 FunctionName | TypedVariable | TypeName
			 *  ;
			 * 
			 * I can use scoping to check for obvious mistakes in these references. However, believe that I 
			 * will need to use validation to do the more complicated type checking. Currently this only checks
			 * that the names are available to me.
			 */
			 
			 /* If this becomes to computationally expensive it is possible to do this in a 
			  * single iteration of the tree, however it's harder to write the code, so first 
			  * attempt users multiple iterations.
			  * 
			  * TODO: Global scope it all!
			  */
			 val rootObj = EcoreUtil2.getRootContainer(context)
			 val currentClass = EcoreUtil2.getContainerOfType(context, ClassDecl)
			 
			 /* FunctionName can be any function within the current body, or any body above. 
			  */
			 var functionNames = EcoreUtilJ.eFilterUpToIncludingWith(rootObj, [object | object == currentClass], [object | object instanceof FunctionName])
			 
			 /* TypedVariableScope */
			 var scope = getVariableScopeFor(context, parent)
			 
			 if (scope !== null)
			 	return Scopes.scopeFor(functionNames, scope)
			 else
			 	return Scopes.scopeFor(functionNames, parent)
		} else if (reference.getEReferenceType() == BSharpPackage.Literals.TYPED_VARIABLE && context instanceof MatchCase){
			/* Assumes we're in a function declaration, as there isn't anywhere else for a match statement
			 * yet. */
			val datatype = EcoreUtil2.getContainerOfType((context.eContainer as MatchStatement).match, Datatype)
			
			if (datatype !== null) {
				val allResults = new ArrayList<EObject>
				
				//datatype.varList.forEach[obj | allResults.addAll(EcoreUtil2.getAllContentsOfType(obj, TypedVariable))]
				return Scopes.scopeFor(allResults, parent)
			}
		} else if (reference == BSharpPackage.Literals.MATCH_CASE) {
			print (reference)
		}
		
		return super.getLocalElementsScope(parent, context, reference)
	}
	
	
	override getImportedNamespaceResolvers(EObject context, boolean ignoreCase) {
		
	}
	
	/* This method is overridden as imports are only from files imported above the
	 * current location where this code is declared.
	 */
	override getImportedNamespace(EObject object) {
		val feature = object.eClass().getEStructuralFeature("imports");
		if (feature !== null && String.equals(feature.getEType().getInstanceClass())) {
			return object.eGet(feature) as String;
		}
		return null;
	}
	
	def IScope getVariableScopeFor(EObject context, IScope parent) {
		val polyProvider = EcoreUtilJ.eContainerMatchingLambda(context, [obj | obj instanceof IVariableProvider]) as IVariableProvider
		
		if (polyProvider === null) {
			return null
		}
		
		val parentScope = getVariableScopeFor(polyProvider as EObject, parent)
		
		if (polyProvider.variablesNames === null) {
			return parentScope;
		}
		
		if (parentScope === null) {
			return Scopes.scopeFor(polyProvider.variablesNames)
		} else {
			return Scopes.scopeFor(polyProvider.variablesNames, parentScope)
		}
		
	}
	
	def IScope getTypeScope(EObject context) {
		/* This is called when a GenName is referenced (GenName: PolymorphicTypeName | TypeName;)
		 * Basically a type has been scanned. In this case we need to check all valid polymorphic 
		 * types (these go backwards up the scope hierarchy), and types previously declared in the file
		 * and previously imported files.
		 */
		 
	}
	
	def IScope getPolyScopeFor(EObject context, IScope parent) {
		val variableProvider = EcoreUtilJ.eContainerMatchingLambda(context, [obj | obj instanceof IVariableProvider]) as IPolyTypeProvider
		
		if (variableProvider === null) {
			return null
		}
		
		val parentScope = getVariableScopeFor(variableProvider as EObject, parent)
		
		if (parentScope === null) {
			return Scopes.scopeFor(variableProvider.polyTypeNames)
		} else {
			return Scopes.scopeFor(variableProvider.polyTypeNames, parentScope)
		}
		
	}
}
