/*
 * generated by Xtext 2.14.0
 */
package ac.soton.bsharp.scoping

import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import ac.soton.bsharp.bSharp.TypeConstructor
import ac.soton.bsharp.bSharp.BSharpPackage
import ac.soton.bsharp.bSharp.ClassDecl
import org.eclipse.xtext.EcoreUtil2
import ac.soton.bsharp.bSharp.Extend
import java.util.ArrayList
import ac.soton.bsharp.bSharp.GenName
import ac.soton.bsharp.bSharp.PolymorphicTypeName
import ac.soton.bsharp.bSharp.Datatype
import ac.soton.bsharp.EcoreUtilJ
import java.util.Collection
import org.eclipse.xtext.scoping.Scopes
import ac.soton.bsharp.bSharp.FunctionName
import ac.soton.bsharp.bSharp.MatchCase
import ac.soton.bsharp.bSharp.MatchStatement
import ac.soton.bsharp.bSharp.IVariableProvider
import ac.soton.bsharp.bSharp.IPolyTypeProvider

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class BSharpScopeProvider extends AbstractBSharpScopeProvider {

	override IScope getScope(EObject context, EReference reference) {
		val parent = super.getScope(context, reference)
		print(parent)
		if (context instanceof TypeConstructor && reference.getEReferenceType() == BSharpPackage.Literals.GEN_NAME) {
			/* Get scope for the class, and use it to check for polymorphic variable. Care needs to 
			 * be taken here  as this is not complete, and will need to be added to when declaring 
			 * functions and methods. */
			var classDecl = EcoreUtil2.getContainerOfType(context, ClassDecl)
			if (classDecl === null) {
				val extend = EcoreUtil2.getContainerOfType(context, Extend)
				if (extend !== null) {
					classDecl = extend.name as ClassDecl
				}
			}
			
			if (classDecl !== null) {
				val finalClassDecl = classDecl
				val allElems = new ArrayList<GenName>()
				if (classDecl.context !== null) {
					allElems.addAll(EcoreUtil2.getAllContentsOfType(classDecl.context, PolymorphicTypeName))
				 }

				/* TODO: Turn this into a look up that includes imports */
				val rootElement = EcoreUtil2.getRootContainer(context)
				/* Predictably The Class elements returned from the statement above are in the
				 * order in which they appear in the file. I can therefore simply remove any elements
				 * from the returned list that appear after the current ndx.
				 */
				 
				 if (classDecl instanceof Datatype) {
				   allElems.addAll(EcoreUtilJ.eFilterUpToIncludingWith(rootElement, [object | object==finalClassDecl],
					[object | object instanceof ClassDecl]) as Collection<ClassDecl>)
				} else {
					allElems.addAll(EcoreUtilJ.eFilterUpToWith(rootElement, [object | object==finalClassDecl],
					[object | object instanceof ClassDecl]) as Collection<ClassDecl>)
				}

				val scope = Scopes.scopeFor(allElems, parent)
				
				return scope
			}
		} else if (reference.getEReferenceType == BSharpPackage.Literals.CLASS_DECL) {
			/* Only allow type names above the current typename
			 * TODO: Need to include global imports.
			 */
			 
			 val rootObj = EcoreUtil2.getRootContainer(context)
			 var typeNames = EcoreUtilJ.eFilterUpToIncludingWith(rootObj, [object | object == context], [object | object instanceof ClassDecl])
			 return Scopes.scopeFor(typeNames, parent)
		} else if (reference.getEReferenceType == BSharpPackage.Literals.EXPRESSION_VARIABLE) {
			/* Here's the definition:
			 * ExpressionVariable:
			 *	 FunctionName | TypedVariable | ClassDecl
			 *  ;
			 * 
			 * I can use scoping to check for obvious mistakes in these references. However, believe that I 
			 * will need to use validation to do the more complicated type checking. Currently this only checks
			 * that the names are available to me.
			 */
			 
			 /* If this becomes to computationally expensive it is possible to do this in a 
			  * single iteration of the tree, however it's harder to write the code, so first 
			  * attempt users multiple iterations.
			  * 
			  * TODO: Global scope it all!
			  */
			 val rootObj = EcoreUtil2.getRootContainer(context)
			 val currentClass = EcoreUtil2.getContainerOfType(context, ClassDecl)
			 
			 /* FunctionName can be any function within the current body, or any body above. 
			  */
			 var functionNames = EcoreUtilJ.eFilterUpToIncludingWith(rootObj, [object | object == currentClass], [object | object instanceof FunctionName])
			 
			 /* TypedVariableScope */
			 var scope = getVariableScopeFor(context, IScope.NULLSCOPE)
			 
			 if (scope !== null)
			 	return Scopes.scopeFor(functionNames, scope)
			 else
			 	return Scopes.scopeFor(functionNames)
		} else if (reference.getEReferenceType() == BSharpPackage.Literals.TYPED_VARIABLE && context instanceof MatchCase){
			/* Assumes we're in a function declaration, as there isn't anywhere else for a match statement
			 * yet. */
			val datatype = EcoreUtil2.getContainerOfType((context.eContainer as MatchStatement).match, Datatype)
			
			if (datatype !== null) {
				val allResults = new ArrayList<EObject>
				
				//datatype.varList.forEach[obj | allResults.addAll(EcoreUtil2.getAllContentsOfType(obj, TypedVariable))]
				return Scopes.scopeFor(allResults, parent)
			}
		} else if (reference == BSharpPackage.Literals.MATCH_CASE) {
			print(reference)
			return parent
		}
		
		return parent
	}
	
	
		def IScope getVariableScopeFor(EObject context, IScope parent) {
		val variableProvider = EcoreUtilJ.eContainerMatchingLambda(context, [obj | obj instanceof IVariableProvider]) as IVariableProvider
		
		if (variableProvider === null) {
			return null
		}
		
		val parentScope = getVariableScopeFor(variableProvider as EObject, parent)
		
		if (variableProvider.variablesNames === null) {
			return parentScope;
		}
		
		if (parentScope === null) {
			return Scopes.scopeFor(variableProvider.variablesNames)
		} else {
			return Scopes.scopeFor(variableProvider.variablesNames, parentScope)
		}
		
	}
	
	def IScope getPolyScopeFor(EObject context, IScope parent) {
		val variableProvider = EcoreUtilJ.eContainerMatchingLambda(context, [obj | obj instanceof IVariableProvider]) as IPolyTypeProvider
		
		if (variableProvider === null) {
			return null
		}
		
		val parentScope = getVariableScopeFor(variableProvider as EObject, parent)
		
		if (parentScope === null) {
			return Scopes.scopeFor(variableProvider.polyTypeNames)
		} else {
			return Scopes.scopeFor(variableProvider.polyTypeNames, parentScope)
		}
		
	}
}
