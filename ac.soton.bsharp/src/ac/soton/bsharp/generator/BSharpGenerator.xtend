/*
 * generated by Xtext 2.13.0
 */
package ac.soton.bsharp.generator

import ac.soton.bsharp.bSharp.GlobalImport
import ac.soton.bsharp.bSharp.LocalImport
import ac.soton.bsharp.bSharp.TopLevel
import ac.soton.bsharp.bSharp.TopLevelFile
import ac.soton.bsharp.theory.util.TheoryUtils
import ch.ethz.eventb.utils.EventBUtils
import java.util.ArrayList
import org.eclipse.core.runtime.IProgressMonitor
import org.eclipse.core.runtime.NullProgressMonitor
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.rodinp.core.IRodinProject
import ac.soton.bsharp.theory.util.TheoryImportCache
import java.util.List
import ac.soton.bsharp.bSharp.util.CompilationUtil
import org.eclipse.emf.ecore.EObject
import ac.soton.bsharp.bSharp.TopLevelInstance
import org.eclipse.emf.common.util.EList

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class BSharpGenerator extends AbstractGenerator {
	
	protected IProgressMonitor nullMonitor = new NullProgressMonitor();
	
	var String projName
	var IRodinProject proj
	var String fileName
	
	/* An array of arrays, each Array contains the elements that need to be compiled for the current import block */
	var ArrayList<EList<TopLevelInstance>> elementsForImport

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		/* When we come into this we're expecting the resource to be at the very top level
		 * This is above the TopLevel, we can get the TopLevel item using resource.contents[0].
		 * To handle imports it is quite nice to iterate over the TopLevel in declaration order
		 * rather than using .imports, .classes etc. 
		 */
		
		val topLevel = resource.contents.get(0) as TopLevel
		projName = topLevel.name + "-gen"
		elementsForImport = newArrayList
		
		var eventBproj = EventBUtils.getEventBProject(projName)
		if (!eventBproj.rodinProject.exists) {
			eventBproj = EventBUtils.createEventBProject(projName, nullMonitor)
		}
		
		proj = eventBproj.rodinProject
		
		/* The top level just contains the package name and a topLevelFile, this
		 * contains the file name and the rest of the emf tree 
		 * (ClassDecl | Extend) which is then iterated over
		 */
		val topLevelFile = topLevel.topLevelFile
		fileName = topLevelFile.name
		
		/* Generates all of the theories that this file will need and imports
		 * as many files as possible.
		 */
		generateTheories(topLevelFile)
		
		for (importElems : elementsForImport) {
			val fileCompiler = new FileCompiler(importElems)
			fileCompiler.compile
			CompilationUtil.getTheoryCacheForElement(importElems.get(0)).save();
		}
		
	}
	
	/* Builds the skeleton for the thy files represented by the BSharp file EMF in top, handles full
	 * file imports, and populates */
	def generateTheories(TopLevelFile top) {
		/* The final thy generated is the one that shares it's name with the BSharp files
		 * previous generated thys have the same name have an increasing integer appended.
		 * These are all put into an array for easy access */
		 val imports = top.topLevelImports
		 
		 if (imports === null || imports.length == 0) {
		 	/* There is only a top level file */
		 	val thy = TheoryUtils.createTheory(proj, fileName, null)
		 	val theoryCache = new TheoryImportCache(thy, projName, null)
		 	top.theoryImportCache = theoryCache
		 	
		 	if (top.noImportElements !== null && !top.noImportElements.isEmpty) {
		 		elementsForImport += top.noImportElements
		 	}
		 	
		 	return
		 }
		 
		 var adder = 0
		 var TheoryImportCache prevTheoryCache
		 
		 if (top.getNoImportElements() !== null && !top.noImportElements.isEmpty) {
		 	val thy = TheoryUtils.createTheory(proj, fileName + Integer.toString(0), null)
		 	val theoryCache = new TheoryImportCache(thy, projName, null)
		 	top.theoryImportCache = theoryCache
		 	elementsForImport += top.noImportElements
		 	top.theoryImportCache = theoryCache
		 	prevTheoryCache = theoryCache
		 	adder++
		 }
		 
		 val importLen = imports.length
		 
		 for (i : 0 ..< importLen - 1) {
		 	val topLevelImport = imports.get(i)
		 	val thy = TheoryUtils.createTheory(proj, fileName + Integer.toString(i + adder), null)
		 	
		 	/* prevTheoryCache can be null without causing an issue. */
		 	val theoryCache = new TheoryImportCache(thy, projName, prevTheoryCache)
		 	if (topLevelImport.localImports !== null) {
		 		importLocalImports(topLevelImport.localImports, theoryCache, topLevelImport)
		 	}
		 	
		 	if (topLevelImport.globalImports !== null) {
		 		importGlobalImports(topLevelImport.globalImports, theoryCache, topLevelImport)
		 	}
		 	
		 	topLevelImport.theoryImportCache = theoryCache
		 	elementsForImport += topLevelImport.bodyElements
		 	prevTheoryCache = theoryCache
		 }
		 
		 val topLevelImport = imports.last
		 val thy = TheoryUtils.createTheory(proj, fileName, null)
		 val theoryCache = new TheoryImportCache(thy, projName, prevTheoryCache)
		 if (topLevelImport.localImports !== null) {
		 	importLocalImports(topLevelImport.localImports, theoryCache, topLevelImport)
		 }
		 	
		 if (topLevelImport.globalImports !== null) {
		 	importGlobalImports(topLevelImport.globalImports, theoryCache, topLevelImport)
		 }
		 
		 topLevelImport.theoryImportCache = theoryCache
		 elementsForImport += imports.last.bodyElements
	}
	
	
	def importLocalImports(List<LocalImport> importBlock, TheoryImportCache theoryCache, EObject tree) {
		for (localImport : importBlock) {
			for (fileImport : localImport.fileImports) {
				if (fileImport.type === null) {
					theoryCache.importLocalTheoryWithName(fileImport.fileName)
				} else {
					theoryCache.importTheoryForTypeNameInTree(fileImport.type, tree)
				}
			}
		}
	}
	
	def importGlobalImports(List<GlobalImport> importBlock, TheoryImportCache theoryCache, EObject tree) {
		for (globalImport : importBlock){
			val projectName = globalImport.project
			for (fileImport : globalImport.fileImports) {
				if (fileImport.type === null) {
					theoryCache.importTheoryWithNameFromProjectWithName(fileImport.fileName, projectName)
				} else {
					theoryCache.importTheoryForTypeNameInTree(fileImport.type, tree)
				}
			}
		}
	}
}