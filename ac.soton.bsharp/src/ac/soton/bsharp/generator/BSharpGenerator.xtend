/*
 * generated by Xtext 2.13.0
 */
package ac.soton.bsharp.generator

import ac.soton.bsharp.bSharp.GlobalImport
import ac.soton.bsharp.bSharp.LocalImport
import ac.soton.bsharp.bSharp.TopLevel
import ac.soton.bsharp.bSharp.TopLevelFile
import ac.soton.bsharp.theory.util.TheoryUtils
import ch.ethz.eventb.utils.EventBUtils
import java.util.ArrayList
import org.eclipse.core.runtime.IProgressMonitor
import org.eclipse.core.runtime.NullProgressMonitor
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.rodinp.core.IRodinProject
import ac.soton.bsharp.theory.util.TheoryImportCache
import java.util.List
import ac.soton.bsharp.bSharp.BodyElements
import ac.soton.bsharp.bSharp.util.CompilationUtil

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class BSharpGenerator extends AbstractGenerator {
	
	protected IProgressMonitor nullMonitor = new NullProgressMonitor();
	
	var String projName
	var IRodinProject proj
	var String fileName
	
	var ArrayList<BodyElements> mainElements
	
	/* When a type in imported explicitly it is possible that a smaller part
	 * of the file is imported. This is resolved when the type is referenced
	 * as this gives access to the EMF that is being referenced so it is possible
	 * to work out where the files splits.
	 */
	var ArrayList<String> explicitTypeImports

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		/* When we come into this we're expecting the resource to be at the very top level
		 * This is above the TopLevel, we can get the TopLevel item using resource.contents[0].
		 * To handle imports it is quite nice to iterate over the TopLevel in declaration order
		 * rather than using .imports, .classes etc. 
		 */
		
		val topLevel = resource.contents.get(0) as TopLevel
		projName = topLevel.name + "-gen"
		explicitTypeImports = new ArrayList
		mainElements = newArrayList
		
		var eventBproj = EventBUtils.getEventBProject(projName)
		if (!eventBproj.rodinProject.exists) {
			eventBproj = EventBUtils.createEventBProject(projName, nullMonitor)
		}
		
		proj = eventBproj.rodinProject
		
		/* The top level just contains the package name and a topLevelFile, this
		 * contains the file name and the rest of the emf tree 
		 * (ClassDecl | Extend) which is then iterated over
		 */
		val topLevelFile = topLevel.topLevelFile
		fileName = topLevelFile.name
		
		/* Generates all of the theories that this file will need and imports
		 * as many files as possible.
		 */
		generateTheories(topLevelFile)
		
		for (bodyElements : mainElements) {
			val fileCompiler = new FileCompiler(bodyElements)
			fileCompiler.compile
			CompilationUtil.getTheoryCacheForElement(bodyElements).save();
		}
		
	}
	
	/* Builds the skeleton for the thy files represented by the BSharp file EMF in top, handles full
	 * file imports, and populates */
	def generateTheories(TopLevelFile top) {
		/* The final thy generated is the one that shares it's name with the BSharp files
		 * previous generated thys have the same name have an increasing integer appended.
		 * These are all put into an array for easy access */
		 val imports = top.topLevelImports
		 
		 if (imports === null || imports.length == 0) {
		 	/* There is only a top level file */
		 	val thy = TheoryUtils.createTheory(proj, fileName, null)
		 	val theoryCache = new TheoryImportCache(thy, projName, null)
		 	top.theoryImportCache = theoryCache
		 	
		 	if (top.noImportElements !== null) {
		 		mainElements += top.noImportElements
		 	}
		 	
		 	return
		 }
		 
		 var adder = 0
		 var TheoryImportCache prevTheoryCache
		 
		 if (top.getNoImportElements() !== null) {
		 	val thy = TheoryUtils.createTheory(proj, fileName + Integer.toString(0), null)
		 	val theoryCache = new TheoryImportCache(thy, projName, null)
		 	top.theoryImportCache = theoryCache
		 	mainElements += top.noImportElements
		 	top.theoryImportCache = theoryCache
		 	prevTheoryCache = theoryCache
		 	adder++
		 }
		 
		 val importLen = imports.length
		 
		 for (i : 0 ..< importLen - 1) {
		 	val topLevelImport = imports.get(i)
		 	val thy = TheoryUtils.createTheory(proj, fileName + Integer.toString(i + adder), null)
		 	
		 	/* prevTheoryCache can be null without causing an issue. */
		 	val theoryCache = new TheoryImportCache(thy, projName, prevTheoryCache)
		 	if (topLevelImport.localImports !== null) {
		 		importLocalImports(topLevelImport.localImports, theoryCache)
		 	}
		 	
		 	if (topLevelImport.globalImports !== null) {
		 		importGlobalImports(topLevelImport.globalImports, theoryCache)
		 	}
		 	
		 	topLevelImport.theoryImportCache = theoryCache
		 	mainElements += topLevelImport.bodyElements
		 	prevTheoryCache = theoryCache
		 }
		 
		 val topLevelImport = imports.last
		 val thy = TheoryUtils.createTheory(proj, fileName, null)
		 val theoryCache = new TheoryImportCache(thy, projName, prevTheoryCache)
		 if (topLevelImport.localImports !== null) {
		 	importLocalImports(topLevelImport.localImports, theoryCache)
		 }
		 	
		 if (topLevelImport.globalImports !== null) {
		 	importGlobalImports(topLevelImport.globalImports, theoryCache)
		 }
		 
		 topLevelImport.theoryImportCache = theoryCache
		 mainElements += imports.last.bodyElements
	}
	
	
	def importLocalImports(List<LocalImport> importBlock, TheoryImportCache theoryCache) {
		for (localImport : importBlock) {
			for (fileImport : localImport.fileImports) {
				if (fileImport.type === null) {
					theoryCache.importLocalTheoryWithName(fileImport.fileName)
				} else {
					explicitTypeImports += fileImport.type
				}
			}
		}
	}
	
	def importGlobalImports(List<GlobalImport> importBlock, TheoryImportCache theoryCache) {
		for (globalImport : importBlock){
			val projectName = globalImport.project
			for (fileImport : globalImport.fileImports) {
				if (fileImport.type === null) {
					theoryCache.importTheoryWithNameFromProjectWithName(fileImport.fileName, projectName)
				} else {
					explicitTypeImports += fileImport.type
				}
			}
		}
	}
}