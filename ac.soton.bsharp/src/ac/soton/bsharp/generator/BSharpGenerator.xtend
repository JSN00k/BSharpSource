/*
 * generated by Xtext 2.13.0
 */
package ac.soton.bsharp.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import java.util.ArrayList
import ac.soton.bsharp.bSharp.TopLevel
import java.util.Collection
import ac.soton.bsharp.bSharp.ClassDecl
import ac.soton.bsharp.bSharp.Extend
import org.eventb.core.IEventBProject
import ch.ethz.eventb.utils.EventBUtils
import ac.soton.bsharp.util.TheoryUtils
import org.eventb.theory.core.ITheoryRoot
import org.eclipse.core.runtime.NullProgressMonitor
import org.eclipse.core.runtime.IProgressMonitor
import ac.soton.bsharp.bSharp.GlobalImport
import ac.soton.bsharp.bSharp.LocalImport
import java.util.HashMap
import org.rodinp.core.IRodinProject
import ac.soton.bsharp.bSharp.TopLevelFile
import org.eventb.theory.core.IImportTheoryProject
import java.util.Map

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class BSharpGenerator extends AbstractGenerator {
	
	protected IProgressMonitor nullMonitor = new NullProgressMonitor();
	
	var String projName
	var IRodinProject proj
	var String fileName
	var ITheoryRoot currentThy
	var ArrayList<ITheoryRoot> theories
	
	/* When a type in imported explicitly it is possible that a smaller part
	 * of the file is imported. This is resolved when the type is referenced
	 * as this gives access to the EMF that is being referenced so it is possible
	 * to work out where the files splits.
	 */
	var ArrayList<HashMap<String, Boolean>> explicitTypeImports

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		/* When we come into this we're expecting the resource to be at the very top level
		 * This is above the TopLevel, we can get the TopLevel item using resource.contents[0].
		 * To handle imports it is quite nice to iterate over the TopLevel in declaration order
		 * rather than using .imports, .classes etc. 
		 */
		
		val topLevel = resource.contents.get(0) as TopLevel
		projName = topLevel.name + "-gen"
		explicitTypeImports = new ArrayList
		theories = new ArrayList
		
		var eventBproj = EventBUtils.getEventBProject(projName)
		if (!eventBproj.rodinProject.exists) {
			print("start")
			eventBproj = EventBUtils.createEventBProject(projName, nullMonitor)
			print("end")
		}
		
		proj = eventBproj.rodinProject
		
		/* The top level just contains the package name and a topLevelFile, this
		 * contains the file name and the rest of the emf tree 
		 * (ClassDecl | Extend) which is then iterated over
		 */
		val topLevelFile = topLevel.topLevelFile
		fileName = topLevelFile.name
		
		generateTheories(topLevelFile)
		
		//currentThy = 
		
		/* The strategy for importing is to import any imports declared directly before 
		 * a Class, Datatype, or Extend declaration (if they've not already been imported,
		 * and to import the previous Class/Datatype/Extend generated file. */
		var ArrayList<String> toImport = new ArrayList
		
		/* A list of all the classes that have already been imported by the current 
		 * file. This is used to check against when writing the toImport
		 */
		var ArrayList<String> prevImports = new ArrayList
		
		var importing = true
		var firstImport = true
		var ITheoryRoot lastThy = currentThy
		
		for (eObject : topLevelFile.eContents) {
			if (eObject instanceof GlobalImport || eObject instanceof LocalImport) {
				importing = true
				//addToToImports(toImport, (eObject as GlobalImport)., prevImports)	
			} else {
				if (importing) {
					
				}
				
				if (eObject instanceof ClassDecl) {

					generate_ClassDecl((eObject as ClassDecl), toImport, fsa, context)
					/* Clear out the current imports as we only want to import each thing once.*/
					prevImports += toImport
					toImport = new ArrayList
				/* I need to add the file that I just created to the toImport list */
				} else if (eObject instanceof Extend) {
					generate_Extend((eObject as Extend), toImport, fsa, context)
					prevImports += toImport
					toImport = new ArrayList

				/* I need to add the file that I just created to the toImport list */
				}
			}
		}
	}
	
	/* Importing in the theory plug-in we don't want to import the same file more than once so
	 * we make sure we only import each file once. This doesn't check across files yet.
	 */
	def addToToImports(ArrayList<String> toImport, Collection<String> newImports, ArrayList<String> allImports) {
		for (string : newImports) {
			if (!allImports.contains(string) && !toImport.contains(string))
				toImport.add(string)
		}
	}
	
	def generate_ClassDecl(ClassDecl classDecl, ArrayList<String> imports, 
		IFileSystemAccess2 fsa, IGeneratorContext context) {
		
	}
	
	def generate_Extend(Extend extend, ArrayList<String> imports, IFileSystemAccess2 fsa, IGeneratorContext ctx) {
		
	}
	
	/* Builds the skeleton for the thy files represented by the BSharp file EMF in top, handles full
	 * file imports, and populates */
	def generateTheories(TopLevelFile top) {
		/* The final thy generated is the one that shares it's name with the BSharp files
		 * previous generated thys have the same name have an increasing integer appended.
		 * These are all put into an array for easy access */
		 val imports = top.topLevelImports
		 
		 if (imports === null || imports.length == 0) {
		 	/* There is only a top level file */
		 	val thy = TheoryUtils.createTheory(proj, fileName, null)
		 	theories += thy
		 	return
		 }
		 
		 var adder = 0
		 var ITheoryRoot prevTheory
		 
		 if (top.getNoImportElements() !== null) {
		 	val thy = TheoryUtils.createTheory(proj, fileName + Integer.toString(0), null)
		 	theories += thy
		 	prevTheory = thy
		 	adder++
		 }
		 
		 val importLen = imports.length
		 
		 for (i : 0 ..< importLen - 1) {
		 	val thy = TheoryUtils.createTheory(proj, fileName + Integer.toString(i + adder), null)
		 	
		 	if (prevTheory !== null) {
		 		val importProjBlock = TheoryUtils.createImportTheoryProject(thy, proj, nullMonitor)
		 		TheoryUtils.createImportTheory(importProjBlock, prevTheory, nullMonitor)
		 	}
		 	
		 	theories += thy
		 	prevTheory = thy
		 }
		 
		 val thy = TheoryUtils.createTheory(proj, fileName, null)
		 val importProjBlock = TheoryUtils.createImportTheoryProject(thy, proj, nullMonitor)
		 if (prevTheory !== null)
		 	TheoryUtils.createImportTheory(importProjBlock, prevTheory, nullMonitor)
		 
		 
		 theories += thy
	}
	
	def importLocalImports (LocalImport importBlock, Map<String, Boolean> typeImports, 
		ITheoryRoot thy, IImportTheoryProject localImportProj
	) {
		var importProj = localImportProj
		for (fileImport : importBlock.fileImports) {
			if (fileImport.type === null) {
				if (localImportProj === null) {
					importProj = TheoryUtils.createImportTheoryProject(thy, proj, nullMonitor)
				}
				
				//TheoryUtils.createImportTheory(importProj, )
			}
		}
	}
}