/*
 * generated by Xtext 2.12.0
 */
package ac.soton.bsharp.scoping

import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.scoping.impl.ImportedNamespaceAwareLocalScopeProvider
import org.eclipse.emf.common.util.EList
import java.util.List
import org.eclipse.xtext.scoping.impl.ImportNormalizer
import com.google.common.collect.Lists
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.naming.IQualifiedNameProvider
import javax.inject.Inject
import ac.soton.bsharp.bSharp.TopLevel
import ac.soton.bsharp.bSharp.TopLevelFile

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class BSharpImportedNamespaceAwareLocalScopeProvider extends ImportedNamespaceAwareLocalScopeProvider {
	@Inject extension IQualifiedNameProvider
	
	override internalGetImportedNamespaceResolvers(EObject context, boolean ignoreCase) {
		/* I need to override this method because getImportedNamespace returns a single object 
		 * and I need to return a list.
		 */
		 
		var List<ImportNormalizer> importedNamespaceResolvers = Lists.newArrayList()

		val packageName = context.fullyQualifiedName

		/* Add the package to the fully qualified domain names */
		if (context instanceof TopLevel) {
			var topLevel = context as TopLevel

			// fqn is the package of this file
			if (packageName !== null) {
				importedNamespaceResolvers += new ImportNormalizer(packageName, true, ignoreCase)
			}

			var topLevelFile = topLevel.topLevelFile
			val localImports = topLevelFile.localImports

			if (localImports !== null) {
				for (localImport : localImports) {
					for (imports : localImport.fileImports) {
						var importfileName = imports.fileName
						var importString = packageName + '.' + importfileName + '.'
						if (imports.type !== null) {
							importString += imports.type
						} else {
							importString += '*'
						}

					}
				}
			}
		
		val globalImports = topLevelFile.globalImports
		

//		for (child : eContents) {
//			val globals = child.eClass().getEStructuralFeature("globalImports")
//			val locals = child.eClass().getEStructuralFeature("localImports")
//			val feature = globals
//			if (feature !== null && String.equals(feature.getEType().getInstanceClass())) {
//				val list = child.eGet(feature) as EList<String>
//				for (importString : list) {
//					val resolver = createImportedNamespaceResolver(importString, ignoreCase)
//					if (resolver !== null) {
//						importedNamespaceResolvers.add(resolver)
//					}
//				}
//			}
//		}
		}

		return importedNamespaceResolvers
	}
	
	override getImplicitImports(boolean ignoreCase) {
		newArrayList(new ImportNormalizer(QualifiedName.create("ac", "soton", "bsharp", "main"), true, ignoreCase))
	}
}
