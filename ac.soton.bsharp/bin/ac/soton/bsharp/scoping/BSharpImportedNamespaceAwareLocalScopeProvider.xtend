/*
 * generated by Xtext 2.12.0
 */
package ac.soton.bsharp.scoping

import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.scoping.impl.ImportedNamespaceAwareLocalScopeProvider
import java.util.List
import org.eclipse.xtext.scoping.impl.ImportNormalizer
import com.google.common.collect.Lists
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.naming.IQualifiedNameProvider
import javax.inject.Inject
import ac.soton.bsharp.bSharp.TopLevel
import ac.soton.bsharp.bSharp.TopLevelImport
import org.eclipse.xtext.EcoreUtil2

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class BSharpImportedNamespaceAwareLocalScopeProvider extends ImportedNamespaceAwareLocalScopeProvider {
	@Inject extension IQualifiedNameProvider
	
	override internalGetImportedNamespaceResolvers(EObject context, boolean ignoreCase) {
		/* I need to override this method because getImportedNamespace returns a single object 
		 * and I need to return a list.
		 */
		 
		var List<ImportNormalizer> importedNamespaceResolvers = Lists.newArrayList()

		/* Add the package to the fully qualified domain names */
		if (context instanceof TopLevelImport) {
			var topLevelImport = context as TopLevelImport
			val topLevel = EcoreUtil2.getContainerOfType(topLevelImport, TopLevel)
			val packageName = topLevel.fullyQualifiedName
			
			/* Note that we know that the iterator contains at least one element as we only
			 * enter here it there is a TopLevelImport.
			 */
			val importBlocks = topLevel.topLevelFile.topLevelImports
			val iterator = importBlocks.iterator
			var TopLevelImport current
			do {
				current = iterator.next
				addImportsForTopLevelImport(current, importedNamespaceResolvers, packageName, ignoreCase)
			} while (current != context)
			
		}

		return importedNamespaceResolvers
	}
	
	def addImportsForTopLevelImport(TopLevelImport topLevel, List<ImportNormalizer> importedNamespaceResolvers,
		QualifiedName packageName, Boolean ignoreCase) {
			val localImports = topLevel.localImports
			val globalImports = topLevel.globalImports

			if (localImports !== null) {
				for (localImport : localImports) {
					for (imports : localImport.fileImports) {
						var importfileName = imports.fileName
						var importString = packageName + '.' + importfileName + '.'
						if (imports.type !== null) {
							importString += imports.type
						} else {
							importString += '*'
						}
						
						val resolver = createImportedNamespaceResolver(importString, ignoreCase)
						
						if (resolver !== null)
							importedNamespaceResolvers += resolver
						
					}
				}
			}
		
			if (globalImports !== null) {
				for (globalImport : globalImports) {
					val projName = globalImport.project
					
					/* I don't currently handle globalproj.* as I'd need to work out
					 * how to iterate over all the files in the global proj.
					 */
					for (file : globalImport.fileImports) {
						val importString = projName + '.' + file
						val resolver = createImportedNamespaceResolver(importString, ignoreCase)
						
						if (resolver !== null) {
							importedNamespaceResolvers += resolver
						}
					}
				}
			}
	}
	
	override getImplicitImports(boolean ignoreCase) {
		newArrayList(new ImportNormalizer(QualifiedName.create("ac", "soton", "bsharp", "main"), true, ignoreCase))
	}
}
